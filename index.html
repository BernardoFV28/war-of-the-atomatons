<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons V.1.2.5</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0a0000ce;
    }
    canvas {
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 1400,
  height: 600,
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: { debug: false }
  },
  scene: {
    preload,
    create,
    update
  }
};

let waveText;
let hudGroup;
let armaNomeText;
let armaImagem;
let player, cursors;
let bullets, enemies, enemyBullets, armas;
let lastShoot = 0;
let showingCards = false;
let wave = 1;
let cardsGroup;
let playerSpeed = 200;
let spiritAlly = null;

let playerStats = {
  life: 3,                    // Coraçãozin tá firme
  bulletDamage: 1,           // Dano padrão da bala
  fireRate: 3000,            // Delay entre tiros
  hasShield: false,          // Tem escudo ou não
  spiritAllyActive: false,   // Espírito aliado tá junto?
  spreadUpgrade: false,      // Tiro espalhado desbloqueado?
  doubleBullets: false,      // Dois tiros de uma vez?
  dashAvailable: false,      // Pode usar dash?
  dashCooldown: false,       // Tá em cooldown?
  slowEnemies: false,        // Inimigos lentos (efeito de carta)
  reviveOnce: false,         // Ressuscita uma vez?
  increasedDropRate: false,  // Mais chance de drop de arma?
  tripleBullets: false,      // Três tiros, modo overpowered
  freezeEnemies: false,      // Congela inimigos temporariamente
  healOnKill: false,         // Cura ao matar?
  damageAura: false,         // Aura de dano por perto
  speedBoost: false,         // Velocidade turbinada
  bulletPiercing: false      // Bala atravessa inimigos?
};

const tiposDeArmas = {
  arma1: { dano: 1, fireRate: 3000 }, // Pistola 
  arma2: { dano: 2, fireRate: 1000 }, // Metralhadora média
  arma3: { dano: 3, fireRate: 2000 } // Lança-raio brabo
};

const game = new Phaser.Game(config);

function preload() {
  this.load.image('player', 'assets/player.png');
  this.load.image('enemy', 'assets/enemy.png');
  this.load.image('bullet', 'assets/bullet.png');
  this.load.image('arma1', 'assets/pistolinha.png');
  this.load.image('arma2', 'assets/metralha.png');
  this.load.image('arma3', 'assets/lancarrio.png');
  this.load.image('fundogame', 'assets/fundogame.png'); 
  this.load.image('cora', 'assets/cora.png');
}

function create() {
      
  this.add.image(config.width / 2, config.height / 2, 'fundogame').setDepth(-1);

  player = this.physics.add.sprite(400, 300, 'player').setCollideWorldBounds(true).setScale(0.05);

  bullets = this.physics.add.group();
  enemies = this.physics.add.group();
  enemyBullets = this.physics.add.group();
  armas = this.physics.add.group();

  cursors = this.input.keyboard.createCursorKeys();

  spawnArmas.call(this);

  this.physics.add.overlap(player, armas, (player, arma) => {
    pegarArma.call(this, arma);
  });

  this.input.keyboard.on('keydown-Z', () => {
    if (playerStats.dashAvailable && !playerStats.dashCooldown) {
      dashPlayer.call(this);
    }
  });

  this.input.keyboard.on('keydown-SPACE', () => {
    if (!player.active) {
      this.time.delayedCall(500, () => {
        this.scene.restart();
      });
    }
  });

  spawnWave.call(this);

  this.physics.add.overlap(bullets, enemies, (b, e) => {
    if (b.active && e.active) {
      b.destroy();
      e.health = (e.health || 1) - playerStats.bulletDamage;
      if (e.health <= 0) e.destroy();
    }
  });

  this.physics.add.overlap(enemyBullets, player, (b, p) => {
    if (b.active && p.active) {
      b.destroy();
      if (!playerStats.hasShield) {
        p.setTint(0xff0000);
        this.time.delayedCall(100, () => p.clearTint());
      } else {
        playerStats.hasShield = false;
        this.cameras.main.setZoom(1);
        p.clearTint();
      }
    }
  });

  hudGroup = this.add.group();

  armaNomeText = this.add.text(config.width / 2, 20, 'Pistolinha', {
    fontFamily: 'Cinzel',
    fontSize: '28px',
    color: '#A62E2E',
    stroke: '#000000',
    strokeThickness: 4,
    shadow: { offsetX: 2, offsetY: 2, color: '#000', blur: 4, stroke: true, fill: true }
  }).setOrigin(0.5, 0);

  const box = this.add.rectangle(config.width / 2, 40, 300, 70, 0x111111, 0.3).setOrigin(0.5, 0);
  box.setStrokeStyle(2, 0x00ffff, 0.7);
  hudGroup.add(box);

  armaImagem = this.add.image(config.width / 2, 70, 'arma1').setScale(0.01);
  hudGroup.addMultiple([armaNomeText, armaImagem]);

  waveText = this.add.text(config.width - 20, 20, `Fase ${wave}`, {
    fontFamily: 'Cinzel',
    fontSize: '24px',
    color: '#FFFFFF',
    stroke: '#000000',
    strokeThickness: 4
  }).setOrigin(1, 0);

  this.time.addEvent({
    delay: 9000,
    loop: true,
    callback: () => {
      enemies.getChildren().forEach(enemy => {
        if (!enemy.active) return;
        const bullet = enemyBullets.create(enemy.x, enemy.y, 'bullet').setScale(0.01);
        const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
        this.physics.velocityFromRotation(angle, 150, bullet.body.velocity);
      });
    }
  });
}

function spawnArmas() {
  const tipos = Object.keys(tiposDeArmas);

  for (let i = 0; i < 3; i++) {
    const tipo = Phaser.Utils.Array.GetRandom(tipos);
    const x = Phaser.Math.Between(100, 1200);
    const y = Phaser.Math.Between(100, 500);
    const arma = armas.create(x, y, tipo).setScale(0.2);
    arma.tipo = tipo;
  }
}

function pegarArma(arma) {
  const props = tiposDeArmas[arma.tipo];

  playerStats.bulletDamage = props.dano;
  playerStats.fireRate = props.fireRate;

  arma.destroy();

  const nomeArmasMap = {
    arma1: 'Pistolinha',
    arma2: 'Fúria de Eryon',
    arma3: 'Lança-Raio'
  };

  atualizarHUDarma(nomeArmasMap[arma.tipo], arma.tipo);

  // Feedback visual style favela-glitch
  this.add.text(player.x, player.y - 30, `Pegou ${nomeArmasMap[arma.tipo]}!`, {
    fontSize: '18px',
    color: '#FFD700',
    fontStyle: 'bold',
    stroke: '#000',
    strokeThickness: 3
  }).setOrigin(0.5).setDepth(99).setScrollFactor(0).setAlpha(0.9)
    .setInteractive()
    .on('pointerdown', txt => txt.destroy());
}

function atualizarHUDarma(nomeArma, keyImagem) {
  armaNomeText.setText(nomeArma);
  armaImagem.setTexture(keyImagem);
}

function update(time) {
  if (!player.active) return;

  let vx = 0, vy = 0;
  if (cursors.left.isDown) vx = -1;
  else if (cursors.right.isDown) vx = 1;

  if (cursors.up.isDown) vy = -1;
  else if (cursors.down.isDown) vy = 1;

  const norm = Math.hypot(vx, vy) || 1;
  player.setVelocity((vx / norm) * playerSpeed, (vy / norm) * playerSpeed);

  if (time > lastShoot + playerStats.fireRate) {
    shootRadial.call(this);
    lastShoot = time;
  }

  enemies.getChildren().forEach(enemy => {
    if (!enemy.active) return;
    const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
    this.physics.velocityFromRotation(angle, 100, enemy.body.velocity);
  });

  if (enemies.countActive() === 0 && !showingCards) {
    showingCards = true;
    showCardChoices.call(this);
  }
}

function shootRadial() { 
  const count = playerStats.spreadUpgrade ? 24 : 12;
  const speed = 700;

  for (let i = 0; i < count; i++) {
    const angle = Phaser.Math.DegToRad((360 / count) * i);
    const bullet = bullets.create(player.x, player.y, 'bullet').setScale(0.02);
    this.physics.velocityFromRotation(angle, speed, bullet.body.velocity);
  }
}

function showCardChoices() {
  const cardOptions = [
    { nome: 'Escudo de Ivirik', desc: 'Proteção que te salva da morte uma vez', cor: 0xffc107, efeito: () => { playerStats.hasShield = true; } },
    { nome: 'Tiro Duplo', desc: 'Dispara duas vezes mais balas', cor: 0x4caf50, efeito: () => { playerStats.doubleBullets = true; } },
    { nome: 'Bênção do Espírito', desc: 'Espírito aliado ajuda no ataque', cor: 0x00bcd4, efeito: ativarSpiritAlly },
    { nome: 'Upgrade do Spread', desc: 'Dispara balas em círculo maior', cor: 0x9c27b0, efeito: () => { playerStats.spreadUpgrade = true; } },
    { nome: 'Dash ', desc: 'Corrida rápida para escapar', cor: 0xf44336, efeito: () => { playerStats.dashAvailable = true; } },
    { nome: 'Projétil Perfurante', desc: 'Balas atravessam inimigos', cor: 0x03a9f4, efeito: () => { playerStats.piercingShots = true; } },
    { nome: 'Recuperação Instantânea', desc: 'Recupera 2 de vida', cor: 0x8bc34a, efeito: () => { player.health = Math.min(player.health + 2, player.maxHealth); } },
    { nome: 'Fúria de Metalion', desc: 'Aumenta o dano por 15s', cor: 0xff5722, efeito: () => { playerStats.damageBoost = true; setTimeout(() => { playerStats.damageBoost = false; }, 15000); } },
    { nome: 'Vida Fantasma', desc: 'Sobrevive com 1 de vida ao morrer', cor: 0x673ab7, efeito: () => { playerStats.phantomLife = true; } },
    { nome: 'Espinhos do Asfalto', desc: 'Dano nos inimigos ao ser atingido', cor: 0xe91e63, efeito: () => { playerStats.thorns = true; } },
  ];

  Phaser.Utils.Array.Shuffle(cardOptions);
  const selectedCards = cardOptions.slice(0, 3);

  cardsGroup = this.add.group();

  const startX = this.cameras.main.centerX;
  const startY = this.cameras.main.centerY;
  const gap = 220;

  selectedCards.forEach((card, i) => {
    const x = startX + (i - 1) * gap;
    const y = startY;

    const container = this.add.container(x, y);

    const bg = this.add.rectangle(0, 0, 160, 240, card.cor, 0.8).setStrokeStyle(4, 0xffffff);
    const title = this.add.text(0, -80, card.nome, { fontSize: '20px', color: '#fff', align: 'center', wordWrap: { width: 140 } }).setOrigin(0.5);
    const desc = this.add.text(0, 0, card.desc, { fontSize: '14px', color: '#eee', align: 'center', wordWrap: { width: 140 } }).setOrigin(0.5);

    container.add([bg, title, desc]);
    container.setSize(160, 240);
    container.setInteractive();

    this.tweens.add({
      targets: container,
      y: y - 20,
      yoyo: true,
      repeat: -1,
      duration: 1000,
      ease: 'Sine.easeInOut'
    });

    container.on('pointerover', () => {
      container.setScale(1.1);
    });

    container.on('pointerout', () => {
      container.setScale(1);
    });

    container.on('pointerdown', () => {
      this.tweens.add({
        targets: container,
        scale: 0.9,
        duration: 100,
        yoyo: true,
        ease: 'Power1',
        onComplete: () => {
          card.efeito();
          cardsGroup.clear(true, true);
          showingCards = false;
          wave++;
          waveText.setText(`Fase ${wave}`);
          spawnWave.call(this);
        }
      });
    });

    cardsGroup.add(container);
  });
}

function ativarSpiritAlly() {
  if (spiritAlly) spiritAlly.destroy();

  spiritAlly = this.physics.add.sprite(player.x, player.y, 'player').setScale(0.03).setAlpha(0.7);
  playerStats.spiritAllyActive = true;

  this.time.addEvent({
    delay: 15000,
    callback: () => {
      if (spiritAlly) spiritAlly.destroy();
      playerStats.spiritAllyActive = false;
    }
  });
}

function spawnWave() {
  for (let i = 0; i < wave * 3; i++) {
    const x = Phaser.Math.Between(100, 1200);
    const y = Phaser.Math.Between(100, 500);
    const enemy = enemies.create(x, y, 'enemy').setScale(0.05);
    enemy.health = 3 + wave;
    enemy.maxHealth = enemy.health;
    enemy.setCollideWorldBounds(true);
  }
}

function dashPlayer() {
  if (playerStats.dashCooldown) return; // evita dash no cooldown, sem vacilo

  playerStats.dashCooldown = true;

  // Direção do dash, pegando o input do cursors
  let dx = 0, dy = 0;
  if (cursors.left.isDown) dx = -1;
  else if (cursors.right.isDown) dx = 1;
  if (cursors.up.isDown) dy = -1;
  else if (cursors.down.isDown) dy = 1;

  // Se não apertou nenhuma direção, não dá dash, tá ligado?
  if (dx === 0 && dy === 0) {
    playerStats.dashCooldown = false; // libera de novo porque não rolou dash
    return;
  }

  const dashDistance = 150;

  this.tweens.add({
    targets: player,
    x: player.x + dx * dashDistance,
    y: player.y + dy * dashDistance,
    duration: 150,
    ease: 'Power2',
    onComplete: () => {
      playerStats.dashCooldown = false; // libera o dash depois do tempo
    }
  });
}

class HUD {
  constructor(scene, player) {
    this.scene = scene;
    this.player = player;
    
    this.maxHealth = player.maxHealth || 5;
    this.currentHealth = player.health;
    
    this.heartSize = 20;
    this.heartSpacing = 30;
    
    this.heartsGraphics = [];
    
    this.createHearts();
    
    // Barra de vida do inimigo
    this.enemyHealthBarBg = scene.add.graphics();
    this.enemyHealthBarFill = scene.add.graphics();
    
    // Posicionamento barra de inimigo
    this.enemyHealthBarX = 20;
    this.enemyHealthBarY = 60;
    this.enemyHealthBarWidth = 120;
    this.enemyHealthBarHeight = 20;
  }
  
  createHearts() {
    for(let i = 0; i < this.maxHealth; i++) {
      let g = this.scene.add.graphics();
      g.setScrollFactor(0);
      g.x = 20 + i * this.heartSpacing;
      g.y = 20;
      this.drawHeart(g, true); // inicialmente cheio
      this.heartsGraphics.push(g);
    }
  }
  
  drawHeart(graphics, full) {
    graphics.clear();
    const size = this.heartSize;
    
    if(full) {
      graphics.fillStyle(0xff0000, 1);
      graphics.lineStyle(2, 0x880000, 1);
    } else {
      graphics.fillStyle(0x550000, 0.3);
      graphics.lineStyle(2, 0x330000, 1);
    }
    
    // Desenho simples de coração
    graphics.beginPath();
    graphics.moveTo(size / 2, size);
    graphics.bezierCurveTo(size / 2 + size / 2, size / 2, size, size / 2, size, size / 4);
    graphics.bezierCurveTo(size, 0, size / 2, 0, size / 2, size / 4);
    graphics.bezierCurveTo(size / 2, 0, 0, 0, 0, size / 4);
    graphics.bezierCurveTo(0, size / 2, size / 2 - size / 2, size / 2, size / 2, size);
    graphics.closePath();
    graphics.fillPath();
    graphics.strokePath();
  }
  
 
  
  updateEnemyHealthBar(enemy) {
    this.enemyHealthBarBg.clear();
    this.enemyHealthBarFill.clear();
    
    // Fundo cinza
    this.enemyHealthBarBg.fillStyle(0x222222, 1);
    this.enemyHealthBarBg.fillRect(this.enemyHealthBarX, this.enemyHealthBarY, this.enemyHealthBarWidth, this.enemyHealthBarHeight);
    
    if (!enemy || enemy.health <= 0) return;
    
    const ratio = Phaser.Math.Clamp(enemy.health / enemy.maxHealth, 0, 1);
    const barWidth = this.enemyHealthBarWidth * ratio;
    
    // Barra vermelha
    this.enemyHealthBarFill.fillStyle(0xff0000, 1);
    this.enemyHealthBarFill.fillRect(this.enemyHealthBarX, this.enemyHealthBarY, barWidth, this.enemyHealthBarHeight);
  }
}

</script>

</body>
</html>

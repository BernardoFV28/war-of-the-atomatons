<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons B - A Cruzada da Rainha</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0a0000ce;
    }
    canvas {
      display: block;
      margin: auto;
    }
    /* Styles for the Level Up/Card Selection Menu */
    .menu-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .menu-container {
      background-color: #333;
      border: 2px solid #555;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      color: #FFF;
      width: 70%;
      max-width: 900px;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
    }
    .menu-title {
      font-size: 36px;
      margin-bottom: 20px;
      color: #00FFFF;
    }
    .cards-container {
      display: flex;
      justify-content: space-around;
      gap: 20px;
      flex-wrap: wrap;
    }
    .card {
      background-color: #222;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 15px;
      width: 250px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: left;
      min-height: 220px; /* Ensures consistent height */
      position: relative;
    }
    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 5px 20px rgba(0, 255, 255, 0.5);
    }
    .card.selected {
      border-color: #00FFFF;
      box-shadow: 0 0 25px rgba(0, 255, 255, 0.9);
    }
    .card-title {
      font-size: 22px;
      margin-bottom: 5px;
      color: #FFD700;
      text-align: center;
      width: 100%;
    }
    .card-description {
      font-size: 14px;
      color: #CCC;
      flex-grow: 1; /* Pushes button to bottom */
    }
    .card-button {
      background-color: #008CBA;
      color: white;
      padding: 10px 15px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 15px;
    }
    .card-button:hover {
      background-color: #005F7F;
    }
    .card-rarity {
        font-size: 12px;
        font-style: italic;
        margin-top: 5px;
        margin-bottom: 10px;
        width: 100%;
        text-align: center;
    }

    /* Shop Menu Styles */
    .shop-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .shop-container {
      background-color: #333;
      border: 2px solid #555;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      color: #FFF;
      width: 70%;
      max-width: 800;
      box-shadow: 0 0 15px rgba(255, 165, 0, 0.7);
    }
    .shop-title {
      font-size: 36px;
      margin-bottom: 20px;
      color: #FFA500;
    }
    .shop-items-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .shop-item {
      background-color: #222;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: left;
    }
    .shop-item-name {
      font-size: 18px;
      color: #FFD700;
      margin-bottom: 5px;
    }
    .shop-item-desc {
      font-size: 13px;
      color: #CCC;
      flex-grow: 1;
      margin-bottom: 10px;
    }
    .shop-item-cost {
      font-size: 16px;
      color: #00FF00;
      margin-top: auto; /* Push to bottom */
    }
    .shop-item-button {
      background-color: #28a745;
      color: white;
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-top: 10px;
    }
    .shop-item-button:disabled {
      background-color: #555;
      cursor: not-allowed;
    }
    .shop-close-button {
      background-color: #dc3545;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 18px;
      margin-top: 20px;
    }
    .shop-close-button:hover {
      background-color: #c82333;
    }
    .shop-currency-display {
      font-size: 24px;
      color: #FFD700;
      margin-bottom: 15px;
    }

    /* Pause Menu Styles (Adjusted) */
    .pause-overlay {
      position: absolute;
      top: 10%; /* Move up slightly */
      left: 10%; /* Move right slightly */
      width: 80%; /* Smaller width */
      height: 70%; /* Smaller height */
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1100;
    }
    .pause-container {
      background-color: #222;
      border: 2px solid #666;
      padding: 20px; /* Reduced padding */
      border-radius: 10px;
      text-align: center;
      color: #FFF;
      width: 80%; /* Adjusted relative to overlay */
      max-width: 900px; /* Reduced max-width */
      box-shadow: 0 0 20px rgba(128, 0, 128, 0.7);
      display: flex;
      flex-direction: column;
    }
    .pause-title {
      font-size: 40px; /* Reduced font size */
      margin-bottom: 20px; /* Reduced margin */
      color: #9932CC;
    }
    .pause-tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 15px; /* Reduced margin */
      gap: 8px; /* Reduced gap */
    }
    .pause-tab-button {
      background-color: #444;
      color: #FFF;
      padding: 8px 15px; /* Reduced padding */
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px; /* Reduced font size */
      transition: background-color 0.2s;
    }
    .pause-tab-button:hover {
      background-color: #666;
    }
    .pause-tab-button.active {
      background-color: #9932CC;
      font-weight: bold;
    }
    .pause-content {
      background-color: #333;
      padding: 15px; /* Reduced padding */
      border-radius: 8px;
      text-align: left;
      min-height: 250px; /* Reduced min-height */
      max-height: 400px; /* Reduced max-height */
      overflow-y: auto;
      margin-bottom: 15px; /* Reduced margin */
    }
    .pause-close-button {
      background-color: #8A2BE2;
      color: white;
      padding: 10px 20px; /* Reduced padding */
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 18px; /* Reduced font size */
      margin-top: 10px; /* Reduced margin */
    }
    .pause-close-button:hover {
      background-color: #6A1BA0;
    }

    /* Specific Tab Styles */
    #stats-tab-content p {
      margin-bottom: 6px; /* Reduced margin */
      font-size: 16px; /* Reduced font size */
    }
    #stats-tab-content strong {
      color: #00FFFF;
    }

    .skill-category {
      margin-bottom: 15px; /* Reduced margin */
      border: 1px solid #555;
      padding: 10px; /* Reduced padding */
      border-radius: 8px;
      background-color: #2b2b2b;
    }
    .skill-category-title {
      font-size: 22px; /* Reduced font size */
      color: #FFD700;
      margin-bottom: 8px; /* Reduced margin */
      text-align: center;
    }
    .skill-talent {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 0; /* Reduced padding */
      border-bottom: 1px dotted #444;
    }
    .skill-talent:last-child {
      border-bottom: none;
    }
    .skill-talent-info {
      flex-grow: 1;
    }
    .skill-talent-name {
      font-size: 16px; /* Reduced font size */
      color: #00FFFF;
    }
    .skill-talent-desc {
      font-size: 13px; /* Reduced font size */
      color: #BBB;
    }
    .skill-talent-level {
      font-size: 14px; /* Reduced font size */
      color: #FFF;
      margin-left: 8px; /* Reduced margin */
    }
    .skill-talent-button {
      background-color: #28a745;
      color: white;
      padding: 4px 8px; /* Reduced padding */
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px; /* Reduced font size */
      margin-left: 10px; /* Reduced margin */
    }
    .skill-talent-button:disabled {
      background-color: #555;
      cursor: not-allowed;
    }
    .skill-points-display {
      font-size: 18px; /* Reduced font size */
      color: #FFD700;
      margin-bottom: 10px; /* Reduced margin */
      text-align: center;
    }

    #quests-tab-content .quest-item {
        margin-bottom: 8px; /* Reduced margin */
        padding: 8px; /* Reduced padding */
        border: 1px solid #555;
        border-radius: 5px;
        background-color: #2b2b2b;
    }
    #quests-tab-content .quest-title {
        font-size: 16px; /* Reduced font size */
        color: #00FFFF;
        margin-bottom: 4px; /* Reduced margin */
    }
    #quests-tab-content .quest-desc {
        font-size: 13px; /* Reduced font size */
        color: #BBB;
    }
    #quests-tab-content .quest-progress {
        font-size: 13px; /* Reduced font size */
        color: #99FF99;
    }
    #quests-tab-content .quest-reward {
        font-size: 13px; /* Reduced font size */
        color: #FFD700;
    }
    #achievements-tab-content .achievement-item {
        margin-bottom: 8px; /* Reduced margin */
        padding: 8px; /* Reduced padding */
        border: 1px solid #555;
        border-radius: 5px;
        background-color: #2b2b2b;
    }
    #achievements-tab-content .achievement-title {
        font-size: 16px; /* Reduced font size */
        color: #FFD700;
        margin-bottom: 4px; /* Reduced margin */
    }
    #achievements-tab-content .achievement-desc {
        font-size: 13px; /* Reduced font size */
        color: #BBB;
    }
    #achievements-tab-content .achievement-status {
        font-size: 13px; /* Reduced font size */
        font-weight: bold;
    }
    #achievements-tab-content .unlocked {
        color: #00FF00;
    }
    #achievements-tab-content .locked {
        color: #FF0000;
    }

  </style>
</head>
<body>
<script>
// --- Configuration ---
const config = {
  type: Phaser.AUTO,
  width: 1320, 
  height: 590, 
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: {
        debug: false, // Set to true for debugging hitboxes
        gravity: { y: 0 }
    }
  },
  scene: {
    preload,
    create,
    update
  }
};

// --- Game Constants ---
const PLAYER_INITIAL_SCALE = 0.08;
const BULLET_INITIAL_SPEED = 500;
const BULLET_INITIAL_SCALE = 0.01; // As requested, very small bullet
const PLAYER_DEFAULT_TINT = 0xFFFFFF; // White
const PLAYER_DASH_DURATION = 150;
const PLAYER_DASH_DISTANCE = 300; // Increased dash distance slightly
const DASH_COOLDOWN_BASE = 3000;
const PLAYER_ACCELERATION = 2000; // NEW: Acceleration for smoother movement
const PLAYER_DRAG = 0.9; // NEW: Friction/drag for smoother stopping

// --- Global Variables (Game Objects & State) ---
let player, cursors;
let bullets, enemies, enemyBullets, armas, itemsGroup, destructiblesGroup, dronesGroup; // Added destructiblesGroup, dronesGroup
let lastShoot = 0;
let lastEnemySpawn = 0;
let waveNumber = 1;
let enemiesInWave = 5;
let enemiesSpawnedThisWave = 0;
let enemySpawnRate = 2000;
let temporaryEffectText = null;
let temporaryEffectTimer = null;
let killStreak = 0;
let killStreakTimer;
let currentWeapon = 1; // 1: Pistolinha, 2: Metralha, 3: Lança-rio
let weaponSwitchCooldown = false;
let playerOriginalTint = PLAYER_DEFAULT_TINT; // Store original player tint
let gamePaused = false; // To manage pause menu state
let playerDashCooldownTimer = null; // To manage dash cooldown visually
let levelUpMenuOpen = false; // NEW: To track if level up menu is open
let shopMenuOpen = false; // NEW: To track if shop menu is open
let pauseMenuOpen = false; // NEW: To track if pause menu is open

// --- Player Stats & RPG Attributes ---
let playerStats = {
  life: 3,
  maxLife: 3,
  bulletDamage: 1,
  fireRate: 300, // Cooldown in ms, lower is faster
  playerSpeed: 1000, // Now used as maxSpeed
  xp: 0,
  level: 1,
  xpToNextLevel: 100,
  skillPoints: 0, // Points gained on level up for RPG stats
  currency: 0,    // Currency for shop
  // Core RPG Attributes
  strength: 1,    // Affects bulletDamage, possibly touchDamage
  agility: 1,     // Affects fireRate, playerSpeed, evasionChance
  constitution: 1,// Affects maxLife, passiveRegen
  intelligence: 1,// Affects cooldowns, possibly unique abilities

  // Skill Tree Trackers (NEW)
  skillTree: {
    strength: {
      "FuriaAutomatica": { level: 0, maxLevel: 3, description: "+Dano para cada inimigo próximo" },
      "PerfuracaoMecanica": { level: 0, maxLevel: 1, description: "Bala perfurante" }
    },
    agility: {
      "ReflexosRapidos": { level: 0, maxLevel: 3, description: "+Velocidade de movimento" },
      "TiroDuplo": { level: 0, maxLevel: 1, description: "Atira 2 balas" }
    },
    constitution: {
      "BlindagemAprimorada": { level: 0, maxLevel: 3, description: "+Vida Máxima" },
      "AutoReparo": { level: 0, maxLevel: 1, description: "Regen passiva de vida" }
    },
    intelligence: {
      "CargaRapida": { level: 0, maxLevel: 3, description: "Reduz Cooldowns de itens ativáveis" },
      "AnaliseDeAmeaca": { level: 0, maxLevel: 1, description: "Revela inimigos fora da tela no minimapa" }
    },
    // NEW: Biopunk Category
    "bio-mutacao": {
        "RegeneracaoAtiva": { level: 0, maxLevel: 3, description: "Aumenta a regeneração passiva de vida do jogador." },
        "SinfoniaParasitaria": { level: 0, maxLevel: 1, description: "Inimigos que causam dano ao jogador recebem dano de veneno por 3 segundos." },
        "MembranaBioReativa": { level: 0, maxLevel: 2, description: "Após ser atingido, ganha uma breve redução de dano." }
    }
  },

  // Existing Item/Effect Flags
  hasShield: false,
  spiritAllyActive: false, // Placeholder, can be a drone now
  spreadUpgrade: false,
  doubleBullets: false,
  dashAvailable: true,
  dashCooldown: false,
  slowEnemies: false,
  reviveOnce: false,
  increasedDropRate: false,
  tripleBullets: false,
  healOnKill: false,
  damageAura: false,
  speedBoost: false,
  bulletPiercing: false,
  thorns: false,
  bulletSpeedBoost: false,
  spikeAuraActive: false,
  reflectDamage: 0,
  lifestealOnKill: 0,
  touchDamage: 0,
  passiveRegenActive: false,
  passiveRegenAmount: 0.1, // Base passive regen amount
  evasionChance: 0,
  bulletRange: 1,
  droneActive: false, // Now managed by dronesGroup
  dashVulnerability: 0,
  distortionFieldActive: false,
  incomingDamageMultiplier: 1, // To reduce damage taken (e.g., from armor)
  safeZoneActive: false,
  bulletCountMultiplier: 1,
  cloneActive: false,
  weaponBulletSpeed: BULLET_INITIAL_SPEED, // Base bullet speed
  poisonTrail: false, // NEW: For Coração Fraturado de Basilisco
  lumirenTeleport: false, // NEW: For Fragmento de Lumiren
  igniunExplosion: false, // NEW: For Sopro de Igniun
  metalionEchoActive: false, // NEW: For Eco de Metalion
  // Status Effects (NEW)
  statusEffects: {
      burning: { active: false, duration: 0, damagePerTick: 0, timer: null },
      poisoned: { active: false, duration: 0, damagePerTick: 0, timer: null }, // For Sinfonia Parasitária
      slowed: { active: false, duration: 0, slowFactor: 0, timer: null },
      stunned: { active: false, duration: 0, timer: null },
      damageReductionActive: false, // For Membrana Bio-Reativa
      damageReductionAmount: 0,
      damageReductionTimer: null,
      // ... more effects
  },
  // Resources (NEW)
  rareParts: 0, // For crafting
  // Achievements (NEW)
  achievements: {
    'FirstKill': { unlocked: false, description: "Derrote seu primeiro inimigo." },
    'Wave10': { unlocked: false, description: "Alcance a Onda 10." },
    'MaxLevel': { unlocked: false, description: "Alcance o Nível Máximo (50)." },
    'Collect1000Scrap': { unlocked: false, description: "Colete 1000 Sucatas." },
    'BossSlayer': { unlocked: false, description: "Derrote um Chefe." },
    // ... more achievements
  },
  // Quest System (NEW)
  activeQuests: [],
  completedQuests: [],
};

// --- Enemy Definitions ---
const enemyTypes = {
  normal: {
    texture: 'enemy_robot',
    baseHealth: 4,
    speed: 800,
    scale: 0.06,
    xpReward: 20,
    currencyReward: 5,
    attacks: [] // No special attack
  },
  fast: {
    texture: 'enemy_fast',
    baseHealth: 4,
    speed: 880,
    scale: 0.06,
    xpReward: 25,
    currencyReward: 7,
    attacks: []
  },
  tank: {
    texture: 'enemy_tank',
    baseHealth: 9,
    speed: 700,
    scale: 0.08,
    xpReward: 35,
    currencyReward: 10,
    attacks: []
  },
  healer: { // NEW ENEMY: Heals allies
    texture: 'enemy_tank', // Using existing asset
    baseHealth: 7,
    speed: 780,
    scale: 0.07,
    xpReward: 30,
    currencyReward: 8,
    attacks: ['heal'] // Special attack type
  },
  kamikaze: { // NEW ENEMY: Explodes on player contact
    texture: 'enemy_fast', // Using existing asset
    baseHealth: 5,
    speed: 850,
    scale: 0.06,
    xpReward: 25,
    currencyReward: 6,
    attacks: ['explode']
  },
  shooter: { // NEW ENEMY: Shoots back
    texture: 'enemy_tank', // Using existing asset
    baseHealth: 6,
    speed: 890,
    scale: 0.07,
    xpReward: 28,
    currencyReward: 9,
    attacks: ['shoot']
  },
  boss_robot: {
    texture: 'boss_robot',
    baseHealth: 200, // Boss health
    speed: 890,
    scale: 0.2, // Larger scale for boss
    xpReward: 500,
    currencyReward: 50,
    attacks: ['shoot', 'summon_minions', 'charge'] // Boss special attacks
  }
};

// --- Item Rarity Definitions (NEW) ---
const itemRarities = {
    common: { color: '#FFFFFF', dropChanceModifier: 1.0 },
    rare: { color: '#00BFFF', dropChanceModifier: 0.5 },
    epic: { color: '#9932CC', dropChanceModifier: 0.2 },
    legendary: { color: '#FFD700', dropChanceModifier: 0.05 }
};

// --- Item Definitions (Card System) ---
// IMAGES FOR NEW ITEMS REPLACED WITH 'ammo' TO AVOID ERRORS
const itemOptions = [
  { nome: "Núcleo de Energia (Passivo)", descricao: "Aumenta o dano da bala.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.bulletDamage += 0.5; }, peso: 1, rarity: 'common' },
  { nome: "Óculos de Precisão (Passivo)", descricao: "Aumenta a velocidade de ataque.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.fireRate = Math.max(50, playerStats.fireRate * 0.9); }, peso: 1, rarity: 'common' },
  { nome: "Módulo de Salto (Ativável)", descricao: "Permite usar Dash.", tipo: "ativavel", textura: "ammo", cooldown: 5000, efeito: (scene) => { playerStats.dashAvailable = true; }, peso: 1, rarity: 'common' },
  { nome: "Corrente Eletrostática (Passivo)", descricao: "Bala perfurante.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.bulletPiercing = true; }, peso: 1, rarity: 'rare' },
  { nome: "Máscara de Gás (Passivo)", descricao: "Cria uma aura de dano ao redor do jogador.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.damageAura = true; }, peso: 1, rarity: 'rare' },
  { nome: "Armadura Reconstruída (Passivo)", descricao: "Reduz o dano recebido.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.incomingDamageMultiplier -= 0.1; playerStats.incomingDamageMultiplier = Math.max(0.5, playerStats.incomingDamageMultiplier); }, peso: 1, rarity: 'rare' },
  { nome: "Overclock (Ativável)", descricao: "Aumenta temporariamente a velocidade de movimento.", tipo: "ativavel", textura: "ammo", cooldown: 10000, efeito: (scene) => { playerStats.speedBoost = true; scene.time.delayedCall(3000, () => { playerStats.speedBoost = false; }); }, peso: 1, rarity: 'common' },
  { nome: "DPE (Passivo)", descricao: "Atira duas balas por vez.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.doubleBullets = true; }, peso: 1, rarity: 'common' },
  { nome: "Armadura Camuflada (Passivo)", descricao: "Chance de desviar de ataques.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.evasionChance += 0.1; }, peso: 1, rarity: 'rare' },
  { nome: "Bateria de Nêutrons (Passivo)", descricao: "Vida máxima +1.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.maxLife += 1; playerStats.life = playerStats.maxLife; scene.hud.updateHealthBar(); }, peso: 1, rarity: 'common' },
  { nome: "Mini Drone de Ataque (Passivo)", descricao: "Spawna um drone aliado.", tipo: "passivo", textura: "ammo", efeito: (scene) => { spawnDrone.call(scene, 'attack'); }, peso: 1, rarity: 'epic' }, // Uses new drone system
  { nome: "Capacitor de Pulso (Passivo)", descricao: "Aumenta o alcance das balas.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.bulletRange += 0.5; }, peso: 1, rarity: 'common' },
  { nome: "Módulos de Resfriamento (Ativável)", descricao: "Reduz cooldowns de itens ativáveis.", tipo: "ativavel", textura: "ammo", cooldown: 20000, efeito: (scene) => { /* Handled by Intelligence/Metalion Echo now */ }, peso: 1, rarity: 'rare' },
  { nome: "Transdutor de Energia (Passivo)", descricao: "Recupera vida ao matar inimigos.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.healOnKill = true; playerStats.lifestealOnKill = 0.5; }, peso: 1, rarity: 'common' },
  { nome: "Campo de Distorção (Ativável)", descricao: "Cria zona segura por um tempo.", tipo: "ativavel", textura: "ammo", cooldown: 15000, efeito: (scene) => { playerStats.safeZoneActive = true; scene.time.delayedCall(5000, () => { playerStats.safeZoneActive = false; }); }, peso: 1, rarity: 'rare' },
  { nome: "Estabilizador de Matriz (Passivo)", descricao: "Atira 3 balas por vez.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.tripleBullets = true; }, peso: 1, rarity: 'epic' },
  { nome: "Regenerador Automático (Passivo)", descricao: "Regeneração passiva de vida.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.passiveRegenActive = true; }, peso: 1, rarity: 'rare' },
  { nome: "Arma Espinhenta (Passivo)", descricao: "Dano de espinhos ao ser atingido.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.thorns = true; playerStats.reflectDamage = 0.2; }, peso: 1, rarity: 'rare' },
  { nome: "Refletor de Dano (Ativável)", descricao: "Reflete dano por um tempo.", tipo: "ativavel", textura: "ammo", cooldown: 10000, efeito: (scene) => { playerStats.reflectDamage = 1; scene.time.delayedCall(3000, () => { playerStats.reflectDamage = 0; }); }, peso: 1, rarity: 'epic' },
  { nome: "Pele Metálica (Passivo)", descricao: "Dano ao toque (player).", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.touchDamage = 1; }, peso: 1, rarity: 'rare' },
  { nome: "Modulo de Carga Rápida (Passivo)", descricao: "Aumenta velocidade da bala.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.bulletSpeedBoost = true; playerStats.weaponBulletSpeed += 100; }, peso: 1, rarity: 'common' },
  { nome: "Casulo de Segurança (Ativável)", descricao: "Recupera 1 de vida ao ser ativado.", tipo: "ativavel", textura: "ammo", cooldown: 15000, efeito: (scene) => { playerStats.life = Math.min(playerStats.life + 1, playerStats.maxLife); scene.hud.updateHealthBar(); }, peso: 1, rarity: 'rare' },
  { nome: "Camuflagem Óptica (Passivo)", descricao: "Chance de reviver uma vez.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.reviveOnce = true; }, peso: 1, rarity: 'epic' },
  { nome: "Magnetizador de Sucata (Passivo)", descricao: "Aumenta drop de sucata.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.increasedDropRate = true; }, peso: 1, rarity: 'common' },
  { nome: "Criador de Clones (Ativável)", descricao: "Cria clone que atira.", tipo: "ativavel", textura: "ammo", cooldown: 20000, efeito: (scene) => { playerStats.cloneActive = true; scene.time.delayedCall(5000, () => { playerStats.cloneActive = false; }); }, peso: 1, rarity: 'epic' },
  {
    nome: "Coração Fraturado de Basilisco",
    descricao: "+5% dano, -2 vida máxima, tiros deixam veneno.",
    tipo: "passivo",
    textura: "ammo", // Replaced missing texture
    efeito: (scene) => {
      playerStats.bulletDamage *= 1.05;
      playerStats.maxLife = Math.max(1, playerStats.maxLife - 2);
      playerStats.life = Math.min(playerStats.life, playerStats.maxLife);
      scene.hud.updateHealthBar();
      playerStats.poisonTrail = true;
    },
    peso: 1, rarity: 'legendary'
  },
  {
    nome: "Raiz Sem Alma",
    descricao: "Dash infinito por 10s, perde -1 vida máxima.",
    tipo: "ativavel",
    textura: "ammo", // Replaced missing texture
    cooldown: 30000,
    efeito: (scene) => {
      playerStats.dashCooldown = false;
      scene.time.delayedCall(10000, () => {
        playerStats.dashCooldown = DASH_COOLDOWN_BASE;
        playerStats.maxLife = Math.max(1, playerStats.maxLife - 1);
        playerStats.life = Math.min(playerStats.life, playerStats.maxLife);
        scene.hud.updateHealthBar();
      });
    },
    peso: 1, rarity: 'epic'
  },
  {
    nome: "Eco de Metalion",
    descricao: "Cooldowns -20%, usar item perde 5% velocidade até fim da wave.",
    tipo: "passivo",
    textura: "ammo", // Replaced missing texture
    efeito: (scene) => {
      playerStats.metalionEchoActive = true;
    },
    peso: 1, rarity: 'rare'
  },
  {
    nome: "Fragmento de Lumiren",
    descricao: "Atirar teleporta 50px p/ trás, cada tp consome 1 vida.",
    tipo: "passivo",
    textura: "ammo", // Replaced missing texture
    efeito: (scene) => {
      playerStats.lumirenTeleport = true;
    },
    peso: 1, rarity: 'legendary'
  },
  {
    nome: "Sopro de Igniun",
    descricao: "Com <10% vida, explode em fogo mas morre depois de 5s.",
    tipo: "passivo",
    textura: "ammo", // Replaced missing texture
    efeito: (scene) => {
      playerStats.igniunExplosion = true;
    },
    peso: 1, rarity: 'legendary'
  },
];

// --- Item Sets (NEW) ---
const itemSets = {
    "Ataque Cibernético": {
        items: ["Núcleo de Energia (Passivo)", "DPE (Passivo)", "Estabilizador de Matriz (Passivo)"],
        bonus: (scene) => {
            playerStats.bulletDamage *= 1.2; // +20% bullet damage
            playerStats.fireRate = Math.max(50, playerStats.fireRate * 0.85); // +15% fire rate
            scene.hud.displayTemporaryEffect('Bônus de Conjunto: Ataque Cibernético!', '#FF8C00', 2000);
        },
        bonusApplied: false
    },
    "Defesa Robusta": {
        items: ["Armadura Reconstruída (Passivo)", "Bateria de Nêutrons (Passivo)", "Armadura Camuflada (Passivo)"],
        bonus: (scene) => {
            playerStats.maxLife += 2;
            playerStats.life = playerStats.maxLife; // Heal to new max
            playerStats.incomingDamageMultiplier *= 0.9; // Another 10% damage reduction
            scene.hud.updateHealthBar();
            scene.hud.displayTemporaryEffect('Bônus de Conjunto: Defesa Robusta!', '#00BFFF', 2000);
        },
        bonusApplied: false
    }
};

// --- Shop Items Definitions ---
const shopItems = [
  {
    nome: "Kit de Reparos Emergencial",
    descricao: "Restaura uma porção de vida.",
    tipo: "consumable",
    custo: 25,
    efeito: (scene) => { playerStats.life = Math.min(playerStats.life + 1, playerStats.maxLife); scene.hud.updateHealthBar(); },
    purchasedCount: 0
  },
  {
    nome: "Módulo de Calibração de Armas",
    descricao: "Aumenta permanentemente o dano de suas balas.",
    tipo: "upgrade",
    custo: 50,
    efeito: (scene) => { playerStats.bulletDamage += 0.5; },
    maxPurchases: 5,
    purchasedCount: 0
  },
  {
    nome: "Placa de Titânio Extra",
    descricao: "Aumenta sua vida máxima.",
    tipo: "upgrade",
    custo: 75,
    efeito: (scene) => { playerStats.maxLife += 1; playerStats.life = Math.min(playerStats.life + 1, playerStats.maxLife); scene.hud.updateHealthBar(); },
    maxPurchases: 3,
    purchasedCount: 0
  },
  {
    nome: "Recarga Rápida de Habilidade",
    descricao: "Reduz o cooldown de todos os itens ativáveis em 10%.",
    tipo: "upgrade",
    custo: 100,
    efeito: (scene) => { playerStats.intelligence += 1; scene.hud.displayTemporaryEffect('Cooldowns Reduzidos!', '#ADD8E6', 1500); },
    maxPurchases: 2,
    purchasedCount: 0
  },
  {
    nome: "Pacote de Sucata",
    descricao: "Ganhe 100 Sucatas extras.",
    tipo: "consumable",
    custo: 20,
    efeito: (scene) => { playerStats.currency += 100; scene.hud.updateCurrencyDisplay(); },
    maxPurchases: 1,
    purchasedCount: 0
  },
  {
    nome: "Olho de Xenosynth",
    descricao: "+20% chance de drop de item por 30s.",
    tipo: "upgrade",
    custo: 150,
    efeito: (scene) => { playerStats.increasedDropRate = true; scene.time.delayedCall(30000, () => { playerStats.increasedDropRate = false; }); },
    maxPurchases: 2,
    purchasedCount: 0
  },
  {
    nome: "Óleo de Ferro-Vivo",
    descricao: "Recupera vida completamente, mas reduz bullet damage em 20% até fim da wave.",
    tipo: "consumable",
    custo: 100,
    efeito: (scene) => { playerStats.life = playerStats.maxLife; playerStats.bulletDamage *= 0.8; scene.hud.updateHealthBar(); },
    maxPurchases: 1,
    purchasedCount: 0
  },
  {
    nome: "Componente Raro (Crafting)",
    descricao: "Um componente essencial para criação de itens avançados.",
    tipo: "resource",
    custo: 200,
    efeito: (scene) => { playerStats.rareParts += 1; scene.hud.displayTemporaryEffect('Componente Raro Adquirido!', '#FFD700', 1000); },
    maxPurchases: 99,
    purchasedCount: 0
  }
];

// --- Player Inventory and Upgrades ---
let playerInventory = {
  passiveItems: {},
  activableItems: {},
  activeItem: null, // Currently selected activable item
  activableItemCooldowns: {}, // To track cooldowns
  activableItemTimers: {}, // To track cooldown timers for UI
};
let playerCards = []; // Cards chosen for upgrades

// --- HUD Class (Assumed/Placeholder) ---
class HUD extends Phaser.GameObjects.Container {
  constructor(scene, x, y) {
    super(scene, x, y);
    scene.add.existing(this);

    // Basic HUD elements
    this.lifeText = scene.add.text(10, 10, 'Vida: ' + playerStats.life, { fontSize: '20px', fill: '#FF0000' });
    this.levelText = scene.add.text(10, 40, 'Nível: ' + playerStats.level, { fontSize: '20px', fill: '#FFFF00' });
    this.xpBar = scene.add.graphics();
    this.currencyText = scene.add.text(10, 70, 'Sucata: ' + playerStats.currency, { fontSize: '20px', fill: '#FFD700' });
    this.rarePartsText = scene.add.text(10, 100, 'Peças Raras: ' + playerStats.rareParts, { fontSize: '20px', fill: '#FFD700' }); // NEW
    this.waveText = scene.add.text(config.width / 2, 10, 'Onda: ' + waveNumber, { fontSize: '24px', fill: '#FFFFFF' }).setOrigin(0.5);

    this.add([this.lifeText, this.levelText, this.xpBar, this.currencyText, this.rarePartsText, this.waveText]);

    // Weapon Display
    this.armaImagem = scene.add.image(config.width - 100, 50, 'arma1').setScale(0.15).setDepth(1);
    this.armaNomeText = scene.add.text(config.width - 100, 80, `Arma ${currentWeapon}`, { fontSize: '16px', fill: '#FFFFFF' }).setOrigin(0.5).setDepth(1);
    this.add([this.armaImagem, this.armaNomeText]);

    // Dash Cooldown Visual
    this.dashCooldownBarBg = scene.add.rectangle(0, 0, 60, 8, 0x555555).setDepth(1).setVisible(false);
    this.dashCooldownBar = scene.add.rectangle(0, 0, 60, 8, 0x00FF00).setDepth(1).setVisible(false);
    this.dashCooldownText = scene.add.text(0, 0, '', { fontSize: '12px', fill: '#FFFFFF' }).setOrigin(0.5).setDepth(1).setVisible(false);
    this.add([this.dashCooldownBarBg, this.dashCooldownBar, this.dashCooldownText]);

    // Initial updates
    this.updateHealthBar();
    this.updateXpBar();
    this.updateLevelDisplay();
    this.updateCurrencyDisplay();
    this.updateRarePartsDisplay();
  }

  updateHealthBar() {
    this.lifeText.setText('Vida: ' + Math.ceil(playerStats.life) + '/' + playerStats.maxLife);
  }

  updateXpBar() {
    this.xpBar.clear();
    const xpBarWidth = 200;
    const xpBarHeight = 15;
    const currentXpRatio = playerStats.xp / playerStats.xpToNextLevel;
    this.xpBar.fillStyle(0x555555); // Background
    this.xpBar.fillRect(10, 20 + 20, xpBarWidth, xpBarHeight);
    this.xpBar.fillStyle(0x00FF00); // Fill
    this.xpBar.fillRect(10, 20 + 20, xpBarWidth * currentXpRatio, xpBarHeight);
    this.xpBar.lineStyle(2, 0xFFFFFF);
    this.xpBar.strokeRect(10, 20 + 20, xpBarWidth, xpBarHeight);
  }

  updateLevelDisplay() {
    this.levelText.setText('Nível: ' + playerStats.level);
  }

  updateCurrencyDisplay() {
    this.currencyText.setText('Sucata: ' + playerStats.currency);
  }

  updateRarePartsDisplay() {
    this.rarePartsText.setText('Peças Raras: ' + playerStats.rareParts);
  }

  updatePlayerStatsDisplay() {
    this.updateHealthBar();
    this.updateXpBar();
    this.updateLevelDisplay();
    this.updateCurrencyDisplay();
    this.updateRarePartsDisplay();
  }

  displayTemporaryEffect(text, color, duration) {
    if (temporaryEffectText) {
      temporaryEffectText.destroy();
    }
    if (temporaryEffectTimer) {
      temporaryEffectTimer.remove(false);
    }
    temporaryEffectText = this.scene.add.text(config.width / 2, config.height / 2 - 50, text, { fontSize: '36px', fill: color, align: 'center', stroke: '#000000', strokeThickness: 4 }).setOrigin(0.5).setDepth(200);
    temporaryEffectTimer = this.scene.time.delayedCall(duration, () => {
      if (temporaryEffectText) {
        temporaryEffectText.destroy();
        temporaryEffectText = null;
      }
    });
  }

  updateWaveDisplay() {
    this.waveText.setText('Onda: ' + waveNumber);
  }

  updateWeaponDisplay(weaponKey) {
    this.armaImagem.setTexture(weaponKey);
    this.armaNomeText.setText(`Arma ${currentWeapon}`);
  }

  updateDashCooldownUI(currentCooldown, maxCooldown) {
    if (playerStats.dashCooldown && player) {
      const barY = player.y + 40;
      this.dashCooldownBarBg.setVisible(true).setPosition(player.x, barY);
      const progress = currentCooldown / maxCooldown;
      const width = 60 * progress;
      this.dashCooldownBar.setVisible(true).setPosition(player.x - (60 / 2) + width / 2, barY);
      this.dashCooldownBar.width = width;
      this.dashCooldownText.setVisible(true).setPosition(player.x, barY + 10);
      this.dashCooldownText.setText(`${(currentCooldown / 1000).toFixed(1)}s`);
    } else {
      this.dashCooldownBar.setVisible(false);
      this.dashCooldownBarBg.setVisible(false);
      this.dashCooldownText.setVisible(false);
    }
  }
}

// --- Phaser Scene Functions ---
function preload() {
  // Game Assets from the provided list
  this.load.image('cardBg', 'assets/card_background.png');
  this.load.image('player', 'assets/player_robot.png');
  this.load.image('bullet', 'assets/bullet.png');
  this.load.image('enemy_robot', 'assets/enemy_robot.png');
  this.load.image('enemy_fast', 'assets/enemy_fast.png');
  this.load.image('enemy_tank', 'assets/enemy_tank.png');
  this.load.image('boss_robot', 'assets/boss_robot.png');
  this.load.image('arma1', 'assets/arma1.png');
  this.load.image('arma2', 'assets/arma2.png');
  this.load.image('arma3', 'assets/arma3.png');
  this.load.image('ammo', 'assets/ammo.png'); // Placeholder for new items
  this.load.image('scrap', 'assets/scrap.png'); // For currency drop
  this.load.image('crate', 'assets/crate.png'); // Destructible crate
  this.load.image('drone_attack', 'assets/drone_attack.png'); // Attack drone
  this.load.image('drone_heal', 'assets/drone_heal.png');     // Heal drone
  this.load.image('bullet_enemy', 'assets/bullet_enemy.png'); // Enemy bullet
}

function create() {
  // Add a listener to resize the canvas when the window resizes
  this.scale.on('resize', resize, this);

  // Initial resize
  resize(this.scale.width, this.scale.height);

  // Player setup
  player = this.physics.add.sprite(config.width / 2, config.height / 2, 'player');
  player.setScale(PLAYER_INITIAL_SCALE);
  player.setCollideWorldBounds(true);
  player.body.setDrag(PLAYER_DRAG); // Apply drag for smoother stopping
  player.body.setMaxSpeed(playerStats.playerSpeed); // Set max speed

  // Weapon switching (1, 2, 3 keys)
  this.input.keyboard.on('keydown-ONE', () => switchWeapon.call(this, 1));
  this.input.keyboard.on('keydown-TWO', () => switchWeapon.call(this, 2));
  this.input.keyboard.on('keydown-THREE', () => switchWeapon.call(this, 3));

  // Bullets group (player)
  bullets = this.physics.add.group({
    defaultKey: 'bullet',
    maxSize: 50 // Limit the number of bullets
  });
  bullets.children.each(function (b) {
    b.setScale(BULLET_INITIAL_SCALE);
  });

  // Enemy bullets group
  enemyBullets = this.physics.add.group({
    defaultKey: 'bullet_enemy',
    maxSize: 50 // Limit enemy bullets
  });

  // Enemies group
  enemies = this.physics.add.group();

  // Destructibles group
  destructiblesGroup = this.physics.add.group();

  // Drones group
  dronesGroup = this.physics.add.group();

  // Items (pickups) group
  itemsGroup = this.physics.add.group();

  // Player controls
  cursors = this.input.keyboard.createCursorKeys();

  // Listen for 'P' key to toggle pause menu
  this.input.keyboard.on('keydown-P', togglePauseMenu, this);

  // Initialize HUD
  this.hud = new HUD(this, 0, 0);

  // Level Up Menu Setup
  createLevelUpMenu(this);

  // Shop Menu Setup
  createShopMenu(this);

  // Pause Menu Setup (HTML/CSS controlled)
  createPauseMenu(this);

  // Overlap and Collision Handlers
  this.physics.add.overlap(bullets, enemies, hitEnemy, null, this);
  this.physics.add.overlap(player, enemies, hitPlayer, null, this);
  this.physics.add.overlap(player, itemsGroup, collectItem, null, this);
  this.physics.add.overlap(bullets, destructiblesGroup, hitDestructible, null, this);
  this.physics.add.overlap(player, enemyBullets, hitPlayerByEnemyBullet, null, this);

  // Initial wave spawn
  startWave.call(this);

  // Initial player stats update
  this.hud.updatePlayerStatsDisplay();
}

function update(time, delta) {
  if (gamePaused) {
    // If game is paused, don't update game logic, only UI related to pause menu
    return;
  }

  // Player Movement
  player.body.setVelocity(0); // Reset velocity each frame

  const currentSpeed = playerStats.playerSpeed * (playerStats.speedBoost ? 1.5 : 1);

  if (cursors.left.isDown) {
    player.body.setVelocityX(-currentSpeed);
  } else if (cursors.right.isDown) {
    player.body.setVelocityX(currentSpeed);
  }

  if (cursors.up.isDown) {
    player.body.setVelocityY(-currentSpeed);
  } else if (cursors.down.isDown) {
    player.body.setVelocityY(currentSpeed);
  }

  // Normalize velocity if moving diagonally to prevent faster diagonal movement
  player.body.velocity.normalize().scale(currentSpeed);

  // Dash Logic
  if (cursors.shift.isDown && playerStats.dashAvailable && !playerStats.dashCooldown) {
    playerStats.dashAvailable = false;
    playerStats.dashCooldown = DASH_COOLDOWN_BASE;
    player.setTint(0x00FF00); // Green tint for dash
    this.time.delayedCall(PLAYER_DASH_DURATION, () => {
      player.setTint(playerOriginalTint); // Revert tint
    });

    const dashVector = new Phaser.Math.Vector2(0, 0);
    if (cursors.left.isDown) dashVector.x = -1;
    if (cursors.right.isDown) dashVector.x = 1;
    if (cursors.up.isDown) dashVector.y = -1;
    if (cursors.down.isDown) dashVector.y = 1;

    // If no direction, dash in the last facing direction or a default
    if (dashVector.x === 0 && dashVector.y === 0) {
      // Default dash direction, e.g., forward or based on last movement
      // For simplicity, let's dash right if no direction is held
      dashVector.x = 1;
    }
    dashVector.normalize().scale(PLAYER_DASH_DISTANCE);

    // Apply dash velocity (impulse-like)
    player.x += dashVector.x;
    player.y += dashVector.y;

    // Start cooldown timer for visual display
    playerDashCooldownTimer = this.time.addEvent({
      delay: DASH_COOLDOWN_BASE,
      callback: () => {
        playerStats.dashCooldown = false;
        playerDashCooldownTimer = null; // Clear timer when cooldown ends
      },
      callbackScope: this
    });
  }

  // Update dash cooldown UI
  if (playerStats.dashCooldown && playerDashCooldownTimer) {
    const remainingTime = playerDashCooldownTimer.getRemaining();
    this.hud.updateDashCooldownUI(remainingTime, DASH_COOLDOWN_BASE);
  } else if (!playerStats.dashCooldown && !playerStats.dashAvailable) {
    // Dash is off cooldown and ready to be used again
    playerStats.dashAvailable = true;
    this.hud.updateDashCooldownUI(0, DASH_COOLDOWN_BASE); // Hide bar
  } else if (!playerStats.dashAvailable) {
    // Still on cooldown but timer might not be running (e.g., after first use)
    this.hud.updateDashCooldownUI(playerStats.dashCooldown, DASH_COOLDOWN_BASE);
  }


  // Shooting
  if (time > lastShoot + playerStats.fireRate) {
    let bulletOffset = 0;
    if (playerStats.doubleBullets) {
      fireBullet.call(this, player.x - 5, player.y);
      fireBullet.call(this, player.x + 5, player.y);
    } else if (playerStats.tripleBullets) {
      fireBullet.call(this, player.x - 10, player.y);
      fireBullet.call(this, player.x, player.y);
      fireBullet.call(this, player.x + 10, player.y);
    } else {
      fireBullet.call(this, player.x, player.y);
    }
    lastShoot = time;
  }

  // Enemy AI and Spawning
  enemies.children.each(function (enemy) {
    if (enemy.active) {
      // Simple enemy movement: move towards the player
      this.physics.moveToObject(enemy, player, enemy.speed);

      // Enemy specific attacks
      if (enemy.enemyType.attacks.includes('shoot') && time > enemy.lastShot + enemy.shootCooldown) {
        fireEnemyBullet.call(this, enemy, player);
        enemy.lastShot = time;
      }
      if (enemy.enemyType.attacks.includes('heal') && time > enemy.lastHeal + enemy.healCooldown) {
        // Find nearest ally and heal
        const allies = enemies.children.entries.filter(e => e.active && e !== enemy && Phaser.Math.Distance.Between(enemy.x, enemy.y, e.x, e.y) < 200);
        if (allies.length > 0) {
          const targetAlly = allies[0]; // Heal the first one found for simplicity
          targetAlly.health = Math.min(targetAlly.health + 2, targetAlly.enemyType.baseHealth); // Heal for 2
          // Visual feedback for healing (e.g., tint green briefly)
          targetAlly.setTint(0x00FF00);
          this.time.delayedCall(200, () => targetAlly.setTint(0xFFFFFF));
        }
        enemy.lastHeal = time;
      }
    }
  }, this);

  // Wave Management
  if (enemies.countActive(true) === 0 && enemiesSpawnedThisWave >= enemiesInWave) {
    startNextWave.call(this);
  } else if (time > lastEnemySpawn + enemySpawnRate && enemiesSpawnedThisWave < enemiesInWave) {
    spawnEnemy.call(this);
    lastEnemySpawn = time;
  }

  // Player passive regen
  if (playerStats.passiveRegenActive && time % 1000 < 50) { // Every second (rough timing)
    playerStats.life = Math.min(playerStats.life + playerStats.passiveRegenAmount, playerStats.maxLife);
    this.hud.updateHealthBar();
  }

  // Killstreak timer
  if (killStreak > 0 && killStreakTimer && time > killStreakTimer.delay + killStreakTimer.elapsed) {
    killStreak = 0;
    this.hud.displayTemporaryEffect('Killstreak Reset!', '#FF0000', 1000);
  }

  // Damage Aura (if active)
  if (playerStats.damageAura) {
      enemies.children.each(function(enemy) {
          if (enemy.active && Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y) < 70) {
              takeDamage(enemy, 0.05); // Small continuous damage
          }
      }, this);
  }

  // Spike Aura (if active, for Thorns effect)
  if (playerStats.thorns) {
    // This is handled in hitPlayer collision for simplicity (return damage)
  }

  // Safe Zone (if active)
  if (playerStats.safeZoneActive) {
      // Logic for safe zone (e.g., enemies cannot enter, or player takes no damage)
      // For now, let's assume it makes player invulnerable
      player.setTint(0x00BFFF); // Blue tint for safe zone
  } else {
      player.setTint(playerOriginalTint); // Revert tint
  }

  // Drone behavior
  dronesGroup.children.each(function(drone) {
      if (drone.active) {
          drone.update(player, enemies); // Drones update based on player and enemies
      }
  }, this);

  // Metalion Echo effect (cooldown reduction for activable items)
  if (playerStats.metalionEchoActive) {
      // This is handled in the `useActivableItem` function
  }

  // Lumiren Teleport (Bullet-based teleport)
  if (playerStats.lumirenTeleport) {
      // This is handled in fireBullet, if the bullet hits something
  }

  // Igniun Explosion (Low HP explosion)
  if (playerStats.igniunExplosion && playerStats.life / playerStats.maxLife < 0.1) {
      // Trigger explosion, then a death timer
      player.setTint(0xFF0000); // Red tint for critical HP
      // Implement explosion logic here (e.g., damage all nearby enemies)
      enemies.children.each(function(enemy) {
          if (enemy.active && Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y) < 150) {
              takeDamage(enemy, 5); // Explode for 5 damage
          }
      }, this);
      playerStats.igniunExplosion = false; // Only once per critical state
      // Initiate self-destruct countdown
      this.time.delayedCall(5000, () => {
          if (player.active) { // Ensure player hasn't already died
              playerStats.life = 0;
              this.hud.updateHealthBar();
              playerDied.call(this);
          }
      });
  }
}

// --- Player & Game Logic Functions ---

function resize(width, height) {
    if (width === undefined) { width = this.sys.game.config.width; }
    if (height === undefined) { height = this.sys.game.config.height; }
    this.cameras.main.setViewport(0, 0, width, height);
}

function fireBullet(x, y) {
  const bullet = bullets.get(x, y);
  if (bullet) {
    bullet.setActive(true).setVisible(true);
    this.physics.moveToPointer(bullet, this.input.activePointer, playerStats.weaponBulletSpeed * (playerStats.bulletSpeedBoost ? 1.2 : 1));
    bullet.setScale(BULLET_INITIAL_SCALE); // Ensure scale is set
    bullet.damage = playerStats.bulletDamage * playerStats.bulletCountMultiplier; // Set damage
    bullet.piercing = playerStats.bulletPiercing; // Set piercing property

    // For Lumiren Teleport
    if (playerStats.lumirenTeleport) {
        player.x -= 50; // Teleport 50px backward
        if (playerStats.life > 0) { // Only consume life if not already dead
            playerStats.life = Math.max(0, playerStats.life - 1); // Consume 1 life
            this.hud.updateHealthBar();
            if (playerStats.life <= 0) {
                playerDied.call(this);
            }
        }
    }
  }
}

function fireEnemyBullet(enemy, target) {
  const bullet = enemyBullets.get(enemy.x, enemy.y);
  if (bullet) {
    bullet.setActive(true).setVisible(true);
    this.physics.moveToObject(bullet, target, 400); // Slower enemy bullets
    bullet.setScale(0.02); // Small enemy bullet
    bullet.damage = 1; // Base enemy bullet damage
  }
}

function hitEnemy(bullet, enemy) {
  bullet.disableBody(true, true); // Disable and hide bullet

  if (playerStats.poisonTrail) {
      enemy.setTint(0x00FF00); // Green tint for poison
      playerStats.statusEffects.poisoned.active = true;
      playerStats.statusEffects.poisoned.damagePerTick = 0.2;
      playerStats.statusEffects.poisoned.duration = 3000;
      // Start a timer for poison damage
      this.time.addEvent({
          delay: 500, // Tick every 0.5 seconds
          repeat: 5, // 5 ticks for 2.5 seconds total
          callback: () => {
              if (enemy.active) {
                  takeDamage(enemy, playerStats.statusEffects.poisoned.damagePerTick);
              }
          }
      });
  }

  takeDamage(enemy, bullet.damage);
}

function takeDamage(target, amount) {
  if (!target.active) return; // Ensure target is active

  target.health -= amount;
  target.setTint(0xFF0000); // Flash red
  this.time.delayedCall(100, () => target.setTint(0xFFFFFF)); // Revert tint

  if (target.health <= 0) {
    enemyDied.call(this, target);
  }
}

function hitPlayer(player, enemy) {
  if (playerStats.safeZoneActive) {
      // No damage taken if safe zone is active
      return;
  }

  if (playerStats.evasionChance > 0 && Math.random() < playerStats.evasionChance) {
      this.hud.displayTemporaryEffect('DESVIADO!', '#FFFF00', 500);
      return; // Evade damage
  }

  if (playerStats.thorns && playerStats.reflectDamage > 0) {
      takeDamage(enemy, enemy.enemyType.baseHealth * playerStats.reflectDamage); // Reflect damage
  }

  let damageTaken = 1; // Base damage 1
  if (playerStats.statusEffects.damageReductionActive) {
      damageTaken *= (1 - playerStats.statusEffects.damageReductionAmount);
  }
  
  damageTaken *= playerStats.incomingDamageMultiplier;
  playerStats.life -= damageTaken;
  this.hud.updateHealthBar();
  player.setTint(0xFF0000); // Flash red
  this.time.delayedCall(100, () => player.setTint(playerOriginalTint)); // Revert tint

  // Sinfonia Parasitária: Apply poison to enemy that hit player
  if (playerStats.skillTree["bio-mutacao"]["SinfoniaParasitaria"].level > 0) {
      enemy.setTint(0x00FF00); // Green tint for poison
      this.time.addEvent({
          delay: 500, // Tick every 0.5 seconds
          repeat: 5, // 5 ticks for 2.5 seconds total
          callback: () => {
              if (enemy.active) {
                  takeDamage(enemy, 0.5); // 0.5 damage per tick
              }
          }
      });
  }

  if (playerStats.touchDamage > 0) {
      takeDamage(enemy, playerStats.touchDamage); // Apply touch damage to enemy
  }

  if (playerStats.life <= 0) {
    playerDied.call(this);
  }
}

function hitPlayerByEnemyBullet(player, bullet) {
    if (playerStats.safeZoneActive) {
        // No damage taken if safe zone is active
        bullet.disableBody(true, true);
        return;
    }

    if (playerStats.evasionChance > 0 && Math.random() < playerStats.evasionChance) {
        this.hud.displayTemporaryEffect('DESVIADO!', '#FFFF00', 500);
        bullet.disableBody(true, true);
        return; // Evade damage
    }

    bullet.disableBody(true, true); // Disable and hide enemy bullet

    let damageTaken = bullet.damage;
    if (playerStats.statusEffects.damageReductionActive) {
        damageTaken *= (1 - playerStats.statusEffects.damageReductionAmount);
    }
    damageTaken *= playerStats.incomingDamageMultiplier;

    playerStats.life -= damageTaken;
    this.hud.updateHealthBar();
    player.setTint(0xFF0000); // Flash red
    this.time.delayedCall(100, () => player.setTint(playerOriginalTint)); // Revert tint

    if (playerStats.life <= 0) {
        playerDied.call(this);
    }
}

function enemyDied(enemy) {
  enemy.disableBody(true, true);
  playerStats.xp += enemy.xpReward;
  playerStats.currency += enemy.currencyReward;
  this.hud.updateXpBar();
  this.hud.updateCurrencyDisplay();

  // Handle killstreak
  killStreak++;
  if (killStreakTimer) {
    killStreakTimer.remove(false); // Reset timer
  }
  killStreakTimer = this.time.delayedCall(3000, () => {
    killStreak = 0;
    this.hud.displayTemporaryEffect('Killstreak Reset!', '#FF0000', 1000);
  });

  if (killStreak >= 5) {
      this.hud.displayTemporaryEffect(`Killstreak: ${killStreak}!`, '#00FF00', 1000);
  }

  // Drop scrap (currency)
  dropItem.call(this, 'scrap', enemy.x, enemy.y);

  // Chance to drop an actual item/card
  if (Math.random() < 0.05 * (playerStats.increasedDropRate ? 2 : 1)) { // 5% base chance, doubled if increasedDropRate is true
      const randomItem = Phaser.Utils.Array.GetRandom(itemOptions);
      dropItem.call(this, randomItem.textura, enemy.x, enemy.y, randomItem);
  }

  // Check for level up
  if (playerStats.xp >= playerStats.xpToNextLevel) {
    levelUp.call(this);
  }

  // Check for achievements
  checkAchievements.call(this, 'FirstKill'); // Example
  checkAchievements.call(this, 'Collect1000Scrap');
}

function dropItem(texture, x, y, itemData = null) {
    const item = itemsGroup.create(x, y, texture);
    item.setScale(0.03); // Smaller scale for pickups
    item.setOrigin(0.5);
    item.body.setCircle(item.width / 2); // Make hitbox circular
    item.body.setCollideWorldBounds(true);
    item.itemData = itemData; // Store item data with the sprite
    item.setDepth(0); // Ensure items are behind player/enemies

    // Random slight movement to make them spread out
    item.setVelocity(Phaser.Math.Between(-100, 100), Phaser.Math.Between(-100, 100));
    this.time.delayedCall(200, () => item.setVelocity(0)); // Stop movement after a short time
}

function collectItem(player, item) {
    item.disableBody(true, true);
    if (item.texture.key === 'scrap') {
        playerStats.currency += 1; // Each scrap pickup is 1 currency
        this.hud.updateCurrencyDisplay();
        checkAchievements.call(this, 'Collect1000Scrap'); // Update achievement
    } else if (item.itemData) {
        // This is a card/power-up drop
        addCardToInventory(item.itemData);
        this.hud.displayTemporaryEffect(`${item.itemData.nome} Adquirido!`, itemRarities[item.itemData.rarity].color, 1500);
    }
}

function addCardToInventory(card) {
    if (card.tipo === 'passivo') {
        if (!playerInventory.passiveItems[card.nome]) {
            playerInventory.passiveItems[card.nome] = 0;
        }
        playerInventory.passiveItems[card.nome]++;
        card.efeito(this); // Apply passive effect immediately
        checkForItemSetBonus.call(this); // Check for set bonuses
    } else if (card.tipo === 'ativavel') {
        if (!playerInventory.activableItems[card.nome]) {
            playerInventory.activableItems[card.nome] = card;
            playerInventory.activableItemCooldowns[card.nome] = 0; // Initialize cooldown
            // Set the first activable item as active by default if none is active
            if (!playerInventory.activeItem) {
                playerInventory.activeItem = card;
            }
        }
        // If it's an activable, it might stack charges or just be a single instance
        // For simplicity, we'll assume one instance of each activable for now.
    }
    // Update inventory UI if you had one
    // console.log("Inventário atualizado:", playerInventory);
}

function checkForItemSetBonus() {
    for (const setName in itemSets) {
        const set = itemSets[setName];
        if (!set.bonusApplied) {
            const hasAllItems = set.items.every(itemName => playerInventory.passiveItems[itemName] > 0);
            if (hasAllItems) {
                set.bonus(this); // Apply the set bonus
                set.bonusApplied = true;
            }
        }
    }
}

function playerDied() {
  if (playerStats.reviveOnce) {
      playerStats.life = playerStats.maxLife; // Revive with full health
      playerStats.reviveOnce = false; // Use up the revive
      this.hud.updateHealthBar();
      this.hud.displayTemporaryEffect('REVIVIDO!', '#FFD700', 2000);
      player.setAlpha(0.5); // Briefly invulnerable
      this.time.delayedCall(1500, () => player.setAlpha(1));
      return;
  }

  gamePaused = true;
  this.physics.pause();
  player.setTint(0x800000); // Dark red tint for death
  this.hud.displayTemporaryEffect('GAME OVER!', '#FF0000', 999999);
  // Optionally, show a restart button or end-game screen
  console.log("Game Over!");
}

function levelUp() {
  playerStats.level++;
  playerStats.xp -= playerStats.xpToNextLevel; // Subtract excess XP
  playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.5); // Increase XP needed for next level
  playerStats.skillPoints++; // Gain a skill point
  playerStats.life = playerStats.maxLife; // Heal on level up
  this.hud.updatePlayerStatsDisplay();
  this.hud.displayTemporaryEffect('LEVEL UP!', '#00FFFF', 2000);
  this.hud.updateHealthBar(); // Update health bar after healing

  // Open level up menu to choose a card
  openLevelUpMenu.call(this);

  // Check achievement for max level
  if (playerStats.level >= 50) { // Assuming 50 is max level
      checkAchievements.call(this, 'MaxLevel');
  }
}

function spawnEnemy() {
  const edge = Phaser.Math.Between(0, 3); // 0: top, 1: right, 2: bottom, 3: left
  let x, y;
  const padding = 50;

  if (edge === 0) { // Top
    x = Phaser.Math.Between(padding, config.width - padding);
    y = -padding;
  }
  else if (edge === 1) { // Right
    x = config.width + padding;
    y = Phaser.Math.Between(padding, config.height - padding);
  }
  else { // Left
    x = -padding;
    y = Phaser.Math.Between(padding, config.height - padding);
  }

  // Choose a random enemy type, potentially weighted by wave number
  const enemyTypeKeys = Object.keys(enemyTypes);
  const randomEnemyKey = Phaser.Utils.Array.GetRandom(enemyTypeKeys);
  const enemyDef = enemyTypes[randomEnemyKey];

  const enemy = enemies.create(x, y, enemyDef.texture);
  enemy.setScale(enemyDef.scale);
  enemy.setTint(0xFFFFFF); // Default tint
  enemy.setCollideWorldBounds(true);
  enemy.body.setCircle(enemy.width / 2); // Adjust hitbox to be circular

  // Set enemy-specific properties
  enemy.health = enemyDef.baseHealth;
  enemy.speed = enemyDef.speed;
  enemy.xpReward = enemyDef.xpReward;
  enemy.currencyReward = enemyDef.currencyReward;
  enemy.enemyType = enemyDef; // Store full definition

  // For shooter/healer enemies
  if (enemyDef.attacks.includes('shoot')) {
      enemy.lastShot = 0;
      enemy.shootCooldown = 1500; // Shoot every 1.5 seconds
  }
  if (enemyDef.attacks.includes('heal')) {
      enemy.lastHeal = 0;
      enemy.healCooldown = 2000; // Heal every 2 seconds
  }

  enemiesSpawnedThisWave++;
}

function spawnDestructible(x, y) {
    const crate = destructiblesGroup.create(x, y, 'crate');
    crate.setScale(0.1);
    crate.setImmovable(true);
    crate.health = 3; // Crates take 3 hits to break
    crate.setDepth(0);
}

function hitDestructible(bullet, crate) {
    bullet.disableBody(true, true);
    crate.health -= 1;
    crate.setTint(0xFFD700); // Flash yellow
    this.time.delayedCall(100, () => crate.setTint(0xFFFFFF));

    if (crate.health <= 0) {
        crate.disableBody(true, true);
        // Drop some scrap when destroyed
        for (let i = 0; i < Phaser.Math.Between(2, 5); i++) {
            dropItem.call(this, 'scrap', crate.x + Phaser.Math.Between(-10, 10), crate.y + Phaser.Math.Between(-10, 10));
        }
    }
}

// --- Wave Management ---
function startWave() {
  this.hud.displayTemporaryEffect(`Onda ${waveNumber}`, '#FFFFFF', 1500);
  enemiesInWave = 5 + waveNumber * 2; // More enemies each wave
  enemySpawnRate = Math.max(500, 2000 - (waveNumber * 50)); // Faster spawn
  enemiesSpawnedThisWave = 0;
  lastEnemySpawn = this.time.now;

  // Spawn some destructibles at the start of each wave
  for (let i = 0; i < Math.min(waveNumber, 5); i++) { // Max 5 crates
      const x = Phaser.Math.Between(100, config.width - 100);
      const y = Phaser.Math.Between(100, config.height - 100);
      spawnDestructible.call(this, x, y);
  }
}

function startNextWave() {
  waveNumber++;
  // Reset any temporary effects that last "until end of wave"
  playerStats.speedBoost = false;
  this.time.delayedCall(2000, () => { // Small delay before next wave starts
    startWave.call(this);
  });
  this.hud.updateWaveDisplay();
  checkAchievements.call(this, 'Wave10'); // Check for wave 10 achievement
}

function switchWeapon(weaponNum) {
  if (weaponSwitchCooldown) return;

  currentWeapon = weaponNum;
  let weaponTexture;
  switch (currentWeapon) {
    case 1:
      playerStats.fireRate = 300;
      playerStats.bulletDamage = playerStats.strength;
      weaponTexture = 'arma1';
      break;
    case 2:
      playerStats.fireRate = 100;
      playerStats.bulletDamage = playerStats.strength * 0.5;
      weaponTexture = 'arma2';
      break;
    case 3:
      playerStats.fireRate = 500;
      playerStats.bulletDamage = playerStats.strength * 2;
      weaponTexture = 'arma3';
      break;
  }
  this.hud.updateWeaponDisplay(weaponTexture);
  this.hud.displayTemporaryEffect(`Arma ${currentWeapon} Selecionada!`, '#FFFFFF', 1000);

  weaponSwitchCooldown = true;
  this.time.delayedCall(500, () => {
    weaponSwitchCooldown = false;
  });
}

function useActivableItem() {
    if (!playerInventory.activeItem) {
        this.hud.displayTemporaryEffect('Nenhum item ativável selecionado!', '#FF0000', 1000);
        return;
    }

    const item = playerInventory.activeItem;
    const currentCooldown = playerInventory.activableItemCooldowns[item.nome];
    const totalCooldown = item.cooldown * (playerStats.metalionEchoActive ? 0.8 : 1); // Apply Metalion Echo

    if (currentCooldown <= 0) {
        item.efeito(this); // Apply item effect
        playerInventory.activableItemCooldowns[item.nome] = totalCooldown; // Start cooldown

        // Visual feedback for item use
        this.hud.displayTemporaryEffect(`${item.nome} Usado!`, '#00FF00', 1000);

        // Start cooldown timer for UI
        if (playerInventory.activableItemTimers[item.nome]) {
            playerInventory.activableItemTimers[item.nome].remove(false);
        }
        playerInventory.activableItemTimers[item.nome] = this.time.addEvent({
            delay: 50, // Update every 50ms
            repeat: Math.floor(totalCooldown / 50),
            callback: () => {
                playerInventory.activableItemCooldowns[item.nome] -= 50;
                if (playerInventory.activableItemCooldowns[item.nome] <= 0) {
                    playerInventory.activableItemCooldowns[item.nome] = 0;
                    if (playerInventory.activableItemTimers[item.nome]) {
                        playerInventory.activableItemTimers[item.nome].remove(false);
                        playerInventory.activableItemTimers[item.nome] = null;
                    }
                }
                // Update UI for the active item's cooldown (if you have one)
            }
        });

        if (playerStats.metalionEchoActive) {
            // Apply speed reduction for Metalion Echo
            playerStats.playerSpeed *= 0.95; // 5% speed reduction
            player.body.setMaxSpeed(playerStats.playerSpeed);
            this.hud.displayTemporaryEffect('-5% Velocidade (Eco de Metalion)', '#FF4500', 1500);
        }
    } else {
        this.hud.displayTemporaryEffect(`Em Cooldown: ${Math.ceil(currentCooldown / 1000)}s`, '#FF8C00', 1000);
    }
}


// --- HTML UI Functions (Level Up) ---
function createLevelUpMenu(scene) {
  const menuOverlay = document.createElement('div');
  menuOverlay.id = 'level-up-menu';
  menuOverlay.className = 'menu-overlay';
  menuOverlay.style.display = 'none'; // Hidden by default
  document.body.appendChild(menuOverlay);

  const menuContainer = document.createElement('div');
  menuContainer.className = 'menu-container';
  menuOverlay.appendChild(menuContainer);

  const menuTitle = document.createElement('h1');
  menuTitle.className = 'menu-title';
  menuTitle.textContent = 'Subir de Nível! Escolha uma Melhoria';
  menuContainer.appendChild(menuTitle);

  const cardsContainer = document.createElement('div');
  cardsContainer.className = 'cards-container';
  menuContainer.appendChild(cardsContainer);

  scene.levelUpCardsContainer = cardsContainer; // Store reference
}

function openLevelUpMenu() {
  gamePaused = true;
  levelUpMenuOpen = true;
  this.physics.pause();
  document.getElementById('level-up-menu').style.display = 'flex';
  this.levelUpCardsContainer.innerHTML = ''; // Clear previous cards

  const availableCards = getRandomCards(itemOptions, 3); // Get 3 random cards
  availableCards.forEach(card => {
    const cardElement = document.createElement('div');
    cardElement.className = 'card';
    cardElement.innerHTML = `
      <h3 class="card-title">${card.nome}</h3>
      <p class="card-rarity" style="color:${itemRarities[card.rarity].color}">${card.rarity.toUpperCase()}</p>
      <p class="card-description">${card.descricao}</p>
      <button class="card-button">Selecionar</button>
    `;
    cardElement.querySelector('.card-button').onclick = () => selectCard.call(this, card);
    this.levelUpCardsContainer.appendChild(cardElement);
  });
}

function closeLevelUpMenu() {
  document.getElementById('level-up-menu').style.display = 'none';
  gamePaused = false;
  levelUpMenuOpen = false;
  this.physics.resume();
}

function selectCard(card) {
  addCardToInventory.call(this, card);
  this.hud.displayTemporaryEffect(`${card.nome} Selecionado!`, itemRarities[card.rarity].color, 1500);
  closeLevelUpMenu.call(this);
}

function getRandomCards(options, count) {
    // Filter out items the player already has if they are unique passives or activables
    // This simple logic might give duplicate passives if they stack, which is fine
    // For unique activables, you'd need more complex filtering.
    const eligibleOptions = options.filter(item => {
        if (item.tipo === 'passivo' || item.tipo === 'ativavel') {
            return !playerInventory.passiveItems[item.nome] && !playerInventory.activableItems[item.nome];
        }
        return true; // Allow consumables/resources to always be an option if desired
    });

    const chosen = [];
    while (chosen.length < count && eligibleOptions.length > 0) {
        const randomIndex = Phaser.Math.Between(0, eligibleOptions.length - 1);
        chosen.push(eligibleOptions[randomIndex]);
        eligibleOptions.splice(randomIndex, 1); // Remove to prevent duplicates
    }
    return chosen;
}

// --- HTML UI Functions (Shop) ---
let shopPanel; // Reference to the shop HTML element
let shopItemsContainer;
let shopCurrencyDisplay;

function createShopMenu(scene) {
  const shopOverlay = document.createElement('div');
  shopOverlay.id = 'shop-menu';
  shopOverlay.className = 'shop-overlay';
  shopOverlay.style.display = 'none'; // Hidden by default
  document.body.appendChild(shopOverlay);

  shopPanel = document.createElement('div');
  shopPanel.className = 'shop-container';
  shopOverlay.appendChild(shopPanel);

  const shopTitle = document.createElement('h1');
  shopTitle.className = 'shop-title';
  shopTitle.textContent = 'Loja de Sucata';
  shopPanel.appendChild(shopTitle);

  shopCurrencyDisplay = document.createElement('div');
  shopCurrencyDisplay.className = 'shop-currency-display';
  shopCurrencyDisplay.textContent = `Sucata: ${playerStats.currency}`;
  shopPanel.appendChild(shopCurrencyDisplay);

  shopItemsContainer = document.createElement('div');
  shopItemsContainer.className = 'shop-items-container';
  shopPanel.appendChild(shopItemsContainer);

  const closeButton = document.createElement('button');
  closeButton.className = 'shop-close-button';
  closeButton.textContent = 'Fechar Loja';
  closeButton.onclick = () => closeShop.call(scene);
  shopPanel.appendChild(closeButton);

  scene.shopPanel = shopPanel; // Store reference
  scene.shopItemsContainer = shopItemsContainer;
  scene.shopCurrencyDisplay = shopCurrencyDisplay;
}

function openShop() {
  console.log('openShop: Abrindo loja.'); // Console Log
  gamePaused = true;
  shopMenuOpen = true;
  this.physics.pause();
  shopPanel.style.display = 'flex'; // Set to flex to display

  updateShopUI.call(this);
  console.log('openShop: Loja aberta e UI atualizada.'); // Console Log
}

function closeShop() {
  console.log('closeShop: Fechando loja.'); // Console Log
  shopPanel.style.display = 'none'; // Hide the shop panel
  gamePaused = false;
  shopMenuOpen = false;
  this.physics.resume();
  console.log('closeShop: Loja fechada.'); // Console Log
}

function updateShopUI() {
  shopItemsContainer.innerHTML = ''; // Clear existing items
  shopCurrencyDisplay.textContent = `Sucata: ${playerStats.currency}`;

  shopItems.forEach(item => {
    const itemElement = document.createElement('div');
    itemElement.className = 'shop-item';
    const canBuy = playerStats.currency >= item.custo && (item.maxPurchases === undefined || item.purchasedCount < item.maxPurchases);
    const buttonText = canBuy ? `Comprar (${item.custo} Sucata)` : `Indisponível (${item.custo} Sucata)`;

    itemElement.innerHTML = `
      <h3 class="shop-item-name">${item.nome}</h3>
      <p class="shop-item-desc">${item.descricao}</p>
      <div class="shop-item-cost">Custo: ${item.custo} Sucata</div>
      <button class="shop-item-button" ${canBuy ? '' : 'disabled'}>${buttonText}</button>
    `;
    itemElement.querySelector('.shop-item-button').onclick = () => buyItem.call(this, item);
    shopItemsContainer.appendChild(itemElement);
  });
}

function buyItem(item) {
  console.log('buyItem: Iniciando compra para', item.nome); // Console Log
  if (playerStats.currency >= item.custo) {
    playerStats.currency -= item.custo;
    item.purchasedCount++;

    console.log('buyItem: Moedas deduzidas e count incrementado.'); // Console Log

    if (item.tipo === 'consumable' || item.tipo === 'resource' || item.tipo === 'upgrade') {
      item.efeito(this); // Apply item effect immediately
    } else if (item.tipo === 'item_card') {
        // If shop sells actual cards that go into inventory like level up
        addCardToInventory.call(this, item.itemData);
    }
    this.hud.updateCurrencyDisplay();
    updateShopUI.call(this); // Re-render shop to update button states
    this.hud.displayTemporaryEffect(`${item.nome} Comprado!`, '#00FF00', 1000);
    console.log('buyItem: Item comprado e UI atualizada.'); // Console Log
  } else {
    this.hud.displayTemporaryEffect('Sucata Insuficiente!', '#FF0000', 1000);
    console.log('buyItem: Sucata insuficiente para comprar', item.nome); // Console Log
  }
}

// --- HTML UI Functions (Pause Menu) ---
let pauseMenuOverlay;
let statsTabContent, inventoryTabContent, skillsTabContent, questsTabContent, achievementsTabContent;
let currentActiveTab = 'stats'; // Default active tab

function createPauseMenu(scene) {
  pauseMenuOverlay = document.createElement('div');
  pauseMenuOverlay.id = 'pause-menu';
  pauseMenuOverlay.className = 'pause-overlay';
  pauseMenuOverlay.style.display = 'none';
  document.body.appendChild(pauseMenuOverlay);

  const pauseContainer = document.createElement('div');
  pauseContainer.className = 'pause-container';
  pauseMenuOverlay.appendChild(pauseContainer);

  const pauseTitle = document.createElement('h1');
  pauseTitle.className = 'pause-title';
  pauseTitle.textContent = 'Jogo Pausado';
  pauseContainer.appendChild(pauseTitle);

  const tabsContainer = document.createElement('div');
  tabsContainer.className = 'pause-tabs';
  pauseContainer.appendChild(tabsContainer);

  // Create Tabs
  const tabs = [
    { id: 'stats', text: 'Estatísticas' },
    { id: 'inventory', text: 'Inventário' },
    { id: 'skills', text: 'Habilidades' },
    { id: 'quests', text: 'Missões' },
    { id: 'achievements', text: 'Conquistas' }
  ];

  tabs.forEach(tab => {
    const button = document.createElement('button');
    button.id = `${tab.id}-tab-button`;
    button.className = 'pause-tab-button';
    button.textContent = tab.text;
    button.onclick = () => switchPauseTab.call(scene, tab.id);
    tabsContainer.appendChild(button);
  });

  const contentContainer = document.createElement('div');
  contentContainer.className = 'pause-content';
  pauseContainer.appendChild(contentContainer);

  // Tab Contents
  statsTabContent = document.createElement('div');
  statsTabContent.id = 'stats-tab-content';
  contentContainer.appendChild(statsTabContent);

  inventoryTabContent = document.createElement('div');
  inventoryTabContent.id = 'inventory-tab-content';
  inventoryTabContent.style.display = 'none';
  contentContainer.appendChild(inventoryTabContent);

  skillsTabContent = document.createElement('div');
  skillsTabContent.id = 'skills-tab-content';
  skillsTabContent.style.display = 'none';
  contentContainer.appendChild(skillsTabContent);

  questsTabContent = document.createElement('div');
  questsTabContent.id = 'quests-tab-content';
  questsTabContent.style.display = 'none';
  contentContainer.appendChild(questsTabContent);

  achievementsTabContent = document.createElement('div');
  achievementsTabContent.id = 'achievements-tab-content';
  achievementsTabContent.style.display = 'none';
  contentContainer.appendChild(achievementsTabContent);


  const closeButton = document.createElement('button');
  closeButton.className = 'pause-close-button';
  closeButton.textContent = 'Continuar Jogo';
  closeButton.onclick = () => togglePauseMenu.call(scene);
  pauseContainer.appendChild(closeButton);

  // Initial tab display
  switchPauseTab.call(scene, currentActiveTab);

  scene.pauseMenuOverlay = pauseMenuOverlay; // Store reference
}

function togglePauseMenu() {
  if (levelUpMenuOpen || shopMenuOpen) return; // Prevent opening if other menus are open

  gamePaused = !gamePaused;
  pauseMenuOpen = gamePaused;

  if (gamePaused) {
    this.physics.pause();
    pauseMenuOverlay.style.display = 'flex';
    updatePauseMenuUI.call(this); // Update content when opening
  } else {
    this.physics.resume();
    pauseMenuOverlay.style.display = 'none';
  }
}

function switchPauseTab(tabId) {
  // Hide all tab contents
  document.querySelectorAll('.pause-content > div').forEach(content => {
    content.style.display = 'none';
  });
  // Deactivate all tab buttons
  document.querySelectorAll('.pause-tab-button').forEach(button => {
    button.classList.remove('active');
  });

  // Show active tab content
  document.getElementById(`${tabId}-tab-content`).style.display = 'block';
  // Activate selected tab button
  document.getElementById(`${tabId}-tab-button`).classList.add('active');

  currentActiveTab = tabId;
  updatePauseMenuUI.call(this); // Update content for the new tab
}

function updatePauseMenuUI() {
  if (currentActiveTab === 'stats') {
    statsTabContent.innerHTML = `
      <p><strong>Nível:</strong> ${playerStats.level}</p>
      <p><strong>XP:</strong> ${playerStats.xp} / ${playerStats.xpToNextLevel}</p>
      <p><strong>Vida:</strong> ${Math.ceil(playerStats.life)} / ${playerStats.maxLife}</p>
      <p><strong>Dano de Bala:</strong> ${playerStats.bulletDamage.toFixed(1)}</p>
      <p><strong>Velocidade de Ataque (ms):</strong> ${playerStats.fireRate}</p>
      <p><strong>Velocidade do Jogador:</strong> ${playerStats.playerSpeed}</p>
      <p><strong>Sucata:</strong> ${playerStats.currency}</p>
      <p><strong>Peças Raras:</strong> ${playerStats.rareParts}</p>
      <p><strong>Pontos de Habilidade:</strong> ${playerStats.skillPoints}</p>
      <p><strong>Força:</strong> ${playerStats.strength}</p>
      <p><strong>Agilidade:</strong> ${playerStats.agility}</p>
      <p><strong>Constituição:</strong> ${playerStats.constitution}</p>
      <p><strong>Inteligência:</strong> ${playerStats.intelligence}</p>
      <p><strong>Chance de Desviar:</strong> ${(playerStats.evasionChance * 100).toFixed(0)}%</p>
      <p><strong>Redução de Dano:</strong> ${((1 - playerStats.incomingDamageMultiplier) * 100).toFixed(0)}%</p>
    `;
  } else if (currentActiveTab === 'inventory') {
      inventoryTabContent.innerHTML = '<h2>Itens Passivos</h2>';
      let hasPassiveItems = false;
      for (const itemName in playerInventory.passiveItems) {
          hasPassiveItems = true;
          const count = playerInventory.passiveItems[itemName];
          const itemDef = itemOptions.find(item => item.nome === itemName);
          inventoryTabContent.innerHTML += `<p><strong>${itemName}</strong> (x${count}) - ${itemDef ? itemDef.descricao : 'Descrição não encontrada'}</p>`;
      }
      if (!hasPassiveItems) {
          inventoryTabContent.innerHTML += '<p>Nenhum item passivo.</p>';
      }

      inventoryTabContent.innerHTML += '<h2>Itens Ativáveis</h2>';
      let hasActivableItems = false;
      for (const itemName in playerInventory.activableItems) {
          hasActivableItems = true;
          const itemDef = playerInventory.activableItems[itemName];
          const cooldownRemaining = playerInventory.activableItemCooldowns[itemName] || 0;
          inventoryTabContent.innerHTML += `
              <p>
                  <strong>${itemName}</strong> - ${itemDef.descricao}
                  <button onclick="useActivableItemWrapper('${itemName}')" ${cooldownRemaining > 0 ? 'disabled' : ''}>
                      Usar ${cooldownRemaining > 0 ? `(${Math.ceil(cooldownRemaining / 1000)}s)` : ''}
                  </button>
              </p>
          `;
      }
      if (!hasActivableItems) {
          inventoryTabContent.innerHTML += '<p>Nenhum item ativável.</p>';
      }
  } else if (currentActiveTab === 'skills') {
      skillsTabContent.innerHTML = `<p class="skill-points-display">Pontos de Habilidade: ${playerStats.skillPoints}</p>`;
      for (const category in playerStats.skillTree) {
          skillsTabContent.innerHTML += `<div class="skill-category"><h3 class="skill-category-title">${category.toUpperCase()}</h3>`;
          for (const skillName in playerStats.skillTree[category]) {
              const skill = playerStats.skillTree[category][skillName];
              const canUpgrade = playerStats.skillPoints > 0 && skill.level < skill.maxLevel;
              skillsTabContent.innerHTML += `
                  <div class="skill-talent">
                      <div class="skill-talent-info">
                          <p class="skill-talent-name">${skillName} (Nível ${skill.level}/${skill.maxLevel})</p>
                          <p class="skill-talent-desc">${skill.description}</p>
                      </div>
                      <button class="skill-talent-button" onclick="upgradeSkillWrapper('${category}', '${skillName}')" ${canUpgrade ? '' : 'disabled'}>
                          Subir Nível
                      </button>
                  </div>
              `;
          }
          skillsTabContent.innerHTML += `</div>`;
      }
  } else if (currentActiveTab === 'quests') {
      questsTabContent.innerHTML = '<h2>Missões Ativas</h2>';
      if (playerStats.activeQuests.length === 0) {
          questsTabContent.innerHTML += '<p>Nenhuma missão ativa.</p>';
      } else {
          playerStats.activeQuests.forEach(quest => {
              questsTabContent.innerHTML += `
                  <div class="quest-item">
                      <p class="quest-title">${quest.title}</p>
                      <p class="quest-desc">${quest.description}</p>
                      <p class="quest-progress">Progresso: ${quest.progress}/${quest.target}</p>
                      <p class="quest-reward">Recompensa: ${quest.rewardDescription}</p>
                  </div>
              `;
          });
      }
      questsTabContent.innerHTML += '<h2>Missões Concluídas</h2>';
      if (playerStats.completedQuests.length === 0) {
          questsTabContent.innerHTML += '<p>Nenhuma missão concluída.</p>';
      } else {
          playerStats.completedQuests.forEach(quest => {
              questsTabContent.innerHTML += `
                  <div class="quest-item">
                      <p class="quest-title">${quest.title} (Concluída)</p>
                      <p class="quest-reward">Recompensa: ${quest.rewardDescription}</p>
                  </div>
              `;
          });
      }
  } else if (currentActiveTab === 'achievements') {
      achievementsTabContent.innerHTML = '<h2>Conquistas</h2>';
      for (const achKey in playerStats.achievements) {
          const achievement = playerStats.achievements[achKey];
          const statusClass = achievement.unlocked ? 'unlocked' : 'locked';
          const statusText = achievement.unlocked ? 'Desbloqueado' : 'Bloqueado';
          achievementsTabContent.innerHTML += `
              <div class="achievement-item">
                  <p class="achievement-title">${achKey}</p>
                  <p class="achievement-desc">${achievement.description}</p>
                  <p class="achievement-status ${statusClass}">${statusText}</p>
              </div>
          `;
      }
  }
}


// Wrappers for HTML button calls to ensure 'this' context is the Phaser scene
function useActivableItemWrapper(itemName) {
    const scene = game.scene.getAt(0); // Get the main game scene
    if (scene) {
        scene.useActivableItem(); // Call the Phaser scene function
    }
    updatePauseMenuUI(); // Update UI immediately after attempt
}

function upgradeSkillWrapper(category, skillName) {
    const scene = game.scene.getAt(0); // Get the main game scene
    if (scene) {
        upgradeSkill.call(scene, category, skillName); // Call the Phaser scene function
    }
    updatePauseMenuUI(); // Update UI immediately after upgrade
}

// --- RPG Skill System ---
function upgradeSkill(category, skillName) {
    const skill = playerStats.skillTree[category][skillName];
    if (playerStats.skillPoints > 0 && skill.level < skill.maxLevel) {
        skill.level++;
        playerStats.skillPoints--;
        applySkillEffect.call(this, category, skillName, skill.level);
        this.hud.displayTemporaryEffect(`Habilidade ${skillName} melhorada!`, '#9932CC', 1500);
        updatePauseMenuUI(); // Update pause menu after upgrade
    } else {
        this.hud.displayTemporaryEffect('Não é possível melhorar habilidade.', '#FF0000', 1000);
    }
}

function applySkillEffect(category, skillName, level) {
    switch (skillName) {
        case "FuriaAutomatica":
            // Effect: +Damage for each nearby enemy
            // This would require checking nearby enemies dynamically in update() or on hit
            // For now, let's just make it a flat damage increase per level for simplicity
            playerStats.bulletDamage += 0.1 * level; // Example: +0.1 damage per level
            break;
        case "PerfuracaoMecanica":
            if (level === 1) playerStats.bulletPiercing = true;
            break;
        case "ReflexosRapidos":
            playerStats.playerSpeed += 50 * level; // Example: +50 speed per level
            player.body.setMaxSpeed(playerStats.playerSpeed);
            break;
        case "TiroDuplo":
            if (level === 1) playerStats.doubleBullets = true;
            break;
        case "BlindagemAprimorada":
            playerStats.maxLife += 1 * level;
            playerStats.life = playerStats.maxLife; // Heal to new max
            this.hud.updateHealthBar();
            break;
        case "AutoReparo":
            if (level === 1) playerStats.passiveRegenActive = true;
            break;
        case "CargaRapida":
            // Reduce cooldowns of activable items
            // This can be applied as a global modifier to playerStats or directly when calculating cooldowns.
            // For now, let's say it reduces cooldowns by 5% per level
            playerStats.intelligence += 1; // Increase intelligence, which might be linked to cooldowns
            // Alternatively, a direct modifier: playerStats.activableCooldownReduction += 0.05 * level;
            break;
        case "AnaliseDeAmeaca":
            // Effect: Reveals off-screen enemies
            // This would require a minimap or indicator system
            if (level === 1) console.log("AnaliseDeAmeaca Habilidade Ativada!");
            break;
        // NEW Biopunk Skills
        case "RegeneracaoAtiva":
            playerStats.passiveRegenActive = true; // Ensure regen is active
            playerStats.passiveRegenAmount += 0.2 * level; // Increase regen amount
            break;
        case "SinfoniaParasitaria":
            // Effect handled in hitPlayer. This skill only needs to be active.
            // No direct stat change here, but flag might be useful for checks if needed.
            break;
        case "MembranaBioReativa":
            playerStats.statusEffects.damageReductionActive = true;
            playerStats.statusEffects.damageReductionAmount = 0.1 * level;
            // The duration and activation on hit will be handled in hitPlayer
            break;
    }
}

// --- Achievement System ---
function checkAchievements(achievementKey) {
    const achievement = playerStats.achievements[achievementKey];
    if (!achievement || achievement.unlocked) return; // Already unlocked or invalid key

    let unlocked = false;
    switch (achievementKey) {
        case 'FirstKill':
            // This is typically checked when an enemy dies the first time
            unlocked = true; // Assumed to be called after first kill
            break;
        case 'Wave10':
            if (waveNumber >= 10) unlocked = true;
            break;
        case 'MaxLevel':
            if (playerStats.level >= 50) unlocked = true; // Assuming max level is 50
            break;
        case 'Collect1000Scrap':
            if (playerStats.currency >= 1000) unlocked = true;
            break;
        case 'BossSlayer':
            // This would be set to true upon defeating a boss
            break;
        // Add more achievement checks here
    }

    if (unlocked) {
        achievement.unlocked = true;
        this.hud.displayTemporaryEffect(`Conquista Desbloqueada: ${achievementKey}!`, '#FFD700', 3000);
        // Optional: Grant rewards for achievements
        updatePauseMenuUI(); // Update UI to show unlocked achievement
    }
}

// --- Quest System (Basic Placeholder) ---
// Example quest structure
const quests = [
    {
        id: 'destroy_crates',
        title: 'Quebra-tudo',
        description: 'Destrua 10 caixas de sucata.',
        type: 'destroy', // Type of objective
        target: 10,
        progress: 0,
        rewardDescription: '200 Sucata',
        reward: (scene) => { playerStats.currency += 200; scene.hud.updateCurrencyDisplay(); }
    },
    {
        id: 'kill_enemies',
        title: 'Caça aos Robôs',
        description: 'Derrote 50 inimigos.',
        type: 'kill',
        target: 50,
        progress: 0,
        rewardDescription: '1 Peça Rara',
        reward: (scene) => { playerStats.rareParts += 1; scene.hud.updateRarePartsDisplay(); }
    }
];

function initializeQuests() {
    playerStats.activeQuests.push(quests[0]); // Start with the first quest
    playerStats.activeQuests.push(quests[1]); // Start with the second quest
}

function updateQuestProgress(questType, amount = 1) {
    playerStats.activeQuests.forEach(quest => {
        if (quest.type === questType && quest.progress < quest.target) {
            quest.progress += amount;
            if (quest.progress >= quest.target) {
                completeQuest.call(this, quest);
            }
        }
    });
}

function completeQuest(quest) {
    quest.reward(this);
    this.hud.displayTemporaryEffect(`Missão Concluída: ${quest.title}!`, '#00FF00', 2500);

    // Move quest from active to completed
    const index = playerStats.activeQuests.indexOf(quest);
    if (index > -1) {
        playerStats.activeQuests.splice(index, 1);
        playerStats.completedQuests.push(quest);
    }
    updatePauseMenuUI(); // Update quest display
}

// --- Drone Class ---
class Drone extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y, texture, type) {
        super(scene, x, y, texture);
        scene.add.existing(this);
        scene.physics.add.existing(this);

        this.type = type; // 'attack' or 'heal'
        this.baseSpeed = 150;
        this.setScale(0.04);
        this.setCollideWorldBounds(true);
        this.setCircle(this.width / 2);
        this.setDepth(1); // Above enemies, below player

        this.attackCooldown = 1000; // For attack drone
        this.lastAttack = 0;

        this.healCooldown = 2000; // For heal drone
        this.lastHeal = 0;
    }

    update(player, enemiesGroup) {
        // Follow player with a slight delay
        this.scene.physics.moveToObject(this, player, this.baseSpeed);

        if (this.type === 'attack') {
            if (this.scene.time.now > this.lastAttack + this.attackCooldown) {
                const nearestEnemy = this.scene.physics.closest(this, enemiesGroup.children.entries);
                if (nearestEnemy && nearestEnemy.active && Phaser.Math.Distance.Between(this.x, this.y, nearestEnemy.x, nearestEnemy.y) < 300) {
                    this.fireBullet(nearestEnemy);
                    this.lastAttack = this.scene.time.now;
                }
            }
        } else if (this.type === 'heal') {
            if (this.scene.time.now > this.lastHeal + this.healCooldown) {
                // Heal player or other drones
                if (playerStats.life < playerStats.maxLife) {
                    playerStats.life = Math.min(playerStats.life + 0.5, playerStats.maxLife); // Heal player for 0.5
                    this.scene.hud.updateHealthBar();
                    this.lastHeal = this.scene.time.now;
                    this.setTint(0x00FF00); // Flash green
                    this.scene.time.delayedCall(100, () => this.setTint(0xFFFFFF));
                }
            }
        }
    }

    fireBullet(target) {
        const bullet = this.scene.physics.add.sprite(this.x, this.y, 'bullet');
        bullet.setScale(0.015); // Smaller drone bullet
        bullet.damage = playerStats.bulletDamage * 0.5; // Half player damage
        this.scene.physics.moveToObject(bullet, target, 600);
        this.scene.physics.add.overlap(bullet, target, (b, t) => {
            b.disableBody(true, true);
            takeDamage(t, b.damage);
        });
        this.scene.time.delayedCall(1500, () => {
            if (bullet.active) bullet.destroy(); // Destroy bullet if it doesn't hit
        });
    }
}

function spawnDrone(type) {
    if (playerStats.droneActive) return; // Only one drone for now
    const droneTexture = type === 'attack' ? 'drone_attack' : 'drone_heal';
    const drone = new Drone(this, player.x + 50, player.y, droneTexture, type);
    dronesGroup.add(drone);
    playerStats.droneActive = true;
    this.hud.displayTemporaryEffect(`Drone de ${type === 'attack' ? 'Ataque' : 'Cura'} Ativado!`, '#00BFFF', 2000);
}


// --- Game Initialization ---
const game = new Phaser.Game(config);

// Call to initialize quests when the game starts (e.g., after loading assets)
// This might need to be called in the 'create' function of your scene
document.addEventListener('DOMContentLoaded', () => {
    // Ensure the game is ready before initializing quests that might update UI
    game.events.on('ready', () => {
        const scene = game.scene.getAt(0);
        if (scene && playerStats.activeQuests.length === 0) { // Only initialize if no quests are active
            initializeQuests.call(scene);
        }
    });
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons V.1.2.7 - Multi-Enemy Update</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0a0000ce;
    }
    canvas {
      display: block;
      margin: auto;}
  </style>
</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 1300,
  height: 580,
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: { debug: false }
  },
  scene: {
    preload,
    create,
    update
  }
};

let waveText;
let hudGroup;
let armaNomeText;
let armaImagem;
let player, cursors;
let bullets, enemyBullets;
let enemies;
let score = 0;
let scoreText;
let vidaText; // Removido, usando HUD de corações agora
let currentWave = 1;
let enemiesPerWave = 5;
let spawnTimer;
let enemiesAlive = 0;
let enemiesToSpawn = 0;
let bossHealthBarBg, bossHealthBarFill;
let bossNameText;

let playerStats = {
  life: 5,
  maxLife: 5,
  speed: 200,
  fireRate: 300, // milissegundos entre tiros
  bulletSpeed: 500,
  bulletDamage: 1,
  currentWeapon: 'pistol',
  canShoot: true
};

const weapons = {
  pistol: {
    name: 'Pistola',
    damage: 1,
    fireRate: 300,
    bulletSpeed: 500,
    ammo: Infinity,
    sprite: 'pistol_icon'
  },
  machinegun: {
    name: 'Metralhadora',
    damage: 0.5,
    fireRate: 100,
    bulletSpeed: 600,
    ammo: 150,
    sprite: 'machinegun_icon'
  },
  shotgun: {
    name: 'Escopeta',
    damage: 1.5,
    fireRate: 700,
    bulletSpeed: 400,
    ammo: 30,
    sprite: 'shotgun_icon',
    pellets: 5 // Para escopeta
  },
  laser: {
    name: 'Laser',
    damage: 2,
    fireRate: 150,
    bulletSpeed: 700,
    ammo: 100,
    sprite: 'laser_icon',
    isLaser: true // Flag para projéteis de laser
  },
  rocketlauncher: {
    name: 'Lança-Foguetes',
    damage: 5,
    fireRate: 1000,
    bulletSpeed: 300,
    ammo: 10,
    sprite: 'rocketlauncher_icon',
    isExplosive: true // Flag para explosões
  }
};

let activePowerUps = {};
let powerUpDuration = 10000; // 10 segundos
let powerUpGroup; // Grupo para os power-ups

let cards = {
  lifeBoost: {
    nome: 'Vida Extra',
    descricao: 'Aumenta sua vida máxima em 1.',
    efeito: (scene) => {
      playerStats.maxLife++;
      playerStats.life = playerStats.maxLife; // Cura total ao ganhar vida extra
      scene.hud.updateHearts(); // Atualiza o HUD de corações
    },
    cor: 0x4CAF50, // Verde
    sprite: 'heart_powerup' // Exemplo de sprite
  },
  speedBoost: {
    nome: 'Super Velocidade',
    descricao: 'Aumenta a velocidade do jogador.',
    efeito: (scene) => {
      playerStats.speed += 50;
      scene.time.delayedCall(powerUpDuration, () => {
        playerStats.speed -= 50;
      });
    },
    cor: 0x2196F3, // Azul
    sprite: 'speed_powerup' // Exemplo de sprite
  },
  fireRateBoost: {
    nome: 'Tiro Rápido',
    descricao: 'Diminui o tempo entre os tiros.',
    efeito: (scene) => {
      playerStats.fireRate -= 50;
      if (playerStats.fireRate < 50) playerStats.fireRate = 50; // Limite mínimo
      scene.time.delayedCall(powerUpDuration, () => {
        playerStats.fireRate += 50;
      });
    },
    cor: 0xFF9800, // Laranja
    sprite: 'firerate_powerup' // Exemplo de sprite
  },
  damageBoost: {
    nome: 'Dano Brutal',
    descricao: 'Aumenta o dano das suas balas.',
    efeito: (scene) => {
      playerStats.bulletDamage += 0.5;
      scene.time.delayedCall(powerUpDuration, () => {
        playerStats.bulletDamage -= 0.5;
      });
    },
    cor: 0xF44336, // Vermelho
    sprite: 'damage_powerup' // Exemplo de sprite
  },
  multiShot: {
    nome: 'Tiro Múltiplo',
    descricao: 'Atira 3 balas em um pequeno arco.',
    efeito: (scene) => {
      activePowerUps.multiShot = true;
      scene.time.delayedCall(powerUpDuration, () => {
        delete activePowerUps.multiShot;
      });
    },
    cor: 0x9C27B0, // Roxo
    sprite: 'multishot_powerup' // Exemplo de sprite
  },
  grenade: {
    nome: 'Granada',
    descricao: 'Joga uma granada que explode.',
    efeito: (scene) => {
      // Implementar lógica da granada
      console.log('Granada ativada!');
    },
    cor: 0x607D8B, // Cinza
    sprite: 'grenade_powerup' // Exemplo de sprite
  }
};

let playerWeapons = {
  pistol: true,
  machinegun: false,
  shotgun: false,
  laser: false,
  rocketlauncher: false
};

let currentCardChoices = [];
let cardsHUDGroup; // Novo grupo para o HUD das cartas
let activeCardCount = {}; // Contador de cartas ativas

// Classe HUD para gerenciar a interface do usuário
class HUD extends Phaser.Scene {
  constructor() {
    super({ key: 'HUD', active: true });
    this.enemy = null; // Inimigo atualmente visado para barra de vida
    this.heartSize = 32; // Tamanho dos corações
  }

  preload() {
    // Já carregado na cena principal, mas se fosse independente, carregaria aqui
  }

  create() {
    const mainScene = this.scene.get('default');

    scoreText = this.add.text(10, 10, 'Pontos: 0', { fontSize: '20px', fill: '#fff' }).setScrollFactor(0);
    waveText = this.add.text(this.game.config.width - 10, 10, 'Onda: 1', { fontSize: '20px', fill: '#fff' }).setOrigin(1, 0).setScrollFactor(0);

    hudGroup = this.add.group();
    hudGroup.add(scoreText);
    hudGroup.add(waveText);

    // Adiciona o HUD da arma
    armaImagem = this.add.image(10, 40, weapons[playerStats.currentWeapon].sprite)
      .setOrigin(0, 0)
      .setScale(0.7)
      .setScrollFactor(0)
      .setDepth(1);
    armaNomeText = this.add.text(armaImagem.x + armaImagem.width * armaImagem.scaleX + 5, 45, weapons[playerStats.currentWeapon].name, { fontSize: '18px', fill: '#fff' }).setScrollFactor(0);
    this.ammoText = this.add.text(armaNomeText.x, armaNomeText.y + 20, '', { fontSize: '16px', fill: '#fff' }).setScrollFactor(0);
    hudGroup.add(armaImagem);
    hudGroup.add(armaNomeText);
    hudGroup.add(this.ammoText);

    // HUD de corações
    this.heartsGroup = this.add.group();
    this.updateHearts();

    // HUD para as cartas (inicialmente vazio)
    cardsHUDGroup = this.add.group();
    mainScene.events.on('updateHUDCartas', this.atualizarHUDCartas, this); // Otimizado

    // Barra de vida do boss (inicialmente escondida)
    bossHealthBarBg = this.add.graphics().setScrollFactor(0).setDepth(2);
    bossHealthBarFill = this.add.graphics().setScrollFactor(0).setDepth(2);
    bossNameText = this.add.text(this.game.config.width / 2, 70, '', { fontSize: '20px', fill: '#fff', align: 'center' }).setOrigin(0.5).setScrollFactor(0).setDepth(2);
    this.hideBossHealthBar(); // Esconde no início

    // Barra de vida do inimigo normal
    this.enemyHealthBarBg = this.add.graphics().setScrollFactor(0).setDepth(1);
    this.enemyHealthBarFill = this.add.graphics().setScrollFactor(0).setDepth(1);
    this.enemyHealthBarBg.setVisible(false);
    this.enemyHealthBarFill.setVisible(false);
  }

  updateHearts() {
    this.heartsGroup.clear(true, true); // Limpa corações existentes
    const startX = 10;
    const startY = this.game.config.height - 40; // Perto do canto inferior esquerdo

    for (let i = 0; i < playerStats.maxLife; i++) {
      const x = startX + i * (this.heartSize + 5); // 5px de espaçamento
      const heart = this.add.image(x, startY, 'heart_full')
        .setScrollFactor(0)
        .setScale(this.heartSize / 16) // Ajusta a escala para o tamanho desejado
        .setOrigin(0, 0);
      this.heartsGroup.add(heart);
    }
    // Atualiza o estado visual dos corações
    for (let i = 0; i < this.heartsGroup.getLength(); i++) {
      const heart = this.heartsGroup.getChildren()[i];
      if (i < playerStats.life) {
        heart.setAlpha(1);
      } else {
        heart.setAlpha(0.3); // Coração "vazio"
      }
    }
  }


  update() {
    // Atualiza corações conforme vida do player
    for (let i = 0; i < this.heartsGroup.getLength(); i++) {
      const heart = this.heartsGroup.getChildren()[i];
      if (i < playerStats.life) { // Use playerStats.life
        heart.setAlpha(1);
      } else {
        heart.setAlpha(0.3);
      }
    }

    // Atualiza barra de vida do inimigo (se tiver algum inimigo ativo na mira)
    if (this.enemy && this.enemy.active && !this.enemy.isBoss) { // Don't show for boss
      // Posição da barra de vida acima do inimigo
      const barX = this.enemy.x - 25 + this.cameras.main.scrollX;
      const barY = this.enemy.y - this.enemy.displayHeight / 2 - 10 + this.cameras.main.scrollY;
      const barWidth = 50;
      const barHeight = 5;

      this.enemyHealthBarBg.clear();
      this.enemyHealthBarBg.fillStyle(0x000000, 0.5);
      this.enemyHealthBarBg.fillRect(barX, barY, barWidth, barHeight);

      this.enemyHealthBarFill.clear();
      this.enemyHealthBarFill.fillStyle(0xff0000, 1);
      this.enemyHealthBarFill.fillRect(barX, barY, barWidth * (this.enemy.health / this.enemy.maxHealth), barHeight);

      this.enemyHealthBarBg.setVisible(true);
      this.enemyHealthBarFill.setVisible(true);
    } else {
      this.enemyHealthBarBg.setVisible(false);
      this.enemyHealthBarFill.setVisible(false);
    }
  }

  // Define o inimigo para mostrar a barra de vida
  setEnemy(enemy) {
    this.enemy = enemy;
  }

  // Esconde a barra de vida do inimigo
  hideEnemyHealthBar() {
    this.enemy = null;
    this.enemyHealthBarBg.setVisible(false);
    this.enemyHealthBarFill.setVisible(false);
  }

  updateScore(newScore) {
    scoreText.setText('Pontos: ' + newScore);
  }

  updateWave(newWave) {
    waveText.setText('Onda: ' + newWave);
  }

  updateWeaponHUD(weaponName, ammo) {
    armaNomeText.setText(weaponName);
    armaImagem.setTexture(weapons[playerStats.currentWeapon].sprite);
    if (ammo !== Infinity) {
      this.ammoText.setText(`Munição: ${ammo}`);
    } else {
      this.ammoText.setText('');
    }
  }

  showBossHealthBar(boss) {
    const barWidth = this.game.config.width * 0.6; // 60% da largura da tela
    const barHeight = 20;
    const barX = (this.game.config.width - barWidth) / 2;
    const barY = 100; // Posição abaixo do topo

    bossHealthBarBg.clear();
    bossHealthBarBg.fillStyle(0x000000, 0.7);
    bossHealthBarBg.fillRect(barX, barY, barWidth, barHeight);
    bossHealthBarBg.setVisible(true);

    bossHealthBarFill.clear();
    bossHealthBarFill.fillStyle(0xFF0000, 1);
    bossHealthBarFill.fillRect(barX, barY, barWidth * (boss.health / boss.maxHealth), barHeight);
    bossHealthBarFill.setVisible(true);

    bossNameText.setText(boss.name);
    bossNameText.setVisible(true);
  }

  hideBossHealthBar() {
    bossHealthBarBg.setVisible(false);
    bossHealthBarFill.setVisible(false);
    bossNameText.setVisible(false);
  }

  // Otimizado: Recebe as cartas ativas e redesenha o HUD
  atualizarHUDCartas(activeCardCounts) {
    cardsHUDGroup.clear(true, true); // Limpa antes de redesenhar

    let currentX = this.game.config.width / 2 - (Object.keys(activeCardCounts).length * 60) / 2;
    const startY = this.game.config.height - 90; // Posição inferior para as cartas ativas

    for (const cardName in activeCardCounts) {
      const card = cards[cardName];
      if (!card) continue; // Garante que a carta existe

      const bgImage = this.add.image(currentX, startY, 'cardBg')
        .setDisplaySize(50, 70) // Ajusta o tamanho da imagem de fundo da carta
        .setOrigin(0.5, 0.5)
        .setScrollFactor(0)
        .setTint(card.cor || 0x999999) // Aplica a cor na imagem de fundo da carta
        .setAlpha(0.8);
      cardsHUDGroup.add(bgImage);

      // Adiciona uma borda para destaque
      const border = this.add.rectangle(currentX, startY, 50, 70)
        .setStrokeStyle(2, 0xffffff)
        .setScrollFactor(0);
      cardsHUDGroup.add(border);


      const title = this.add.text(currentX, startY - 20, card.nome[0], {
        fontSize: '24px',
        color: '#fff',
        fixedWidth: 50, // Garante que o texto não ultrapasse
        align: 'center'
      }).setOrigin(0.5).setScrollFactor(0);
      cardsHUDGroup.add(title);

      const countText = this.add.text(currentX, startY + 15, activeCardCounts[cardName], {
        fontSize: '18px',
        color: '#fff',
        fixedWidth: 50,
        align: 'center'
      }).setOrigin(0.5).setScrollFactor(0);
      cardsHUDGroup.add(countText);

      currentX += 60; // Espaçamento entre as cartas
    }
  }
}

let game = new Phaser.Game(config);

function preload() {
  this.load.image('player', 'assets/player.png');
  this.load.image('bullet', 'assets/bullet.png');
  this.load.image('enemy1', 'assets/enemy1.png');
  this.load.image('enemy2', 'assets/enemy2.png');
  this.load.image('enemy3', 'assets/enemy3.png');
  this.load.image('boss1', 'assets/boss1.png');
  this.load.image('health_pickup', 'assets/health_pickup.png');
  this.load.image('ammo_pickup', 'assets/ammo_pickup.png');
  this.load.image('weapon_pickup', 'assets/weapon_pickup.png');
  this.load.image('laser_bullet', 'assets/laser_bullet.png'); // Para projéteis de laser
  this.load.image('rocket', 'assets/rocket.png'); // Para foguetes
  this.load.image('explosion', 'assets/explosion.png'); // Para explosões
  this.load.image('tile', 'assets/tile.png'); // Tile para o fundo

  // Sprites de armas (se tiver ícones específicos)
  this.load.image('pistol_icon', 'assets/pistol_icon.png');
  this.load.image('machinegun_icon', 'assets/machinegun_icon.png');
  this.load.image('shotgun_icon', 'assets/shotgun_icon');
  this.load.image('laser_icon', 'assets/laser_icon.png');
  this.load.image('rocketlauncher_icon', 'assets/rocketlauncher_icon.png');

  // Sprites de power-ups para as cartas
  this.load.image('heart_powerup', 'assets/heart_powerup.png');
  this.load.image('speed_powerup', 'assets/speed_powerup.png');
  this.load.image('firerate_powerup', 'assets/firerate_powerup.png');
  this.load.image('damage_powerup', 'assets/damage_powerup.png');
  this.load.image('multishot_powerup', 'assets/multishot_powerup.png');
  this.load.image('grenade_powerup', 'assets/grenade_powerup.png');

  this.load.image('heart_full', 'assets/heart_full.png'); // Coração cheio
  this.load.image('cardBg', 'assets/cardBg.png'); // Fundo para as cartas no pop-up e HUD

  // Carrega spritesheets para animações (se houver)
  this.load.spritesheet('explosion_ss', 'assets/explosion_spritesheet.png', { frameWidth: 64, frameHeight: 64 });
}

function create() {
  this.scene.launch('HUD'); // Inicia a cena HUD
  this.hud = this.scene.get('HUD'); // Pega a referência para a cena HUD

  // Cria um background de tiles
  const worldWidth = 2000; // Largura do mundo
  const worldHeight = 2000; // Altura do mundo
  this.add.tileSprite(0, 0, worldWidth, worldHeight, 'tile').setOrigin(0, 0);
  this.physics.world.setBounds(0, 0, worldWidth, worldHeight);

  player = this.physics.add.sprite(config.width / 2, config.height / 2, 'player').setCollideWorldBounds(true);
  player.setDamping(true).setDrag(0.99); // Adiciona inércia ao movimento

  cursors = this.input.keyboard.createCursorKeys();
  this.input.keyboard.on('keydown-SPACE', fireBullet, this);
  this.input.keyboard.on('keydown-ONE', () => switchWeapon('pistol'), this);
  this.input.keyboard.on('keydown-TWO', () => switchWeapon('machinegun'), this);
  this.input.keyboard.on('keydown-THREE', () => switchWeapon('shotgun'), this);
  this.input.keyboard.on('keydown-FOUR', () => switchWeapon('laser'), this);
  this.input.keyboard.on('keydown-FIVE', () => switchWeapon('rocketlauncher'), this);
  this.input.keyboard.on('keydown-E', showLevelUpChoices, this); // Key for Level Up/Card choice

  bullets = this.physics.add.group({
    defaultKey: 'bullet',
    maxSize: 50 // Limita o número de balas para performance
  });

  enemyBullets = this.physics.add.group({
    defaultKey: 'bullet',
    maxSize: 50 // Limita o número de balas dos inimigos
  });

  enemies = this.physics.add.group();
  powerUpGroup = this.physics.add.group(); // Inicializa o grupo de power-ups

  this.physics.add.collider(player, enemies, hitPlayer, null, this);
  this.physics.add.collider(bullets, enemies, hitEnemy, null, this);
  this.physics.add.collider(player, powerUpGroup, collectPowerUp, null, this);
  this.physics.add.collider(enemyBullets, player, hitPlayerByEnemyBullet, null, this);

  // Colisão entre balas de player e inimigos
  this.physics.add.overlap(bullets, enemies, (bullet, enemy) => {
    bullet.destroy();
    enemy.health -= playerStats.bulletDamage * weapons[playerStats.currentWeapon].damage;
    if (enemy.health <= 0) {
      enemy.destroy();
      score += 10;
      this.hud.updateScore(score);
      enemiesAlive--;
      if (enemy.isBoss) {
        this.hud.hideBossHealthBar();
        this.time.delayedCall(1000, showLevelUpChoices, [], this); // Após 1 segundo, mostra escolha de carta
      }
    }
  });

  // Câmera segue o jogador
  this.cameras.main.setBounds(0, 0, worldWidth, worldHeight);
  this.cameras.main.startFollow(player, true, 0.05, 0.05);

  spawnTimer = this.time.addEvent({
    delay: 2000, // Spawn a cada 2 segundos
    callback: spawnEnemy,
    callbackScope: this,
    loop: true
  });

  this.time.addEvent({
    delay: 1000, // A cada 1 segundo
    callback: () => {
      // Atualiza o HUD das cartas ativas
      this.hud.atualizarHUDCartas(activeCardCount);
    },
    callbackScope: this,
    loop: true
  });

  startWave();
}

function update() {
  // Movimento do jogador
  player.setVelocity(0);

  if (cursors.left.isDown) {
    player.setVelocityX(-playerStats.speed);
  } else if (cursors.right.isDown) {
    player.setVelocityX(playerStats.speed);
  }

  if (cursors.up.isDown) {
    player.setVelocityY(-playerStats.speed);
  } else if (cursors.down.isDown) {
    player.setVelocityY(playerStats.speed);
  }

  // Rotação do jogador para olhar para o ponteiro do mouse
  let angle = Phaser.Math.Angle.Between(player.x, player.y, this.input.activePointer.x + this.cameras.main.scrollX, this.input.activePointer.y + this.cameras.main.scrollY);
  player.setRotation(angle + Math.PI / 2); // Ajuste de 90 graus

  // Atirar com o mouse
  if (this.input.activePointer.isDown) {
    fireBullet.call(this);
  }

  // Atualiza barra de vida do inimigo seguindo o inimigo visado
  let closestEnemy = null;
  let minDistance = Infinity;

  enemies.children.each(function (enemy) {
    if (enemy.active && !enemy.isBoss) {
      const distance = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
      if (distance < minDistance) {
        minDistance = distance;
        closestEnemy = enemy;
      }
    }
  }, this);

  if (closestEnemy) {
    this.hud.setEnemy(closestEnemy);
  } else {
    this.hud.hideEnemyHealthBar();
  }

  // Lógica para inimigos
  enemies.children.each(function (enemy) {
    if (enemy.active) {
      this.physics.moveToObject(enemy, player, enemy.speed); // Inimigos se movem em direção ao jogador

      // Inimigos atirando (exemplo básico)
      if (enemy.canShoot && enemy.lastShot + enemy.fireRate < this.time.now) {
        let enemyBullet = enemyBullets.get(enemy.x, enemy.y);
        if (enemyBullet) {
          enemyBullet.setActive(true).setVisible(true);
          this.physics.moveToObject(enemyBullet, player, enemy.bulletSpeed);
          enemy.lastShot = this.time.now;
        }
      }
    }
  }, this);

  // Limpa balas fora da tela
  bullets.children.each(function (bullet) {
    if (bullet.active && !this.physics.world.bounds.contains(bullet.x, bullet.y)) {
      bullet.destroy();
    }
  }, this);

  enemyBullets.children.each(function (bullet) {
    if (bullet.active && !this.physics.world.bounds.contains(bullet.x, bullet.y)) {
      bullet.destroy();
    }
  }, this);
}

function fireBullet() {
  if (!playerStats.canShoot) return;

  const weapon = weapons[playerStats.currentWeapon];
  if (weapon.ammo <= 0 && weapon.ammo !== Infinity) return;

  const bulletOffset = 30; // Distância do player
  const dx = Math.cos(player.rotation - Math.PI / 2);
  const dy = Math.sin(player.rotation - Math.PI / 2);

  const startX = player.x + dx * bulletOffset;
  const startY = player.y + dy * bulletOffset;

  if (activePowerUps.multiShot && !weapon.pellets && !weapon.isLaser && !weapon.isExplosive) {
    // Tiro múltiplo (power-up)
    for (let i = -1; i <= 1; i++) {
      let bullet = bullets.get(startX, startY);
      if (bullet) {
        let angle = player.rotation + i * 0.2; // Pequeno arco
        bullet.setActive(true).setVisible(true);
        this.physics.velocityFromRotation(angle - Math.PI / 2, weapon.bulletSpeed, bullet.body.velocity);
      }
    }
  } else if (weapon.pellets) {
    // Escopeta (múltiplos projéteis)
    for (let i = 0; i < weapon.pellets; i++) {
      let bullet = bullets.get(startX, startY);
      if (bullet) {
        let angleOffset = Phaser.Math.Between(-15, 15) * Phaser.Math.DEG_TO_RAD; // Espalhamento
        let angle = player.rotation + angleOffset;
        bullet.setActive(true).setVisible(true);
        this.physics.velocityFromRotation(angle - Math.PI / 2, weapon.bulletSpeed, bullet.body.velocity);
      }
    }
  } else if (weapon.isLaser) {
    // Laser
    let bullet = bullets.get(startX, startY, 'laser_bullet'); // Usa sprite de laser
    if (bullet) {
      bullet.setActive(true).setVisible(true);
      this.physics.velocityFromRotation(player.rotation - Math.PI / 2, weapon.bulletSpeed, bullet.body.velocity);
      // Efeito de laser
      this.add.tween({
        targets: bullet,
        alpha: { from: 1, to: 0.5 },
        duration: weapon.fireRate / 2,
        yoyo: true,
        repeat: 0
      });
    }
  } else if (weapon.isExplosive) {
    // Foguete
    let rocket = bullets.get(startX, startY, 'rocket'); // Usa sprite de foguete
    if (rocket) {
      rocket.setActive(true).setVisible(true);
      this.physics.velocityFromRotation(player.rotation - Math.PI / 2, weapon.bulletSpeed, rocket.body.velocity);
      rocket.damage = weapon.damage; // Transfere o dano para a bala para uso na explosão
      rocket.setRotation(player.rotation); // Rotação do foguete
    }
  } else {
    // Tiro normal
    let bullet = bullets.get(startX, startY);
    if (bullet) {
      bullet.setActive(true).setVisible(true);
      this.physics.velocityFromRotation(player.rotation - Math.PI / 2, weapon.bulletSpeed, bullet.body.velocity);
    }
  }

  // Atualiza munição (se não for infinita)
  if (weapon.ammo !== Infinity) {
    weapon.ammo--;
    this.hud.updateWeaponHUD(weapon.name, weapon.ammo);
  }

  playerStats.canShoot = false;
  this.time.delayedCall(playerStats.fireRate, () => {
    playerStats.canShoot = true;
  });
}

function hitPlayer(player, enemy) {
  if (player.invincible) return; // Se o jogador estiver invencível, não sofre dano

  playerStats.life--;
  this.hud.updateHearts(); // Atualiza o HUD de corações

  if (playerStats.life <= 0) {
    // Game Over
    this.physics.pause();
    player.setTint(0xff0000);
    this.add.text(this.cameras.main.scrollX + config.width / 2, this.cameras.main.scrollY + config.height / 2, 'GAME OVER', { fontSize: '64px', fill: '#ff0000' }).setOrigin(0.5);
    this.time.addEvent({
      delay: 2000,
      callback: () => {
        this.scene.restart();
        this.scene.launch('HUD'); // Relança o HUD
        // Resetar stats do player para um novo jogo
        playerStats = {
          life: 5,
          maxLife: 5,
          speed: 200,
          fireRate: 300,
          bulletSpeed: 500,
          bulletDamage: 1,
          currentWeapon: 'pistol',
          canShoot: true
        };
        score = 0;
        currentWave = 1;
        enemiesPerWave = 5;
        enemiesAlive = 0;
        enemiesToSpawn = 0;
        playerWeapons = {
          pistol: true,
          machinegun: false,
          shotgun: false,
          laser: false,
          rocketlauncher: false
        };
        activePowerUps = {};
        activeCardCount = {};
      },
      callbackScope: this
    });
  } else {
    // Aplica invencibilidade temporária
    player.setTint(0xff0000); // Fica vermelho quando leva dano
    player.invincible = true;
    this.time.delayedCall(1000, () => {
      player.clearTint();
      player.invincible = false;
    });
  }
}

function hitPlayerByEnemyBullet(player, bullet) {
  bullet.destroy();
  if (player.invincible) return;

  playerStats.life -= 1; // Bala inimiga tira 1 de vida
  this.hud.updateHearts(); // Atualiza o HUD de corações

  if (playerStats.life <= 0) {
    // Game Over (mesma lógica de hitPlayer)
    this.physics.pause();
    player.setTint(0xff0000);
    this.add.text(this.cameras.main.scrollX + config.width / 2, this.cameras.main.scrollY + config.height / 2, 'GAME OVER', { fontSize: '64px', fill: '#ff0000' }).setOrigin(0.5);
    this.time.addEvent({
      delay: 2000,
      callback: () => {
        this.scene.restart();
        this.scene.launch('HUD');
        playerStats = {
          life: 5,
          maxLife: 5,
          speed: 200,
          fireRate: 300,
          bulletSpeed: 500,
          bulletDamage: 1,
          currentWeapon: 'pistol',
          canShoot: true
        };
        score = 0;
        currentWave = 1;
        enemiesPerWave = 5;
        enemiesAlive = 0;
        enemiesToSpawn = 0;
        playerWeapons = {
          pistol: true,
          machinegun: false,
          shotgun: false,
          laser: false,
          rocketlauncher: false
        };
        activePowerUps = {};
        activeCardCount = {};
      },
      callbackScope: this
    });
  } else {
    // Aplica invencibilidade temporária
    player.setTint(0xff0000);
    player.invincible = true;
    this.time.delayedCall(1000, () => {
      player.clearTint();
      player.invincible = false;
    });
  }
}


function hitEnemy(bullet, enemy) {
  if (weapons[playerStats.currentWeapon].isExplosive && bullet.texture.key === 'rocket') {
    // Se for um foguete, ele explode
    createExplosion.call(this, bullet.x, bullet.y);
    bullet.destroy();
    // Afeta inimigos próximos
    enemies.children.each(function (e) {
      const distance = Phaser.Math.Distance.Between(bullet.x, bullet.y, e.x, e.y);
      if (distance < 100) { // Raio da explosão
        e.health -= bullet.damage; // Dano do foguete
        if (e.health <= 0) {
          e.destroy();
          score += 10;
          this.hud.updateScore(score);
          enemiesAlive--;
          if (e.isBoss) {
            this.hud.hideBossHealthBar();
            this.time.delayedCall(1000, showLevelUpChoices, [], this);
          }
        }
      }
    }, this);
  } else {
    bullet.destroy();
    enemy.health -= playerStats.bulletDamage * weapons[playerStats.currentWeapon].damage;
  }


  if (enemy.health <= 0) {
    if (Phaser.Math.RND.between(1, 100) <= 20) { // 20% de chance de drop de pickup
      spawnPowerUp.call(this, enemy.x, enemy.y);
    }
    enemy.destroy();
    score += 10;
    this.hud.updateScore(score);
    enemiesAlive--;

    if (enemy.isBoss) {
      this.hud.hideBossHealthBar();
      this.time.delayedCall(1000, showLevelUpChoices, [], this); // Após 1 segundo, mostra escolha de carta
    }
  }
}

function spawnEnemy() {
  if (enemiesToSpawn > 0) {
    let x, y;
    let spawnEdge = Phaser.Math.RND.between(0, 3); // 0: top, 1: right, 2: bottom, 3: left

    if (spawnEdge === 0) { // Top
      x = Phaser.Math.RND.between(0, this.physics.world.bounds.width);
      y = 0;
    } else if (spawnEdge === 1) { // Right
      x = this.physics.world.bounds.width;
      y = Phaser.Math.RND.between(0, this.physics.world.bounds.height);
    } else if (spawnEdge === 2) { // Bottom
      x = Phaser.Math.RND.between(0, this.physics.world.bounds.width);
      y = this.physics.world.bounds.height;
    } else { // Left
      x = 0;
      y = Phaser.Math.RND.between(0, this.physics.world.bounds.height);
    }

    let enemyType = Phaser.Math.RND.between(1, 3); // 1, 2 ou 3 para diferentes inimigos
    let enemy;

    if (enemyType === 1) {
      enemy = enemies.create(x, y, 'enemy1').setCollideWorldBounds(true);
      enemy.health = 5;
      enemy.maxHealth = 5;
      enemy.speed = 100;
      enemy.canShoot = false;
    } else if (enemyType === 2) {
      enemy = enemies.create(x, y, 'enemy2').setCollideWorldBounds(true);
      enemy.health = 8;
      enemy.maxHealth = 8;
      enemy.speed = 80;
      enemy.canShoot = true; // Este inimigo atira
      enemy.fireRate = 1500;
      enemy.lastShot = 0;
      enemy.bulletSpeed = 300;
    } else {
      enemy = enemies.create(x, y, 'enemy3').setCollideWorldBounds(true);
      enemy.health = 12;
      enemy.maxHealth = 12;
      enemy.speed = 60;
      enemy.canShoot = false;
    }

    enemy.setTint(0x808080); // Cor cinza para inimigos normais
    enemiesToSpawn--;
    enemiesAlive++;
  } else if (enemiesAlive === 0 && enemiesToSpawn === 0) {
    // Todos os inimigos da onda foram eliminados ou não há mais para spawnar
    endWave.call(this);
  }
}

function startWave() {
  this.hud.updateWave(currentWave);
  enemiesToSpawn = enemiesPerWave;
  enemiesAlive = 0; // Reset para a nova onda

  if (currentWave % 5 === 0) { // A cada 5 ondas, um boss
    spawnBoss.call(this);
  }
  // Aumenta o número de inimigos para a próxima onda
  enemiesPerWave += 2;
}

function endWave() {
  currentWave++;
  this.time.delayedCall(2000, startWave, [], this); // Inicia próxima onda após 2 segundos
}

function spawnBoss() {
  const boss = enemies.create(this.physics.world.bounds.width / 2, 100, 'boss1').setCollideWorldBounds(true);
  boss.isBoss = true; // Flag para identificar o boss
  boss.health = 50 * currentWave; // Vida do boss escala com a onda
  boss.maxHealth = boss.health;
  boss.speed = 50;
  boss.name = `Mega-Autômato [Onda ${currentWave}]`;
  boss.setTint(0x8B0000); // Cor vermelha escura para o boss

  this.hud.showBossHealthBar(boss);
  enemiesAlive++; // Boss também conta como inimigo vivo
}

function switchWeapon(newWeapon) {
  if (playerWeapons[newWeapon]) {
    playerStats.currentWeapon = newWeapon;
    playerStats.fireRate = weapons[newWeapon].fireRate;
    playerStats.bulletDamage = weapons[newWeapon].damage;
    playerStats.bulletSpeed = weapons[newWeapon].bulletSpeed;
    this.hud.updateWeaponHUD(weapons[newWeapon].name, weapons[newWeapon].ammo);
  } else {
    // Mensagem de "Arma não desbloqueada"
    console.log(`Arma ${weapons[newWeapon].name} não desbloqueada!`);
  }
}

function spawnPowerUp(x, y) {
  const powerUpTypes = ['health_pickup', 'ammo_pickup', 'weapon_pickup'];
  const chosenType = Phaser.Math.RND.pick(powerUpTypes);
  const powerUp = powerUpGroup.create(x, y, chosenType);
  powerUp.setCollideWorldBounds(true);
  powerUp.setBounce(0.6); // Efeito de quique

  // Adiciona um tween para fazer o power-up piscar ou flutuar
  this.tweens.add({
    targets: powerUp,
    y: powerUp.y - 10, // Flutua para cima
    duration: 800,
    ease: 'Sine.easeInOut',
    yoyo: true,
    repeat: -1 // Infinito
  });
}

function collectPowerUp(player, powerUp) {
  if (powerUp.texture.key === 'health_pickup') {
    playerStats.life = Math.min(playerStats.life + 1, playerStats.maxLife);
    this.hud.updateHearts();
  } else if (powerUp.texture.key === 'ammo_pickup') {
    // Recarrega munição de uma arma aleatória ou da atual
    const currentWeaponObj = weapons[playerStats.currentWeapon];
    if (currentWeaponObj.ammo !== Infinity) {
      currentWeaponObj.ammo += 50; // Exemplo: adiciona 50 balas
      this.hud.updateWeaponHUD(currentWeaponObj.name, currentWeaponObj.ammo);
    } else {
      // Se a arma atual for infinita, recarrega uma arma aleatória não infinita
      const availableWeapons = Object.keys(weapons).filter(key => weapons[key].ammo !== Infinity && playerWeapons[key]);
      if (availableWeapons.length > 0) {
        const randomWeaponKey = Phaser.Math.RND.pick(availableWeapons);
        weapons[randomWeaponKey].ammo += 50;
        // Se a arma recarregada for a atual, atualiza o HUD
        if (randomWeaponKey === playerStats.currentWeapon) {
          this.hud.updateWeaponHUD(weapons[randomWeaponKey].name, weapons[randomWeaponKey].ammo);
        }
      }
    }
  } else if (powerUp.texture.key === 'weapon_pickup') {
    // Desbloqueia uma arma aleatória que o jogador ainda não tem
    const unownedWeapons = Object.keys(playerWeapons).filter(key => !playerWeapons[key]);
    if (unownedWeapons.length > 0) {
      const newWeaponKey = Phaser.Math.RND.pick(unownedWeapons);
      playerWeapons[newWeaponKey] = true;
      // Exemplo: dá 50 munição inicial para a nova arma
      if (weapons[newWeaponKey].ammo !== Infinity) {
        weapons[newWeaponKey].ammo = 50;
      }
      this.hud.updateWeaponHUD(weapons[playerStats.currentWeapon].name, weapons[playerStats.currentWeapon].ammo); // Atualiza para exibir a nova arma
      // Mensagem de arma desbloqueada
      this.add.text(player.x, player.y - 50, `Arma ${weapons[newWeaponKey].name} desbloqueada!`, { fontSize: '20px', fill: '#00ff00' })
        .setOrigin(0.5)
        .setDepth(1)
        .setAlpha(0)
        .addTween({
          targets: this,
          alpha: 1,
          duration: 500,
          yoyo: true,
          onComplete: function (tween, targets) {
            targets[0].destroy();
          }
        });
    } else {
      // Se já tem todas as armas, pode dar munição extra ou vida
      playerStats.life = Math.min(playerStats.life + 1, playerStats.maxLife);
      this.hud.updateHearts();
    }
  }
  powerUp.destroy();
}

function createExplosion(x, y) {
  const explosion = this.add.sprite(x, y, 'explosion_ss').play('explode');
  explosion.on('animationcomplete', () => {
    explosion.destroy();
  });
}

// Cria animação de explosão no create da cena principal
this.anims.create({
  key: 'explode',
  frames: this.anims.generateFrameNumbers('explosion_ss', { start: 0, end: 15 }),
  frameRate: 24,
  hideOnComplete: true
});

function showLevelUpChoices() {
  this.physics.pause(); // Pausa o jogo
  playerStats.canShoot = false; // Impede o jogador de atirar

  const choicesPanel = this.add.container(this.cameras.main.scrollX + config.width / 2, this.cameras.main.scrollY + config.height / 2);
  choicesPanel.setDepth(100);

  const panelBg = this.add.graphics();
  panelBg.fillStyle(0x000000, 0.8);
  panelBg.fillRect(-350, -150, 700, 300); // Fundo para as 3 cartas
  choicesPanel.add(panelBg);

  this.add.text(0, -120, 'Escolha uma Melhoria!', { fontSize: '32px', fill: '#fff' }).setOrigin(0.5).setDepth(1).setContainer(choicesPanel);

  const availableCards = Object.keys(cards);
  currentCardChoices = []; // Limpa escolhas anteriores

  // Escolhe 3 cartas aleatórias e únicas
  while (currentCardChoices.length < 3 && availableCards.length > 0) {
    const randomIndex = Phaser.Math.RND.between(0, availableCards.length - 1);
    const chosenCardName = availableCards[randomIndex];
    currentCardChoices.push(chosenCardName);
    availableCards.splice(randomIndex, 1); // Remove para evitar repetição
  }

  const cardSpacing = 200; // Espaçamento entre as cartas
  let startX = -cardSpacing; // Posição inicial para centralizar 3 cartas

  currentCardChoices.forEach((cardName, index) => {
    const card = cards[cardName];
    const xPos = startX + index * cardSpacing;

    const bgImage = this.add.image(xPos, 0, 'cardBg')
      .setDisplaySize(160, 240)
      .setTint(card.cor || 0xADD8E6) // Cor da carta
      .setInteractive({ useHandCursor: true })
      .on('pointerover', function () { this.setTint(0xAAAAAA); }) // Efeito hover
      .on('pointerout', function () { this.setTint(card.cor || 0xADD8E6); })
      .on('pointerdown', () => selecionarCarta.call(this, cardName, choicesPanel)); // Chama a função ao clicar

    const title = this.add.text(xPos, -90, card.nome, { fontSize: '22px', fill: '#fff', align: 'center', wordWrap: { width: 140 } })
      .setOrigin(0.5);
    const description = this.add.text(xPos, -40, card.descricao, { fontSize: '14px', fill: '#ddd', align: 'center', wordWrap: { width: 140 } })
      .setOrigin(0.5);

    // Adiciona o ícone da carta
    if (card.sprite) {
      const icon = this.add.image(xPos, -110, card.sprite).setScale(0.8).setOrigin(0.5);
      choicesPanel.add(icon);
    }


    choicesPanel.add(bgImage);
    choicesPanel.add(title);
    choicesPanel.add(description);
  });
}

function selecionarCarta(cardName, choicesPanel) {
  choicesPanel.destroy(); // Remove o painel de escolhas

  // Aplica o efeito da carta
  const card = cards[cardName];
  card.efeito(this); // Passa a cena atual para a função de efeito

  // Adiciona a carta selecionada ao contador de cartas ativas
  activeCardCount[cardName] = (activeCardCount[cardName] || 0) + 1;
  this.hud.atualizarHUDCartas(activeCardCount); // Atualiza o HUD das cartas

  this.physics.resume(); // Volta o jogo
  playerStats.canShoot = true; // Permite o jogador atirar
}
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons - Survivor Mode</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000008c7; }
    canvas { display: block; margin: auto; }
    .menu-overlay, .shop-overlay, .pause-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; color: #FFF; }
    .menu-container, .shop-container, .pause-container { background-color: #333; border: 2px solid #555; padding: 20px; border-radius: 8px; text-align: center; width: 80%; max-width: 900px; }
    .menu-title, .shop-title, .pause-title { font-size: 36px; margin-bottom: 20px; color: #00FFFF; }
    .cards-container, .shop-items-container { display: flex; justify-content: space-around; gap: 20px; flex-wrap: wrap; }
    .card, .shop-item { background-color: #222; border: 1px solid #444; border-radius: 8px; padding: 15px; width: 250px; display: flex; flex-direction: column; align-items: center; text-align: left; min-height: 220px; }
    .card:hover { transform: translateY(-5px); box-shadow: 0 5px 20px rgba(0, 255, 255, 0.5); }
    .card-title, .shop-item-name { font-size: 22px; color: #FFD700; }
    .card-button, .shop-item-button, .shop-close-button, .pause-close-button, .pause-tab-button { padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; margin-top: 15px; }
    .card-button { background-color: #008CBA; color: white; }
    .shop-item-button { background-color: #28a745; color: white; }
    .shop-close-button, .pause-close-button { background-color: #dc3545; color: white; }
    .card-rarity { font-size: 12px; font-style: italic; margin: 5px 0 10px 0; }
  </style>
</head>
<body>
<script>
// --- Game Configuration ---
const WORLD_SIZE = 4000; // FIX: Mundo grande
const config = {
  type: Phaser.AUTO,
  width: 1320,
  height: 590,
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: { debug: false, gravity: { y: 0 } }
  },
  scene: { preload, create, update }
};

// --- Centralized Game Balance & Config ---
const GAME_CONFIG = {
    PLAYER: {
        INITIAL_SCALE: 0.08,
        DEFAULT_TINT: 0xFFFFFF,
        DASH_DURATION: 150, DASH_DISTANCE: 300, DASH_COOLDOWN_BASE: 3000,
        ACCELERATION: 2000, DRAG: 0.6,
        BASE_MAGNET_RANGE: 150,
        BASE_PIERCING: 1
    },
    BULLET: { INITIAL_SPEED: 1000, INITIAL_SCALE: 0.01 },
    WEAPONS: {
        1: { fireRate: 1000, damage: 2, speed: 1000, range: 400 },     
    },
    WAVE: {
        INITIAL_ENEMY_COUNT: 5, 
        ENEMY_INCREMENT_PER_WAVE: 5,
        INITIAL_SPAWN_RATE: 1000,
        SPAWN_RATE_DECREASE_PER_WAVE: 80,
        MAX_ENEMIES_ON_SCREEN: 200
    },
    CAMERA_SHAKE: { PLAYER_HIT: { DURATION: 100, INTENSITY: 0.01 } }
};

// --- Global Variables ---
let player, cursors, bullets, enemies, xpGemsGroup;
let hud;
let lastShoot = 0;
let waveNumber = 1;
let enemiesInWave = GAME_CONFIG.WAVE.INITIAL_ENEMY_COUNT;
let enemiesSpawnedThisWave = 0;

// FIX: NOVAS VARIÁVEIS DE CONTROLE DE FIM DE WAVE
let enemiesToKillThisWave = enemiesInWave; 
let enemiesKilledThisWave = 0; 

let enemySpawnRate = GAME_CONFIG.WAVE.INITIAL_SPAWN_RATE;
let currentWeapon = 1;
let gamePaused = false, levelUpMenuOpen = false, shopMenuOpen = false;
let closestEnemy = null;

// --- Player Stats ---
let playerStats = {
  life: 3, maxLife: 3,
  bulletDamage: 2, fireRate: 300, playerSpeed: 300,
  xp: 0, level: 1, xpToNextLevel: 50, 
  currency: 0,
  magnetRange: GAME_CONFIG.PLAYER.BASE_MAGNET_RANGE,
  piercingCount: GAME_CONFIG.PLAYER.BASE_PIERCING,
  dashAvailable: false, dashCooldown: false, doubleBullets: false,
  incomingDamageMultiplier: 1, weaponBulletSpeed: GAME_CONFIG.BULLET.INITIAL_SPEED,
  inventory: []
};

// --- Enemy Definitions ---
const enemyTypes = {
  normal: { texture: 'enemy_robot', baseHealth: 4, speed: 100, scale: 0.06, xpValue: 5 },
  fast: { texture: 'enemy_fast', baseHealth: 3, speed: 200, scale: 0.06, xpValue: 8 },
  tank: { texture: 'enemy_tank', baseHealth: 15, speed: 50, scale: 0.08, xpValue: 15 },
  boss_robot: { texture: 'boss_robot', baseHealth: 500, speed: 200, scale: 0.2, xpValue: 200, boss: true }
};

// --- Item Rarity ---
const itemRarities = {
    common: { color: '#FFFFFF' }, rare: { color: '#00BFFF' }, epic: { color: '#9932CC' }, legendary: { color: '#FFD700' }
};

// --- Card Options ---
const itemOptions = [
  { nome: "Balas de Titânio", descricao: "+20% Dano", rarity: 'common', efeito: () => playerStats.bulletDamage *= 1.2 },
  { nome: "Gatilho Rápido", descricao: "+15% Velocidade de Ataque", rarity: 'common', efeito: () => playerStats.fireRate *= 0.85 },
  { nome: "Motor V8", descricao: "+10% Velocidade de Movimento", rarity: 'common', efeito: () => playerStats.playerSpeed *= 1.1 },
  { nome: "Imã de Sucata", descricao: "+50% Alcance de Coleta", rarity: 'common', efeito: () => playerStats.magnetRange *= 1.5 },
  { nome: "Projétil Perfurante", descricao: "Balas atravessam +1 inimigo", rarity: 'rare', efeito: () => playerStats.piercingCount += 1 },
  { nome: "Pele Reforçada", descricao: "+1 Vida Máxima", rarity: 'rare', efeito: () => { playerStats.maxLife++; playerStats.life++; hud.updateHealthBar(); } },
  { nome: "Tiro Duplo", descricao: "Dispara um segundo projétil", rarity: 'epic', efeito: () => playerStats.doubleBullets = true },
  { nome: "Módulo de Dash", descricao: "Habilita a habilidade de Dash (Espaço)", rarity: 'epic', efeito: () => playerStats.dashAvailable = true },
];

// --- HUD Class ---
class HUD extends Phaser.GameObjects.Container {
  constructor(scene, x, y) {
    super(scene, x, y);
    scene.add.existing(this);
    this.setDepth(1000); 
    this.setScrollFactor(0); 
    this.lifeText = scene.add.text(10, 10, '', { fontSize: '20px', fill: '#FF0000' }).setScrollFactor(0);
    this.levelText = scene.add.text(10, 40, '', { fontSize: '20px', fill: '#FFFF00' }).setScrollFactor(0);
    this.currencyText = scene.add.text(10, 70, '', { fontSize: '20px', fill: '#FFD700' }).setScrollFactor(0);
    this.xpBarBg = scene.add.rectangle(10, 100, 200, 15, 0x555555).setOrigin(0).setScrollFactor(0);
    this.xpBar = scene.add.rectangle(10, 100, 0, 15, 0x00FF00).setOrigin(0).setScrollFactor(0);
    this.waveText = scene.add.text(config.width / 2, 10, '', { fontSize: '24px', fill: '#FFFFFF' }).setOrigin(0.5).setScrollFactor(0);
    this.add([this.lifeText, this.levelText, this.currencyText, this.xpBarBg, this.xpBar, this.waveText]);
    this.updateAll();
  }
  updateAll() {
      this.lifeText.setText(`Vida: ${Math.ceil(playerStats.life)}/${playerStats.maxLife}`);
      this.levelText.setText(`Nível: ${playerStats.level}`);
      this.currencyText.setText(`Sucata: ${playerStats.currency}`);
      // FIX: Mostrar o progresso real da wave (abates/meta)
      this.waveText.setText(`Onda ${waveNumber}: ${enemiesKilledThisWave}/${enemiesToKillThisWave}`); 
      const xpRatio = playerStats.xp / playerStats.xpToNextLevel;
      this.xpBar.width = 200 * xpRatio;
  }
  updateHealthBar() { this.updateAll(); }
  updateXpBar() { this.updateAll(); }
  updateCurrencyDisplay() { this.updateAll(); }
}

// --- Phaser Scene Functions ---
function preload() {
  this.load.image('cardBg', 'assets/card.png');
  this.load.image('player', 'assets/player.png');
  this.load.image('bullet', 'assets/bullet.png');
  this.load.image('enemy_robot', 'assets/enemy_robot.png');
  this.load.image('enemy_fast', 'assets/enemy_fast.png');
  this.load.image('enemy_tank', 'assets/enemy_tank.png');
  this.load.image('boss_robot', 'assets/boss_robot.png');
  this.load.image('ammo', 'assets/ammo.png'); 

  this.load.image('background_tile', 'assets/dungeon_floor.png'); 

  // Fallbacks
  if(!this.textures.exists('player')) this.load.image('player', 'https://labs.phaser.io/assets/sprites/phaser-dude.png');
  if(!this.textures.exists('bullet')) this.load.image('bullet', 'https://labs.phaser.io/assets/sprites/bullets/bullet7.png');
  if(!this.textures.exists('enemy_robot')) this.load.image('enemy_robot', 'https://labs.phaser.io/assets/sprites/space-baddie.png');
  if(!this.textures.exists('ammo')) this.load.image('ammo', 'https://labs.phaser.io/assets/sprites/orb-green.png');
  if(!this.textures.exists('background_tile')) this.load.image('background_tile', 'https://labs.phaser.io/assets/pics/dungeon-floor-fallback.png');
}

function create() {
  this.physics.world.setBounds(0, 0, WORLD_SIZE, WORLD_SIZE);
  this.add.tileSprite(WORLD_SIZE / 2, WORLD_SIZE / 2, WORLD_SIZE, WORLD_SIZE, 'background_tile'); 

  player = this.physics.add.sprite(WORLD_SIZE / 2, WORLD_SIZE / 2, 'player').setScale(GAME_CONFIG.PLAYER.INITIAL_SCALE);
  player.setCollideWorldBounds(true);
  player.setDrag(GAME_CONFIG.PLAYER.DRAG); player.setMaxVelocity(playerStats.playerSpeed);

  this.cameras.main.setBounds(0, 0, WORLD_SIZE, WORLD_SIZE);
  this.cameras.main.startFollow(player, true, 0.09, 0.09); 

  cursors = this.input.keyboard.createCursorKeys();
  this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
  this.keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);
  this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
  this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
  this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);

  bullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 100 });
  enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true, maxSize: GAME_CONFIG.WAVE.MAX_ENEMIES_ON_SCREEN });
  xpGemsGroup = this.physics.add.group({ classType: XPGem, runChildUpdate: true, maxSize: 300 });

  this.physics.add.overlap(bullets, enemies, bulletHitEnemy, null, this);
  this.physics.add.collider(player, enemies, playerHitEnemy, null, this);
  this.physics.add.overlap(player, xpGemsGroup, collectXPGem, null, this);

  hud = new HUD(this, 0, 0); 
  switchWeapon.call(this, 1);

  // Spawner loop
  this.time.addEvent({ delay: enemySpawnRate, callback: spawnEnemy, callbackScope: this, loop: true, id: 'spawner' });
}

function update(time, delta) {
  if (gamePaused || levelUpMenuOpen) return;

  // Movimentação
  player.setAcceleration(0);
  if (cursors.left.isDown || this.keyA.isDown) player.setAccelerationX(-GAME_CONFIG.PLAYER.ACCELERATION);
  else if (cursors.right.isDown || this.keyD.isDown) player.setAccelerationX(GAME_CONFIG.PLAYER.ACCELERATION);
  if (cursors.up.isDown || this.keyW.isDown) player.setAccelerationY(-GAME_CONFIG.PLAYER.ACCELERATION);
  else if (cursors.down.isDown || this.keyS.isDown) player.setAccelerationY(GAME_CONFIG.PLAYER.ACCELERATION);

  // Dash
  if (Phaser.Input.Keyboard.JustDown(this.keySpace) && playerStats.dashAvailable && !playerStats.dashCooldown) {
    performDash(this);
  }
  
  // Auto-Targeting
  closestEnemy = null;
  let minDistance = Infinity;
  const weaponRange = GAME_CONFIG.WEAPONS[currentWeapon].range;

  enemies.children.each(enemy => {
      if (enemy.active) {
          const dist = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
          if (dist < minDistance && dist <= weaponRange) {
              minDistance = dist;
              closestEnemy = enemy;
          }
      }
  });

  if (time > lastShoot && closestEnemy) {
    shootBullet.call(this, closestEnemy);
    lastShoot = time + playerStats.fireRate;
  }
}

// --- Game Logic Functions ---
function shootBullet(targetEnemy) {
  let baseBulletCount = playerStats.doubleBullets ? 2 : 1;
  const angleRad = Phaser.Math.Angle.Between(player.x, player.y, targetEnemy.x, targetEnemy.y);
  for (let i = 0; i < baseBulletCount; i++) {
    let offsetAngle = (baseBulletCount > 1) ? Phaser.Math.DEG_TO_RAD * ((i === 0 ? -5 : 5)) : 0;
    const bullet = bullets.get(player.x, player.y);
    if (bullet) bullet.fire(angleRad + offsetAngle, playerStats.weaponBulletSpeed, playerStats.bulletDamage, playerStats.piercingCount);
  }
}

function switchWeapon(weaponNum) {
  currentWeapon = weaponNum;
  const weaponConfig = GAME_CONFIG.WEAPONS[currentWeapon];
  playerStats.fireRate = weaponConfig.fireRate;
  playerStats.bulletDamage = weaponConfig.damage;
  playerStats.weaponBulletSpeed = weaponConfig.speed;
}

function bulletHitEnemy(bullet, enemy) {
  if (!bullet.active || !enemy.active) return;
  enemy.takeDamage(bullet.damage);
  bullet.piercingHealth--;
  if (bullet.piercingHealth <= 0) bullet.kill();
  if (enemy.health <= 0) handleEnemyDeath.call(this, enemy);
}

function playerHitEnemy(player, enemy) {
    if (!player.active || !enemy.active || player.isInvulnerable) return;
    this.cameras.main.shake(GAME_CONFIG.CAMERA_SHAKE.PLAYER_HIT.DURATION, GAME_CONFIG.CAMERA_SHAKE.PLAYER_HIT.INTENSITY);
    playerStats.life -= 1;
    hud.updateHealthBar();
    player.setTint(0xFF0000);
    player.isInvulnerable = true;
    this.time.delayedCall(500, () => { player.clearTint(); player.isInvulnerable = false; });
    if (playerStats.life <= 0) gameOver.call(this);
}

function handleEnemyDeath(enemy) {
    if (!enemy.active) return;
    dropXPGem(this, enemy.x, enemy.y, enemy.enemyType.xpValue);
    enemy.kill();

    // FIX: CONTAGEM E VERIFICAÇÃO DE FIM DE WAVE
    enemiesKilledThisWave++;
    if (enemiesKilledThisWave >= enemiesToKillThisWave) {
        startNextWave.call(this);
    }
}

function dropXPGem(scene, x, y, xpValue) {
    const gem = xpGemsGroup.get(x, y);
    if (gem) gem.spawn(xpValue);
}

function collectXPGem(player, gem) {
    if(gem.isBeingCollected) return;
    gem.isBeingCollected = true;
    gainXp.call(this, gem.xpValue);
    gem.kill();
}

function gainXp(amount) {
  playerStats.xp += amount;
  hud.updateXpBar();
  if (playerStats.xp >= playerStats.xpToNextLevel) {
    playerStats.level++;
    playerStats.xp -= playerStats.xpToNextLevel;
    playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.2);
    hud.updateAll();
    showLevelUpMenu.call(this);
  }
}

function performDash(scene) {
    playerStats.dashCooldown = true;
    const dashVelocity = scene.physics.velocityFromRotation(player.rotation, GAME_CONFIG.PLAYER.DASH_DISTANCE * 4);
    player.body.setVelocity(dashVelocity.x, dashVelocity.y);
    player.setTint(0x00FF00);
    scene.time.delayedCall(GAME_CONFIG.PLAYER.DASH_DURATION, () => player.clearTint());
    scene.time.delayedCall(GAME_CONFIG.PLAYER.DASH_COOLDOWN_BASE, () => playerStats.dashCooldown = false);
}

function spawnEnemy() {
  if (enemies.countActive() >= GAME_CONFIG.WAVE.MAX_ENEMIES_ON_SCREEN) return;

  if (enemiesSpawnedThisWave >= enemiesInWave) {
      // FIX: O SPAWNER APENAS PARA QUANDO A META DE SPAWN É ATINGIDA, MAS NÃO INICIA A PRÓXIMA WAVE.
      return;
  }
  
  const cam = this.cameras.main; 
  let x, y;
  const padding = 50;
  
  // Lógica de Spawn FORA da visão da câmera
  if (Math.random() < 0.5) { 
      x = (Math.random() < 0.5) ? cam.scrollX - padding : cam.scrollX + cam.width + padding;
      y = Phaser.Math.Between(cam.scrollY, cam.scrollY + cam.height);
  } else { 
      x = Phaser.Math.Between(cam.scrollX, cam.scrollX + cam.width);
      y = (Math.random() < 0.5) ? cam.scrollY - padding : cam.scrollY + cam.height + padding;
  }

  x = Phaser.Math.Clamp(x, 0, WORLD_SIZE);
  y = Phaser.Math.Clamp(y, 0, WORLD_SIZE);

  let enemyTypeKey = 'normal';
  if(waveNumber > 3 && Math.random() > 0.7) enemyTypeKey = 'fast';
  if(waveNumber > 5 && Math.random() > 0.8) enemyTypeKey = 'tank';

  const enemy = enemies.get(x, y);
  if (enemy) {
    enemy.spawn(enemyTypes[enemyTypeKey]);
    enemiesSpawnedThisWave++;
  }
}

function startNextWave() {
  waveNumber++;
  
  // Aumenta o número de inimigos a serem mortos na próxima onda
  enemiesInWave += GAME_CONFIG.WAVE.ENEMY_INCREMENT_PER_WAVE; 
  
  // FIX: Configura a nova meta de abate e reseta o contador
  enemiesToKillThisWave = enemiesInWave; 
  enemiesKilledThisWave = 0; 
  
  let newRate = enemySpawnRate - GAME_CONFIG.WAVE.SPAWN_RATE_DECREASE_PER_WAVE;
  enemySpawnRate = Math.max(200, newRate);
  
  const spawner = this.time.getEvent('spawner');
  if(spawner) spawner.delay = enemySpawnRate;

  // Reseta o contador de spawn para permitir que a nova leva comece a aparecer.
  enemiesSpawnedThisWave = 0; 
  hud.updateAll();
}

// --- Custom Classes (Mantidas) ---
class Bullet extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y) { super(scene, x, y, 'bullet'); }
  fire(angle, speed, damage, piercing) {
      this.setActive(true).setVisible(true).setScale(GAME_CONFIG.BULLET.INITIAL_SCALE);
      this.damage = damage; this.piercingHealth = piercing; this.setRotation(angle);
      this.scene.physics.velocityFromRotation(angle, speed, this.body.velocity);
      this.lifeSpan = 2000;
  }
  kill() { this.setActive(false).setVisible(false); this.body.stop(); }
  preUpdate(time, delta) {
      super.preUpdate(time, delta);
      this.lifeSpan -= delta;
      if (this.lifeSpan <= 0) this.kill();
  }
}

class Enemy extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y) { super(scene, x, y, 'enemy_robot'); }
  spawn(enemyData) {
      this.setActive(true).setVisible(true).setTexture(enemyData.texture).setScale(enemyData.scale);
      this.health = enemyData.baseHealth * (1 + (waveNumber * 0.1));
      this.speed = enemyData.speed; this.enemyType = enemyData; this.setTint(0xffffff);
  }
  takeDamage(amount) { this.health -= amount; this.setTint(0xff0000); this.scene.time.delayedCall(100, ()=> { if(this.active) this.clearTint() }); }
  kill() { this.setActive(false).setVisible(false); this.body.stop(); }
  update(time, delta) {
    if (!this.active || !player.active || gamePaused) return;
    this.scene.physics.moveToObject(this, player, this.speed);
  }
}

class XPGem extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { 
        super(scene, x, y, 'ammo'); 
        this.setScale(0.04); this.setTint(0x00ff00);
    }
    spawn(xpValue) {
        this.setActive(true).setVisible(true);
        this.xpValue = xpValue; this.isBeingCollected = false; this.body.setVelocity(0);
    }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if(!this.active) return;
        
        const dist = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y);
        if (dist < playerStats.magnetRange) {
            this.scene.physics.moveToObject(this, player, 600);
        }
    }
}

// --- Menus HTML (Mantidos) ---
function showLevelUpMenu() {
    if (levelUpMenuOpen) return;
    gamePaused = true; levelUpMenuOpen = true; this.physics.pause();
    
    const overlay = document.createElement('div'); overlay.className = 'menu-overlay';
    const container = document.createElement('div'); container.className = 'menu-container';
    container.innerHTML = '<h2 class="menu-title">Subiu de Nível!</h2>';
    const cardsDiv = document.createElement('div'); cardsDiv.className = 'cards-container';
    
    const choices = Phaser.Utils.Array.Shuffle(itemOptions).slice(0, 3);
    
    choices.forEach(item => {
        const card = document.createElement('div'); card.className = 'card';
        card.innerHTML = `<h3 class="card-title">${item.nome}</h3><p class="card-rarity" style="color:${itemRarities[item.rarity].color}">${item.rarity}</p><p>${item.descricao}</p><button class="card-button">Selecionar</button>`;
        card.querySelector('button').onclick = () => {
            item.efeito(this);
            document.body.removeChild(overlay);
            levelUpMenuOpen = false; gamePaused = false; this.physics.resume();
        };
        cardsDiv.appendChild(card);
    });
    container.appendChild(cardsDiv); overlay.appendChild(container); document.body.appendChild(overlay);
}

function gameOver() {
  this.physics.pause(); gamePaused = true;
  const overlay = document.createElement('div'); overlay.className = 'menu-overlay';
  overlay.innerHTML = '<div class="menu-container"><h2 class="menu-title" style="color:red">VOCÊ MORREU</h2><button class="card-button" onclick="location.reload()">Tentar Novamente</button></div>';
  document.body.appendChild(overlay);
}

new Phaser.Game(config);
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons - Wave Mode</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000008c7; font-family: Arial, sans-serif; }
    canvas { display: block; margin: auto; }
    
    /* UI Styles */
    .menu-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: flex; justify-content: center; align-items: center; z-index: 1000; color: #FFF; }
    .menu-container { background-color: #222; border: 2px solid #444; padding: 20px; border-radius: 8px; text-align: center; width: 90%; max-width: 800px; box-shadow: 0 0 20px #000; }
    .menu-title { font-size: 32px; margin-bottom: 20px; color: #00FFFF; text-transform: uppercase; }
    .cards-container { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; }
    .card { background-color: #1a1a1a; border: 1px solid #444; border-radius: 6px; padding: 15px; width: 200px; display: flex; flex-direction: column; align-items: center; text-align: center; transition: transform 0.1s; cursor: pointer; }
    .card:hover { transform: scale(1.05); border-color: #fff; }
    .card-title { font-size: 18px; color: #FFD700; margin-bottom: 10px; font-weight: bold; }
    .card-button { background-color: #008CBA; color: white; padding: 8px 16px; border: none; border-radius: 4px; font-weight: bold; pointer-events: none; }
  </style>
</head>
<body>
<script>

const GAME_CONFIG = {
    PLAYER: {
        SPEED: 250,
        MAX_HP: 3,
        MAGNET: 120,
        DASH: { DIST: 250, CD: 3000 }
    },
    LIMITS: {
        MAX_ENEMIES_ON_SCREEN: 50, // Limite visual para não travar
        MAX_GEMS: 60
    },
    WAVE: {
        START_COUNT: 10, // Inimigos na onda 1
        INC_PER_WAVE: 5,  // Aumento por onda
        SPAWN_DELAY: 800  // Velocidade que eles aparecem
    }
};

// Globais
let player, cursors, bullets, enemies, xpGems, hud;
let isPaused = false;

let gameState = {
    wave: 1,
    enemiesToSpawn: 0, // Quantos faltam nascer nesta onda
    enemiesAlive: 0    // Quantos estão na tela agora
};

let playerStats = { 
    hp: 3, maxHp: 3, damage: 2, fireRate: 800, speed: GAME_CONFIG.PLAYER.SPEED, 
    xp: 0, level: 1, xpToNext: 20, currency: 0, magnet: GAME_CONFIG.PLAYER.MAGNET,
    piercing: 1, doubleShot: false, dashUnlocked: false, dashCool: false 
};

let lastShot = 0;

class MainScene extends Phaser.Scene {
    constructor() { super({ key: 'MainScene' }); }

    preload() {
        this.load.image('player', 'https://labs.phaser.io/assets/sprites/phaser-dude.png');
        this.load.image('bullet', 'https://labs.phaser.io/assets/sprites/bullets/bullet7.png');
        this.load.image('enemy', 'https://labs.phaser.io/assets/sprites/space-baddie.png'); 
        this.load.image('gem', 'https://labs.phaser.io/assets/sprites/orb-green.png');
        this.load.image('bg', 'https://labs.phaser.io/assets/skies/deep-space.jpg');
    }

    create() {
        this.add.tileSprite(0, 0, this.scale.width, this.scale.height, 'bg').setOrigin(0).setScrollFactor(0).setAlpha(0.5);

        player = this.physics.add.sprite(this.scale.width/2, this.scale.height/2, 'player').setScale(1.2);
        player.setCollideWorldBounds(true);
        
        // Grupos
        bullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 50 });
        enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true, maxSize: GAME_CONFIG.LIMITS.MAX_ENEMIES_ON_SCREEN });
        xpGems = this.physics.add.group({ classType: Gem, runChildUpdate: true, maxSize: GAME_CONFIG.LIMITS.MAX_GEMS });

        // Colisões
        this.physics.add.overlap(bullets, enemies, this.hitEnemy, null, this);
        this.physics.add.collider(player, enemies, this.hitPlayer, null, this);
        this.physics.add.overlap(player, xpGems, this.collectGem, null, this);

        cursors = this.input.keyboard.createCursorKeys();
        this.input.keyboard.on('keydown-SPACE', () => this.dash());

        // Inicializa HUD e Progresso
        loadProgress();
        hud = new HUD(this);
        
        // Inicia a primeira onda
        this.startWave(1);

        // Loop de Spawn
        this.time.addEvent({ delay: GAME_CONFIG.WAVE.SPAWN_DELAY, callback: this.trySpawnEnemy, callbackScope: this, loop: true });
    }

    update(time, delta) {
        if (isPaused) return;

        // Movimento
        player.setVelocity(0);
        const spd = playerStats.speed;
        if (cursors.left.isDown) player.setVelocityX(-spd);
        else if (cursors.right.isDown) player.setVelocityX(spd);
        if (cursors.up.isDown) player.setVelocityY(-spd);
        else if (cursors.down.isDown) player.setVelocityY(spd);

        // Auto-Tiro
        if (time > lastShot) {
            let closest = null;
            let minDist = 450;
            enemies.children.each(e => {
                if (e.active) {
                    const d = Phaser.Math.Distance.Between(player.x, player.y, e.x, e.y);
                    if (d < minDist) { minDist = d; closest = e; }
                }
            });

            if (closest) {
                this.shoot(closest);
                lastShot = time + playerStats.fireRate;
            }
        }
    }

    // --- SISTEMA DE ONDAS ---
    startWave(waveNum) {
        gameState.wave = waveNum;
        // Calcula quantos inimigos teremos nesta onda
        const totalEnemies = GAME_CONFIG.WAVE.START_COUNT + ((waveNum - 1) * GAME_CONFIG.WAVE.INC_PER_WAVE);
        
        gameState.enemiesToSpawn = totalEnemies;
        
        hud.showMsg(`ONDA ${waveNum} INICIADA!`, '#00FFFF');
        hud.updateStats();
    }

    trySpawnEnemy() {
        if (isPaused) return;
        
        // 1. Verifica se ainda tem inimigos para nascer na "reserva" da onda
        if (gameState.enemiesToSpawn <= 0) return;

        // 2. Verifica se a tela já está cheia (Anti-Lag)
        if (enemies.countActive() >= GAME_CONFIG.LIMITS.MAX_ENEMIES_ON_SCREEN) return;

        // Spawn
        this.spawnOneEnemy();
    }

    spawnOneEnemy() {
        const edge = Math.random() < 0.5 ? 'x' : 'y';
        let x, y;
        if (edge === 'x') {
            x = Math.random() < 0.5 ? -50 : this.scale.width + 50;
            y = Math.random() * this.scale.height;
        } else {
            x = Math.random() * this.scale.width;
            y = Math.random() < 0.5 ? -50 : this.scale.height + 50;
        }

        const e = enemies.get();
        if (e) {
            e.spawn(x, y, gameState.wave);
            gameState.enemiesToSpawn--; // Remove da reserva
            hud.updateStats(); // Atualiza contador na tela
        }
    }

    checkWaveEnd() {
        // Se não falta nascer ninguém E não tem ninguém vivo na tela
        if (gameState.enemiesToSpawn <= 0 && enemies.countActive() === 0) {
            hud.showMsg("ONDA CONCLUÍDA!", "#00FF00");
            
            // Espera 2 segundos e inicia a próxima
            this.time.delayedCall(2000, () => {
                this.startWave(gameState.wave + 1);
            });
        }
    }

    shoot(target) {
        const angle = Phaser.Math.Angle.Between(player.x, player.y, target.x, target.y);
        const shots = playerStats.doubleShot ? 2 : 1;
        for(let i=0; i<shots; i++) {
            const b = bullets.get();
            if (b) {
                const spread = (i === 0) ? 0 : 0.2;
                b.fire(player.x, player.y, angle + spread);
            }
        }
    }

    hitEnemy(bullet, enemy) {
        if (!bullet.active || !enemy.active) return;
        enemy.hp -= bullet.damage;
        enemy.setTint(0xff0000);
        this.time.delayedCall(50, () => { if(enemy.active) enemy.clearTint(); });

        bullet.pierce--;
        if (bullet.pierce <= 0) bullet.kill();

        if (enemy.hp <= 0) {
            this.dropGem(enemy.x, enemy.y, enemy.xpValue);
            enemy.kill();
            
            // VERIFICA SE A ONDA ACABOU AO MATAR UM INIMIGO
            this.checkWaveEnd();
            hud.updateStats();
        }
    }

    dropGem(x, y, val) {
        if (xpGems.countActive() >= GAME_CONFIG.LIMITS.MAX_GEMS) {
            const oldGem = xpGems.getFirstAlive();
            if (oldGem) oldGem.kill();
        }
        const g = xpGems.get();
        if (g) g.spawn(x, y, val);
    }

    collectGem(player, gem) {
        if (gem.collected) return;
        gem.collected = true;
        gem.kill();
        playerStats.xp += gem.val;
        if (playerStats.xp >= playerStats.xpToNext) {
            playerStats.level++;
            playerStats.xp = 0;
            playerStats.xpToNext = Math.floor(playerStats.xpToNext * 1.3);
            hud.updateStats();
            showLevelUp(this);
        }
        hud.updateStats();
    }

    hitPlayer(player, enemy) {
        if (player.isInvulnerable) return;
        playerStats.hp--;
        hud.updateStats();
        player.setTint(0xff0000);
        player.isInvulnerable = true;
        
        if (playerStats.hp <= 0) {
            this.physics.pause();
            isPaused = true;
            saveProgress(); // Salva dinheiro ao morrer
            hud.showMsg("GAME OVER - F5 para Reiniciar", "#FF0000", 99999);
        } else {
            this.time.delayedCall(1000, () => {
                player.clearTint();
                player.isInvulnerable = false;
            });
        }
    }

    dash() {
        if (!playerStats.dashUnlocked || playerStats.dashCool) return;
        playerStats.dashCool = true;
        const angle = (player.body.velocity.x === 0 && player.body.velocity.y === 0) ? 0 : player.body.velocity.angle();
        const vel = this.physics.velocityFromRotation(angle, GAME_CONFIG.PLAYER.DASH.DIST * 4);
        player.body.velocity.x = vel.x;
        player.body.velocity.y = vel.y;
        player.setAlpha(0.5);
        this.time.delayedCall(200, () => player.setAlpha(1));
        this.time.delayedCall(3000, () => playerStats.dashCool = false);
    }
}

// --- CLASSES OTIMIZADAS ---
class Bullet extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { super(scene, x, y, 'bullet'); }
    fire(x, y, angle) {
        this.body.reset(x, y);
        this.setActive(true).setVisible(true);
        this.setRotation(angle);
        this.scene.physics.velocityFromRotation(angle, 1000, this.body.velocity);
        this.damage = playerStats.damage;
        this.pierce = playerStats.piercing;
        this.lifespan = 1000;
    }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        this.lifespan -= delta;
        if (this.lifespan <= 0) this.kill();
    }
}

class Enemy extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { super(scene, x, y, 'enemy'); }
    spawn(x, y, waveDifficulty) {
        this.body.reset(x, y);
        this.setActive(true).setVisible(true);
        // Vida aumenta conforme a onda
        this.hp = 3 + (waveDifficulty * 1.5);
        this.xpValue = 10 + waveDifficulty;
        this.setTint(0xffffff);
    }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.active) this.scene.physics.moveToObject(this, player, 120);
    }
}

class Gem extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { super(scene, x, y, 'gem'); this.setScale(0.5); }
    spawn(x, y, val) {
        this.body.reset(x, y);
        this.setActive(true).setVisible(true);
        this.val = val;
        this.collected = false;
    }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.active) {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y);
            if (dist < playerStats.magnet) this.scene.physics.moveToObject(this, player, 400);
        }
    }
}

class HUD {
    constructor(scene) {
        this.scene = scene;
        this.statsText = scene.add.text(20, 20, "", { fontSize: '18px', color: '#fff', stroke: '#000', strokeThickness: 2 }).setScrollFactor(0).setDepth(100);
        this.waveInfo = scene.add.text(scene.scale.width/2, 30, "", { fontSize: '24px', fontStyle:'bold', color:'#FFD700', stroke: '#000', strokeThickness: 3 }).setOrigin(0.5).setScrollFactor(0).setDepth(100);
        this.msgText = scene.add.text(scene.scale.width/2, scene.scale.height/2 - 100, "", { fontSize: '40px', fontStyle:'bold', stroke:'#000', strokeThickness:6 }).setOrigin(0.5).setScrollFactor(0).setDepth(200).setAlpha(0);
        this.updateStats();
    }
    updateStats() {
        // Mostra quantos faltam para acabar a onda (Reserva + Vivos na tela)
        const remaining = gameState.enemiesToSpawn + enemies.countActive();
        this.waveInfo.setText(`ONDA ${gameState.wave} - RESTAM: ${remaining}`);
        this.statsText.setText(`HP: ${playerStats.hp}/${playerStats.maxHp}\nLVL: ${playerStats.level}\nXP: ${playerStats.xp}/${playerStats.xpToNext}\n$: ${playerStats.currency}`);
    }
    showMsg(text, color, duration = 2000) {
        this.msgText.setText(text).setColor(color).setAlpha(1);
        this.scene.tweens.add({ targets: this.msgText, alpha: 0, duration: duration, ease: 'Power2' });
    }
}

// --- PERSISTÊNCIA ---
function saveProgress() {
    const data = { totalCurrency: playerStats.currency };
    localStorage.setItem('WarAutomatonsSave', JSON.stringify(data));
}
function loadProgress() {
    const data = localStorage.getItem('WarAutomatonsSave');
    if (data) playerStats.currency = JSON.parse(data).totalCurrency || 0;
}

function showLevelUp(scene) {
    isPaused = true; scene.physics.pause();
    const overlay = document.createElement('div'); overlay.className = 'menu-overlay';
    const box = document.createElement('div'); box.className = 'menu-container';
    box.innerHTML = '<h2 class="menu-title">SUBIU DE NÍVEL!</h2><div class="cards-container"></div>';
    
    const upgrades = [
        { n: "Dano +20%", f: () => playerStats.damage *= 1.2 },
        { n: "Tiro Rápido +15%", f: () => playerStats.fireRate *= 0.85 },
        { n: "Velocidade +10%", f: () => playerStats.speed += 20 },
        { n: "Imã +50%", f: () => playerStats.magnet += 50 },
        { n: "Tiro Duplo", f: () => playerStats.doubleShot = true },
        { n: "Dash", f: () => playerStats.dashUnlocked = true },
        { n: "Cura Total", f: () => { playerStats.hp = playerStats.maxHp; hud.updateStats(); } }
    ];
    
    const container = box.querySelector('.cards-container');
    Phaser.Utils.Array.Shuffle(upgrades).slice(0, 3).forEach(up => {
        const card = document.createElement('div'); card.className = 'card';
        card.innerHTML = `<div class="card-title">${up.n}</div><button class="card-button">ESCOLHER</button>`;
        card.onclick = () => {
            up.f();
            document.body.removeChild(overlay);
            isPaused = false; scene.physics.resume();
        };
        container.appendChild(card);
    });
    overlay.appendChild(box); document.body.appendChild(overlay);
}

// Inicialização
const game = new Phaser.Game({
    type: Phaser.AUTO, width: window.innerWidth, height: window.innerHeight,
    backgroundColor: '#000', parent: document.body,
    physics: { default: 'arcade', arcade: { debug: false } },
    scene: [MainScene]
});

window.addEventListener('resize', () => game.scale.resize(window.innerWidth, window.innerHeight));
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons - Survivor Mode (Otimizado)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000008c7; font-family: Arial, sans-serif; }
    canvas { display: block; margin: auto; }
    
    /* Estilos de UI */
    .menu-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); display: flex; justify-content: center; align-items: center; z-index: 1000; color: #FFF; }
    .menu-container { background-color: #222; border: 2px solid #444; padding: 20px; border-radius: 8px; text-align: center; width: 90%; max-width: 800px; box-shadow: 0 0 20px #000; }
    .menu-title { font-size: 32px; margin-bottom: 20px; color: #00FFFF; text-transform: uppercase; }
    
    /* Cards */
    .cards-container { display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; }
    .card { background-color: #1a1a1a; border: 1px solid #444; border-radius: 6px; padding: 15px; width: 200px; display: flex; flex-direction: column; align-items: center; text-align: center; transition: transform 0.1s; }
    .card:hover { transform: scale(1.05); border-color: #fff; }
    .card-title { font-size: 18px; color: #FFD700; margin-bottom: 10px; font-weight: bold; }
    .card-desc { font-size: 13px; color: #ccc; margin-bottom: 15px; flex-grow: 1; }
    .card-button { background-color: #008CBA; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; }
    .card-button:hover { background-color: #005f7f; }
    .rarity { font-size: 11px; font-style: italic; margin-bottom: 5px; }
  </style>
</head>
<body>
<script>

// --- CONFIGURAÇÃO BALANCEADA (ANTI-LAG) ---
const GAME_CONFIG = {
    PLAYER: {
        SPEED: 250, // Velocidade ajustada para jogabilidade fluida
        MAX_HP: 3,
        MAGNET: 120, // Alcance do imã
        DASH: { DIST: 250, CD: 3000, DUR: 200 }
    },
    LIMITS: {
        MAX_ENEMIES: 50, // TRAVA O JOGO EM 50 INIMIGOS (Evita Lag)
        MAX_GEMS: 60     // TRAVA O JOGO EM 60 GEMAS (Evita Lag Extremo)
    },
    WAVE: {
        SPAWN_RATE: 1000 // 1 segundo entre spawns (diminui com o tempo)
    }
};

// --- Variáveis Globais ---
let player, cursors, bullets, enemies, xpGems, hud;
let playerStats = { 
    hp: 3, maxHp: 3, damage: 2, fireRate: 800, speed: GAME_CONFIG.PLAYER.SPEED, 
    xp: 0, level: 1, xpToNext: 20, currency: 0, magnet: GAME_CONFIG.PLAYER.MAGNET,
    piercing: 1, doubleShot: false, dashUnlocked: false, dashCool: false 
};

let gameTimeSeconds = 0; // Cronômetro
let gameTimerEvent;
let lastShot = 0;
let isPaused = false;

// --- CENA PRINCIPAL ---
class MainScene extends Phaser.Scene {
    constructor() { super({ key: 'MainScene' }); }

    preload() {
        // Usando assets online para garantir que funcione
        this.load.image('player', 'https://labs.phaser.io/assets/sprites/phaser-dude.png');
        this.load.image('bullet', 'https://labs.phaser.io/assets/sprites/bullets/bullet7.png');
        this.load.image('enemy', 'https://labs.phaser.io/assets/sprites/space-baddie.png'); 
        this.load.image('gem', 'https://labs.phaser.io/assets/sprites/orb-green.png');
        this.load.image('bg', 'https://labs.phaser.io/assets/skies/deep-space.jpg');
    }

    create() {
        // Fundo
        this.add.tileSprite(0, 0, this.scale.width, this.scale.height, 'bg').setOrigin(0).setScrollFactor(0).setAlpha(0.5);

        // Player
        player = this.physics.add.sprite(this.scale.width/2, this.scale.height/2, 'player').setScale(1.2);
        player.setCollideWorldBounds(true);
        
        // Grupos (Pooling)
        bullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 50 });
        enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true, maxSize: GAME_CONFIG.LIMITS.MAX_ENEMIES });
        xpGems = this.physics.add.group({ classType: Gem, runChildUpdate: true, maxSize: GAME_CONFIG.LIMITS.MAX_GEMS });

        // Colisões
        this.physics.add.overlap(bullets, enemies, this.hitEnemy, null, this);
        this.physics.add.collider(player, enemies, this.hitPlayer, null, this);
        this.physics.add.overlap(player, xpGems, this.collectGem, null, this);

        // Inputs
        cursors = this.input.keyboard.createCursorKeys();
        this.input.keyboard.on('keydown-SPACE', () => this.dash());

        // HUD
        hud = new HUD(this);

        // CRONÔMETRO (Avança 1 segundo a cada 1000ms)
        gameTimeSeconds = 0;
        gameTimerEvent = this.time.addEvent({ delay: 1000, callback: this.tickTimer, callbackScope: this, loop: true });

        // Spawner de Inimigos
        this.spawner = this.time.addEvent({ delay: 1000, callback: this.spawnEnemy, callbackScope: this, loop: true });
    }

    update(time, delta) {
        if (isPaused) return;

        // Movimento
        player.setVelocity(0);
        const spd = playerStats.speed;
        if (cursors.left.isDown) player.setVelocityX(-spd);
        else if (cursors.right.isDown) player.setVelocityX(spd);
        if (cursors.up.isDown) player.setVelocityY(-spd);
        else if (cursors.down.isDown) player.setVelocityY(spd);

        // Auto-Fire (Mira no mais próximo)
        if (time > lastShot) {
            let closest = null;
            let minDist = 400; // Alcance da arma
            enemies.children.each(e => {
                if (e.active) {
                    const d = Phaser.Math.Distance.Between(player.x, player.y, e.x, e.y);
                    if (d < minDist) { minDist = d; closest = e; }
                }
            });

            if (closest) {
                this.shoot(closest);
                lastShot = time + playerStats.fireRate;
            }
        }
    }

    // --- Lógica do Timer e Dificuldade ---
    tickTimer() {
        if (isPaused) return;
        gameTimeSeconds++;
        hud.updateTimer(gameTimeSeconds);

        // Aumenta dificuldade a cada 30 segundos
        if (gameTimeSeconds % 30 === 0) {
            // Diminui tempo de spawn (mais inimigos)
            if (this.spawner.delay > 200) {
                this.spawner.delay -= 100; 
                hud.showMsg("A ONDA CRESCEU!", "#FF0000");
            }
        }
    }

    spawnEnemy() {
        if (isPaused) return;
        // SE JÁ TEM 50 INIMIGOS, NÃO SPAWNA MAIS (ANTI-LAG)
        if (enemies.countActive() >= GAME_CONFIG.LIMITS.MAX_ENEMIES) return;

        // Spawn nas bordas
        const edge = Math.random() < 0.5 ? 'x' : 'y';
        let x, y;
        if (edge === 'x') {
            x = Math.random() < 0.5 ? -50 : this.scale.width + 50;
            y = Math.random() * this.scale.height;
        } else {
            x = Math.random() * this.scale.width;
            y = Math.random() < 0.5 ? -50 : this.scale.height + 50;
        }

        const e = enemies.get();
        if (e) e.spawn(x, y, gameTimeSeconds);
    }

    shoot(target) {
        const angle = Phaser.Math.Angle.Between(player.x, player.y, target.x, target.y);
        const shots = playerStats.doubleShot ? 2 : 1;
        
        for(let i=0; i<shots; i++) {
            const b = bullets.get();
            if (b) {
                const spread = (i === 0) ? 0 : 0.2;
                b.fire(player.x, player.y, angle + spread);
            }
        }
    }

    hitEnemy(bullet, enemy) {
        if (!bullet.active || !enemy.active) return;
        enemy.hp -= bullet.damage;
        
        // Feedback visual simples
        enemy.setTint(0xff0000);
        this.time.delayedCall(50, () => { if(enemy.active) enemy.clearTint(); });

        bullet.pierce--;
        if (bullet.pierce <= 0) bullet.kill();

        if (enemy.hp <= 0) {
            this.dropGem(enemy.x, enemy.y, enemy.xpValue);
            enemy.kill();
        }
    }

    dropGem(x, y, val) {
        // SE JÁ TEM 60 GEMAS, RECICLA A MAIS VELHA (ANTI-LAG)
        if (xpGems.countActive() >= GAME_CONFIG.LIMITS.MAX_GEMS) {
            const oldGem = xpGems.getFirstAlive();
            if (oldGem) oldGem.kill();
        }
        const g = xpGems.get();
        if (g) g.spawn(x, y, val);
    }

    collectGem(player, gem) {
        if (gem.collected) return;
        gem.collected = true;
        gem.kill();
        playerStats.xp += gem.val;
        if (playerStats.xp >= playerStats.xpToNext) {
            playerStats.level++;
            playerStats.xp = 0;
            playerStats.xpToNext = Math.floor(playerStats.xpToNext * 1.3);
            hud.updateStats();
            showLevelUp(this);
        }
        hud.updateStats();
    }

    hitPlayer(player, enemy) {
        if (player.isInvulnerable) return;
        playerStats.hp--;
        hud.updateStats();
        player.setTint(0xff0000);
        player.isInvulnerable = true;
        
        if (playerStats.hp <= 0) {
            this.physics.pause();
            isPaused = true;
            hud.showMsg("GAME OVER - F5 para Reiniciar", "#FF0000", 99999);
        } else {
            this.time.delayedCall(1000, () => {
                player.clearTint();
                player.isInvulnerable = false;
            });
        }
    }

    dash() {
        if (!playerStats.dashUnlocked || playerStats.dashCool) return;
        playerStats.dashCool = true;
        const vel = this.physics.velocityFromRotation(0, GAME_CONFIG.PLAYER.DASH.DIST * 4); // Simplificado
        // Dash simples na direção do mouse ou movimento seria melhor, mas para simplificar:
        if (player.body.velocity.x !== 0 || player.body.velocity.y !== 0) {
             player.body.velocity.normalize().scale(800);
        }
        player.setAlpha(0.5);
        this.time.delayedCall(200, () => player.setAlpha(1));
        this.time.delayedCall(3000, () => playerStats.dashCool = false);
    }
}

// --- OBJETOS OTIMIZADOS (POOLING) ---
class Bullet extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { super(scene, x, y, 'bullet'); }
    fire(x, y, angle) {
        this.body.reset(x, y);
        this.setActive(true).setVisible(true);
        this.setRotation(angle);
        this.scene.physics.velocityFromRotation(angle, 1000, this.body.velocity);
        this.damage = playerStats.damage;
        this.pierce = playerStats.piercing;
        this.lifespan = 1000;
    }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        this.lifespan -= delta;
        if (this.lifespan <= 0) this.kill();
    }
}

class Enemy extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { super(scene, x, y, 'enemy'); }
    spawn(x, y, difficulty) {
        this.body.reset(x, y);
        this.setActive(true).setVisible(true);
        // Dificuldade baseada no tempo
        const hpMult = 1 + (difficulty / 60); 
        this.hp = 3 * hpMult;
        this.xpValue = 10;
        this.setTint(0xffffff);
    }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.active) this.scene.physics.moveToObject(this, player, 100 + (gameTimeSeconds/2));
    }
}

class Gem extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { super(scene, x, y, 'gem'); this.setScale(0.5); }
    spawn(x, y, val) {
        this.body.reset(x, y);
        this.setActive(true).setVisible(true);
        this.val = val;
        this.collected = false;
    }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.active) {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y);
            if (dist < playerStats.magnet) this.scene.physics.moveToObject(this, player, 400);
        }
    }
}

// --- HUD E UI ---
class HUD {
    constructor(scene) {
        this.scene = scene;
        this.timerText = scene.add.text(scene.scale.width/2, 30, "00:00", { fontSize: '32px', fontStyle: 'bold', color: '#fff', stroke: '#000', strokeThickness: 4 }).setOrigin(0.5).setScrollFactor(0).setDepth(100);
        this.statsText = scene.add.text(20, 20, "", { fontSize: '18px', color: '#fff', stroke: '#000', strokeThickness: 2 }).setScrollFactor(0).setDepth(100);
        this.msgText = scene.add.text(scene.scale.width/2, scene.scale.height/2 - 100, "", { fontSize: '40px', fontStyle:'bold', stroke:'#000', strokeThickness:6 }).setOrigin(0.5).setScrollFactor(0).setDepth(200).setAlpha(0);
        this.updateStats();
    }
    updateTimer(seconds) {
        const m = Math.floor(seconds / 60).toString().padStart(2, '0');
        const s = (seconds % 60).toString().padStart(2, '0');
        this.timerText.setText(`${m}:${s}`);
    }
    updateStats() {
        this.statsText.setText(`HP: ${playerStats.hp}/${playerStats.maxHp}\nLVL: ${playerStats.level}\nXP: ${playerStats.xp}/${playerStats.xpToNext}`);
    }
    showMsg(text, color, duration = 2000) {
        this.msgText.setText(text).setColor(color).setAlpha(1);
        this.scene.tweens.add({ targets: this.msgText, alpha: 0, duration: duration, ease: 'Power2' });
    }
}

// --- MENU DE LEVEL UP ---
function showLevelUp(scene) {
    isPaused = true; scene.physics.pause();
    const overlay = document.createElement('div'); overlay.className = 'menu-overlay';
    const box = document.createElement('div'); box.className = 'menu-container';
    box.innerHTML = '<h2 class="menu-title">SUBIU DE NÍVEL!</h2><div class="cards-container"></div>';
    
    const upgrades = [
        { n: "Dano +20%", f: () => playerStats.damage *= 1.2 },
        { n: "Tiro Rápido +15%", f: () => playerStats.fireRate *= 0.85 },
        { n: "Velocidade +10%", f: () => playerStats.speed += 20 },
        { n: "Imã +50%", f: () => playerStats.magnet += 50 },
        { n: "Tiro Duplo", f: () => playerStats.doubleShot = true },
        { n: "Dash", f: () => playerStats.dashUnlocked = true },
        { n: "Cura Total", f: () => { playerStats.hp = playerStats.maxHp; hud.updateStats(); } }
    ];
    
    const container = box.querySelector('.cards-container');
    Phaser.Utils.Array.Shuffle(upgrades).slice(0, 3).forEach(up => {
        const card = document.createElement('div'); card.className = 'card';
        card.innerHTML = `<div class="card-title">${up.n}</div><button class="card-button">ESCOLHER</button>`;
        card.onclick = () => {
            up.f();
            document.body.removeChild(overlay);
            isPaused = false; scene.physics.resume();
        };
        container.appendChild(card);
    });
    
    overlay.appendChild(box); document.body.appendChild(overlay);
}

// START
const game = new Phaser.Game({
    type: Phaser.AUTO, width: window.innerWidth, height: window.innerHeight,
    backgroundColor: '#000', parent: document.body,
    physics: { default: 'arcade', arcade: { debug: false } },
    scene: [MainScene]
});

window.addEventListener('resize', () => game.scale.resize(window.innerWidth, window.innerHeight));
</script>
</body>
</html>

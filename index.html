<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons V.1.2.8 - Multi-Enemy Update + Classes + Weapon Levels</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0a0000ce;
    }
    canvas {
      display: block;
      margin: auto;
    }
  </style>

</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 1300,
  height: 580,
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: { debug: false }
  },
  scene: {
    preload,
    create,
    update
  }
};

let waveText;
let hudGroup;
let armaNomeText;
let armaImagem;
let player, cursors;
let bullets, enemies, enemyBullets, armas;
let lastShoot = 0;
let showingCards = false;
let cardsHUDGroup; // Group for HUD cards
let choiceCardsGroup; // Group for choice cards
let playerStatsPanel; // Renamed for clarity
let playerEffectsPanel; // New: to display active effects
let game;
let gameRestarting = false; // Flag to prevent multiple restarts

// --- Game Stats & Data ---
let playerStats = {
  level: 1,
  xp: 0,
  xpToNextLevel: 100,
  life: 100,
  maxLife: 100,
  speed: 200,
  fireRate: 500, // ms between shots
  damage: 10,
  critChance: 0.1,
  critDamage: 1.5,
  bulletSpeed: 500,
  playerClass: 'Soldado', // Default class
  currentWeapon: 'pistol', // Default weapon
  numBullets: 1, // For multi-shot
  bulletSpread: 0, // For shotgun-like effects
  dashAvailable: false, // Flag for Dash card effect
  spikeAuraActive: false, // Flag for Spike Aura card effect
  // ... add other effect flags as needed
};

// Player Class Definitions
const classes = {
  Soldado: {
    baseLife: 100,
    baseSpeed: 200,
    baseDamage: 10,
    baseFireRate: 500,
  },
  Atirador: {
    baseLife: 80,
    baseSpeed: 220,
    baseDamage: 12,
    baseFireRate: 400,
  },
  Tanque: {
    baseLife: 150,
    baseSpeed: 150,
    baseDamage: 8,
    baseFireRate: 600,
  },
};

// Weapon Definitions
const tiposDeArmas = {
  pistol: {
    name: 'Pistola',
    damageMultiplier: 1,
    fireRateMultiplier: 1,
    bulletSpeedMultiplier: 1,
    numBullets: 1,
    spread: 0,
    image: 'pistol',
    level: 1,
    maxLevel: 5,
    xp: 0,
    xpToNextLevel: 50,
    upgrade: (weapon) => {
      weapon.level++;
      weapon.damageMultiplier += 0.2;
      weapon.fireRateMultiplier -= 0.05; // Faster fire rate
      weapon.bulletSpeedMultiplier += 0.1;
      weapon.xpToNextLevel = Math.floor(weapon.xpToNextLevel * 1.5);
    }
  },
  shotgun: {
    name: 'Escopeta',
    damageMultiplier: 0.8,
    fireRateMultiplier: 1.5,
    bulletSpeedMultiplier: 0.8,
    numBullets: 3,
    spread: 0.2, // radians
    image: 'shotgun',
    level: 1,
    maxLevel: 5,
    xp: 0,
    xpToNextLevel: 70,
    upgrade: (weapon) => {
      weapon.level++;
      weapon.damageMultiplier += 0.15;
      weapon.fireRateMultiplier -= 0.1;
      weapon.numBullets += 1;
      weapon.xpToNextLevel = Math.floor(weapon.xpToNextLevel * 1.6);
    }
  },
  rifle: {
    name: 'Rifle',
    damageMultiplier: 1.2,
    fireRateMultiplier: 0.8,
    bulletSpeedMultiplier: 1.2,
    numBullets: 1,
    spread: 0,
    image: 'rifle',
    level: 1,
    maxLevel: 5,
    xp: 0,
    xpToNextLevel: 60,
    upgrade: (weapon) => {
      weapon.level++;
      weapon.damageMultiplier += 0.25;
      weapon.fireRateMultiplier -= 0.08;
      weapon.bulletSpeedMultiplier += 0.15;
      weapon.xpToNextLevel = Math.floor(weapon.xpToNextLevel * 1.55);
    }
  }
  // Add more weapons as needed
};

// Enemy Waves Configuration
const waves = [
  { wave: 1, enemyCount: 5, enemySpeed: 50, enemyLife: 20, spawnDelay: 1000 },
  { wave: 2, enemyCount: 8, enemySpeed: 60, enemyLife: 25, spawnDelay: 900 },
  { wave: 3, enemyCount: 10, enemySpeed: 70, enemyLife: 30, spawnDelay: 800 },
  { wave: 4, enemyCount: 12, enemySpeed: 80, enemyLife: 35, spawnDelay: 700 },
  { wave: 5, enemyCount: 15, enemySpeed: 90, enemyLife: 40, spawnDelay: 600 },
  { wave: 6, enemyCount: 18, enemySpeed: 100, enemyLife: 45, spawnDelay: 550 },
  { wave: 7, enemyCount: 20, enemySpeed: 110, enemyLife: 50, spawnDelay: 500 },
  { wave: 8, enemyCount: 22, enemySpeed: 120, enemyLife: 55, spawnDelay: 450 },
  { wave: 9, enemyCount: 25, enemySpeed: 130, enemyLife: 60, spawnDelay: 400 },
  { wave: 10, enemyCount: 30, enemySpeed: 140, enemyLife: 70, spawnDelay: 350 },
];

let currentWaveIndex = 0;
let enemiesRemaining = 0;
let enemiesSpawnedInWave = 0;
let waveInProgress = false;
let spawnEvent;

// Card Definitions
// Ensure these cards refer to appropriate playerStats flags for uniqueness
const cards = [{
    nome: 'Mais Vida',
    descricao: 'Aumenta sua vida máxima em 20.',
    cor: 0x00ff00,
    raridade: 'comum',
    efeito: function() {
      playerStats.maxLife += 20;
      playerStats.life += 20; // Heal
      this.hud.updateHealthBar();
      this.hud.updatePlayerStatsPanel();
    }
  },
  {
    nome: 'Velocidade',
    descricao: 'Aumenta sua velocidade em 50.',
    cor: 0x0000ff,
    raridade: 'comum',
    efeito: function() {
      playerStats.speed += 50;
      this.hud.updatePlayerStatsPanel();
    }
  },
  {
    nome: 'Dano Extra',
    descricao: 'Aumenta seu dano em 5.',
    cor: 0xff0000,
    raridade: 'comum',
    efeito: function() {
      playerStats.damage += 5;
      this.hud.updatePlayerStatsPanel();
    }
  },
  {
    nome: 'Frenesi',
    descricao: 'Aumenta a cadência de tiro em 100ms.',
    cor: 0xffa500,
    raridade: 'comum',
    efeito: function() {
      playerStats.fireRate = Math.max(50, playerStats.fireRate - 100); // Cap fireRate
      this.hud.updatePlayerStatsPanel();
    }
  },
  {
    nome: 'Tiro Rápido',
    descricao: 'Aumenta a velocidade do projétil em 100.',
    cor: 0xffff00,
    raridade: 'comum',
    efeito: function() {
      playerStats.bulletSpeed += 100;
      this.hud.updatePlayerStatsPanel();
    }
  },
  {
    nome: 'Multi-Tiro',
    descricao: 'Atira 2 projéteis extras em arco.',
    cor: 0x8a2be2,
    raridade: 'rara',
    efeito: function() {
      if (playerStats.numBullets < 5) { // Limit multi-shot stacks
        playerStats.numBullets += 2;
        playerStats.bulletSpread = Math.min(0.5, playerStats.bulletSpread + 0.1); // Increase spread
      }
      this.hud.updatePlayerStatsPanel();
    }
  },
  {
    nome: 'Dash',
    descricao: 'Habilita a habilidade de Dash (SHIFT).',
    cor: 0x00ced1,
    raridade: 'rara',
    efeito: function() {
      if (!playerStats.dashAvailable) { // Prevent multiple activations
        playerStats.dashAvailable = true;
        // Add visual indicator for Dash if implemented
      }
      this.hud.updatePlayerStatsPanel();
    }
  },
  {
    nome: 'Aura de Espinhos',
    descricao: 'Causa dano a inimigos próximos.',
    cor: 0x8b0000,
    raridade: 'epica',
    efeito: function() {
      if (!playerStats.spikeAuraActive) { // Prevent multiple activations
        playerStats.spikeAuraActive = true;
        // Logic for spike aura damage will be in update
        // Add visual indicator for Aura if implemented
      }
      this.hud.updatePlayerStatsPanel();
    }
  },
  {
    nome: 'Trocar Arma: Escopeta',
    descricao: 'Troca para a Escopeta.',
    cor: 0x808080,
    raridade: 'comum',
    efeito: function() {
      playerStats.currentWeapon = 'shotgun';
      tiposDeArmas.shotgun.xp = 0; // Reset weapon XP
      this.hud.updateWeaponStats();
      this.hud.updatePlayerStatsPanel();
    }
  },
  {
    nome: 'Trocar Arma: Rifle',
    descricao: 'Troca para o Rifle.',
    cor: 0x4682b4,
    raridade: 'comum',
    efeito: function() {
      playerStats.currentWeapon = 'rifle';
      tiposDeArmas.rifle.xp = 0; // Reset weapon XP
      this.hud.updateWeaponStats();
      this.hud.updatePlayerStatsPanel();
    }
  },
  {
    nome: 'Nível Arma',
    descricao: 'Aumenta o nível da arma atual.',
    cor: 0xffd700,
    raridade: 'rara',
    efeito: function() {
      const currentWeapon = tiposDeArmas[playerStats.currentWeapon];
      if (currentWeapon && currentWeapon.level < currentWeapon.maxLevel) {
        currentWeapon.upgrade(currentWeapon);
        this.hud.updateWeaponStats();
        this.hud.updatePlayerStatsPanel();
      } else if (currentWeapon) {
        console.log('Arma já está no nível máximo!');
      }
    }
  },
  {
    nome: 'Recuperação',
    descricao: 'Recupera 30% da vida máxima.',
    cor: 0x00ff00,
    raridade: 'comum',
    efeito: function() {
      playerStats.life = Math.min(playerStats.maxLife, playerStats.life + playerStats.maxLife * 0.3);
      this.hud.updateHealthBar();
    }
  },
];

let playerCards = []; // Cards currently held by the player (not shown in HUD, but could be)
let chosenCardTweens = []; // To store tweens of choice cards

function preload() {
  this.load.image('player', 'assets/player.png');
  this.load.image('bullet', 'assets/bullet.png');
  this.load.image('enemy', 'assets/enemy.png');
  this.load.image('enemyBullet', 'assets/enemy_bullet.png');
  this.load.image('pistol', 'assets/pistol.png');
  this.load.image('shotgun', 'assets/shotgun.png');
  this.load.image('rifle', 'assets/rifle.png');
  this.load.image('background', 'assets/background.png'); // Example background
}

function create() {
  this.add.image(config.width / 2, config.height / 2, 'background').setDepth(-1).setScrollFactor(0);

  // Initialize HUD and Groups
  hudGroup = this.add.group();
  cardsHUDGroup = this.add.group(); // Group for the player's held cards in the HUD
  choiceCardsGroup = this.add.group(); // Group for the cards presented for choice
  playerEffectsPanel = this.add.group(); // New: Group for active effects display

  player = this.physics.add.sprite(config.width / 2, config.height / 2, 'player').setCollideWorldBounds(true);
  player.setDrag(100);

  cursors = this.input.keyboard.createCursorKeys();
  cursors.shift = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT);

  bullets = this.physics.add.group({
    classType: Bullet,
    runChildUpdate: true
  });
  enemies = this.physics.add.group({
    classType: Enemy,
    runChildUpdate: true
  });
  enemyBullets = this.physics.add.group({
    classType: EnemyBullet,
    runChildUpdate: true
  });
  armas = this.physics.add.group({
    classType: WeaponPickup,
    runChildUpdate: true
  });

  this.physics.add.overlap(bullets, enemies, hitEnemy, null, this);
  this.physics.add.overlap(player, enemies, enemyCollision, null, this);
  this.physics.add.overlap(player, enemyBullets, playerHitByEnemyBullet, null, this);
  this.physics.add.overlap(player, armas, pickUpWeapon, null, this);

  // HUD elements setup
  this.hud = new HUD(this); // Pass 'this' (scene) to the HUD class
  this.hud.create();

  this.input.on('pointermove', function(pointer) {
    if (!showingCards) { // Only rotate player if not showing cards
      let angle = Phaser.Math.Angle.Between(player.x, player.y, pointer.x, pointer.y);
      player.setRotation(angle + Math.PI / 2); // Adjust for sprite's default orientation
    }
  }, this);

  this.input.on('pointerdown', function() {
    if (!showingCards) {
      shootBullet(this);
    }
  }, this);

  this.input.keyboard.on('keydown-SPACE', () => {
    if (!waveInProgress && !gameRestarting && playerStats.life <= 0) {
      restartGame(this);
    }
  });

  startGame(this);
}

function update(time, delta) {
  if (playerStats.life <= 0) {
    if (!gameRestarting) {
      displayGameOver(this);
    }
    return;
  }

  // Player movement
  if (!showingCards) {
    player.setVelocity(0); // Reset velocity to stop movement if no keys are pressed

    const currentSpeed = playerStats.speed;
    if (cursors.left.isDown) {
      player.setVelocityX(-currentSpeed);
    } else if (cursors.right.isDown) {
      player.setVelocityX(currentSpeed);
    }

    if (cursors.up.isDown) {
      player.setVelocityY(-currentSpeed);
    } else if (cursors.down.isDown) {
      player.setVelocityY(currentSpeed);
    }

    // Dash functionality
    if (playerStats.dashAvailable && cursors.shift.isDown) {
      player.setVelocity(0); // Stop current movement
      let dashDirectionX = 0;
      let dashDirectionY = 0;

      if (cursors.left.isDown) dashDirectionX = -1;
      else if (cursors.right.isDown) dashDirectionX = 1;

      if (cursors.up.isDown) dashDirectionY = -1;
      else if (cursors.down.isDown) dashDirectionY = 1;

      // If no direction key is pressed, dash in the direction the player is facing
      if (dashDirectionX === 0 && dashDirectionY === 0) {
        const angle = player.rotation - Math.PI / 2; // Adjust for sprite orientation
        dashDirectionX = Math.cos(angle);
        dashDirectionY = Math.sin(angle);
      }

      const dashSpeed = 800; // Increased dash speed
      const dashDuration = 100; // Duration of dash in ms

      player.body.setVelocity(dashDirectionX * dashSpeed, dashDirectionY * dashSpeed);

      playerStats.dashAvailable = false; // Dash on cooldown
      this.time.delayedCall(dashDuration, () => {
        player.setVelocity(0);
      });
      this.time.delayedCall(2000, () => { // Dash cooldown
        playerStats.dashAvailable = true;
      });
    }

    // Apply Spike Aura damage if active
    if (playerStats.spikeAuraActive) {
      enemies.children.entries.forEach(enemy => {
        const distance = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
        if (distance < 100) { // Aura radius
          enemy.takeDamage(1); // Small continuous damage
        }
      });
    }

    // Normalize diagonal movement speed
    player.body.velocity.normalize().scale(currentSpeed);
  }

  // Update HUD
  this.hud.update();

  // Wave management
  if (waveInProgress && enemies.countActive(true) === 0 && enemiesRemaining === 0 && enemiesSpawnedInWave >= waves[currentWaveIndex].enemyCount) {
    waveInProgress = false;
    currentWaveIndex++;
    if (currentWaveIndex < waves.length) {
      waveText.setText(`Wave ${currentWaveIndex + 1} will start soon...`);
      this.time.delayedCall(3000, () => startNextWave(this), [], this);
    } else {
      waveText.setText('You cleared all waves! Game Over!');
      // Implement game win condition / final screen
    }
  }
}

class Bullet extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y) {
    super(scene, x, y, 'bullet');
    this.speed = playerStats.bulletSpeed; // Use dynamic bullet speed
    this.damage = playerStats.damage; // Use dynamic player damage
  }

  fire(x, y, angle) {
    this.body.reset(x, y);
    this.setActive(true);
    this.setVisible(true);
    this.setRotation(angle + Math.PI / 2); // Adjust for sprite's orientation
    this.scene.physics.velocityFromRotation(angle, this.speed, this.body.velocity);
  }

  preUpdate(time, delta) {
    super.preUpdate(time, delta);
    if (this.y <= 0 || this.y >= this.scene.sys.game.config.height ||
      this.x <= 0 || this.x >= this.scene.sys.game.config.width) {
      this.setActive(false);
      this.setVisible(false);
    }
  }
}

class Enemy extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y, life, speed) {
    super(scene, x, y, 'enemy');
    scene.add.existing(this);
    scene.physics.add.existing(this);

    this.life = life;
    this.speed = speed;
    this.points = 10; // XP / score from this enemy
    this.setCollideWorldBounds(true);
    this.setBounce(1); // Bounce off walls
    this.setCircle(20); // Make collision body a circle for better movement
    this.lastShot = 0;
    this.fireRate = Phaser.Math.Between(1000, 3000); // Random fire rate for enemies
  }

  spawn(x, y, life, speed) {
    this.body.reset(x, y);
    this.life = life;
    this.speed = speed;
    this.setActive(true);
    this.setVisible(true);
    this.setVelocity(Phaser.Math.Between(-this.speed, this.speed), Phaser.Math.Between(-this.speed, this.speed));
  }

  takeDamage(amount) {
    this.life -= amount;
    if (this.life <= 0) {
      this.die();
      return true; // Enemy died
    }
    return false; // Enemy did not die
  }

  die() {
    this.setActive(false);
    this.setVisible(false);
    this.destroy(); // Remove from scene

    // Give XP to player
    addXP(this.scene, this.points);
  }

  preUpdate(time, delta) {
    super.preUpdate(time, delta);

    // Make enemies chase player
    const angle = Phaser.Math.Angle.Between(this.x, this.y, player.x, player.y);
    this.scene.physics.velocityFromRotation(angle, this.speed, this.body.velocity);

    // Enemy shooting (simple logic)
    if (time > this.lastShot + this.fireRate) {
      const enemyBullet = enemyBullets.get(this.x, this.y);
      if (enemyBullet) {
        enemyBullet.fire(this.x, this.y, angle);
        this.lastShot = time;
      }
    }
  }
}

class EnemyBullet extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y) {
    super(scene, x, y, 'enemyBullet');
    this.speed = 200;
    this.damage = 10;
  }

  fire(x, y, angle) {
    this.body.reset(x, y);
    this.setActive(true);
    this.setVisible(true);
    this.setRotation(angle + Math.PI / 2);
    this.scene.physics.velocityFromRotation(angle, this.speed, this.body.velocity);
  }

  preUpdate(time, delta) {
    super.preUpdate(time, delta);
    if (this.y <= 0 || this.y >= this.scene.sys.game.config.height ||
      this.x <= 0 || this.x >= this.scene.sys.game.config.width) {
      this.setActive(false);
      this.setVisible(false);
    }
  }
}

class WeaponPickup extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y, texture, weaponType) {
    super(scene, x, y, texture);
    this.weaponType = weaponType; // 'pistol', 'shotgun', 'rifle'
    scene.add.existing(this);
    scene.physics.add.existing(this);
    this.setCircle(20);
    this.setCollideWorldBounds(true);
    this.setBounce(0.5);
    this.setVelocity(Phaser.Math.Between(-50, 50), Phaser.Math.Between(-50, 50));
  }
}

// --- Game Logic Functions ---

function startGame(scene) {
  // Apply class stats
  const selectedClass = classes[playerStats.playerClass];
  playerStats.maxLife = selectedClass.baseLife;
  playerStats.life = selectedClass.baseLife;
  playerStats.speed = selectedClass.baseSpeed;
  playerStats.damage = selectedClass.baseDamage;
  playerStats.fireRate = selectedClass.baseFireRate;

  // Initial HUD updates
  scene.hud.updateHealthBar();
  scene.hud.updateWeaponStats();
  scene.hud.updatePlayerStatsPanel();
  scene.hud.updateWaveText();

  // Clear any existing cards in HUD or choice
  cardsHUDGroup.clear(true, true);
  choiceCardsGroup.clear(true, true);
  playerEffectsPanel.clear(true, true); // Clear active effects

  startNextWave(scene);
}

function restartGame(scene) {
  if (gameRestarting) return; // Prevent multiple restarts
  gameRestarting = true;

  // Reset player stats to initial values
  playerStats = {
    level: 1,
    xp: 0,
    xpToNextLevel: 100,
    life: 100,
    maxLife: 100,
    speed: 200,
    fireRate: 500,
    damage: 10,
    critChance: 0.1,
    critDamage: 1.5,
    bulletSpeed: 500,
    playerClass: 'Soldado',
    currentWeapon: 'pistol',
    numBullets: 1,
    bulletSpread: 0,
    dashAvailable: false,
    spikeAuraActive: false,
  };

  // Reset weapon stats
  for (const weaponType in tiposDeArmas) {
    if (tiposDeArmas.hasOwnProperty(weaponType)) {
      const defaultWeapon = {
        pistol: {
          name: 'Pistola',
          damageMultiplier: 1,
          fireRateMultiplier: 1,
          bulletSpeedMultiplier: 1,
          numBullets: 1,
          spread: 0,
          image: 'pistol',
          level: 1,
          maxLevel: 5,
          xp: 0,
          xpToNextLevel: 50,
        },
        shotgun: {
          name: 'Escopeta',
          damageMultiplier: 0.8,
          fireRateMultiplier: 1.5,
          bulletSpeedMultiplier: 0.8,
          numBullets: 3,
          spread: 0.2,
          image: 'shotgun',
          level: 1,
          maxLevel: 5,
          xp: 0,
          xpToNextLevel: 70,
        },
        rifle: {
          name: 'Rifle',
          damageMultiplier: 1.2,
          fireRateMultiplier: 0.8,
          bulletSpeedMultiplier: 1.2,
          numBullets: 1,
          spread: 0,
          image: 'rifle',
          level: 1,
          maxLevel: 5,
          xp: 0,
          xpToNextLevel: 60,
        }
      };
      // Simple deep copy for weapon stats reset
      tiposDeArmas[weaponType] = JSON.parse(JSON.stringify(defaultWeapon[weaponType]));
    }
  }

  currentWaveIndex = 0;
  enemiesRemaining = 0;
  enemiesSpawnedInWave = 0;
  waveInProgress = false;

  // Stop any ongoing spawn events
  if (spawnEvent) {
    spawnEvent.remove();
  }

  // Clear all game objects
  bullets.clear(true, true);
  enemies.clear(true, true);
  enemyBullets.clear(true, true);
  armas.clear(true, true);

  // Clear HUD elements
  cardsHUDGroup.clear(true, true);
  choiceCardsGroup.clear(true, true);
  playerEffectsPanel.clear(true, true); // Clear active effects

  // Reset player position
  player.setPosition(config.width / 2, config.height / 2);
  player.setVelocity(0);
  player.setRotation(0);
  player.setActive(true);
  player.setVisible(true);

  // Hide Game Over text if it was shown
  if (scene.gameOverText) {
    scene.gameOverText.setVisible(false);
  }
  if (scene.restartText) {
    scene.restartText.setVisible(false);
  }

  // Restart game state
  startGame(scene);
  gameRestarting = false;
}


function startNextWave(scene) {
  if (currentWaveIndex >= waves.length) {
    waveText.setText('You cleared all waves! Game Over!');
    return;
  }

  const wave = waves[currentWaveIndex];
  waveText.setText(`Wave ${wave.wave} - Spawning ${wave.enemyCount} enemies`);
  enemiesRemaining = wave.enemyCount;
  enemiesSpawnedInWave = 0;
  waveInProgress = true;

  // Spawn enemies at a delay
  spawnEvent = scene.time.addEvent({
    delay: wave.spawnDelay,
    callback: () => spawnEnemy(scene, wave.enemyLife, wave.enemySpeed),
    repeat: wave.enemyCount - 1 // Repeat for total enemy count
  });
}

function spawnEnemy(scene, life, speed) {
  if (enemiesSpawnedInWave >= waves[currentWaveIndex].enemyCount) {
    return;
  }

  const x = Phaser.Math.Between(0, config.width);
  const y = Phaser.Math.Between(0, config.height);
  const enemy = enemies.get(x, y);

  if (enemy) {
    enemy.spawn(x, y, life, speed);
    enemiesSpawnedInWave++;
    enemiesRemaining--;
  }
}

function shootBullet(scene) {
  const currentWeapon = tiposDeArmas[playerStats.currentWeapon];
  if (!currentWeapon) return; // Should not happen if currentWeapon is always valid

  const time = scene.time.now;
  const fireRateAdjusted = currentWeapon.fireRateMultiplier * playerStats.fireRate;

  if (time > lastShoot + fireRateAdjusted) {
    const angle = player.rotation - Math.PI / 2; // Adjust for sprite orientation

    for (let i = 0; i < currentWeapon.numBullets; i++) {
      const bullet = bullets.get(player.x, player.y);
      if (bullet) {
        const spreadAngle = (i - (currentWeapon.numBullets - 1) / 2) * currentWeapon.spread;
        bullet.fire(player.x, player.y, angle + spreadAngle);
      }
    }
    lastShoot = time;
  }
}

function hitEnemy(bullet, enemy) {
  bullet.setActive(false);
  bullet.setVisible(false);

  let damageDealt = playerStats.damage * tiposDeArmas[playerStats.currentWeapon].damageMultiplier;

  // Critical hit chance
  if (Math.random() < playerStats.critChance) {
    damageDealt *= playerStats.critDamage;
    // console.log('CRIT!', damageDealt); // For debugging
  }

  if (enemy.takeDamage(damageDealt)) { // If enemy died
    // Random chance to drop a weapon upgrade (e.g., 5% chance)
    if (Math.random() < 0.05) {
      const weaponTypes = Object.keys(tiposDeArmas);
      const randomWeaponType = Phaser.Utils.Array.GetRandom(weaponTypes);
      const weaponImage = tiposDeArmas[randomWeaponType].image;
      const weaponPickup = new WeaponPickup(this, enemy.x, enemy.y, weaponImage, randomWeaponType);
      armas.add(weaponPickup);
    }
  }
}

function enemyCollision(player, enemy) {
  playerStats.life -= 10; // Take damage on collision
  this.hud.updateHealthBar();
  enemy.die(); // Enemy is destroyed on collision for simplicity

  if (playerStats.life <= 0) {
    player.setActive(false).setVisible(false);
    displayGameOver(this);
  }
}

function playerHitByEnemyBullet(player, enemyBullet) {
  enemyBullet.setActive(false);
  enemyBullet.setVisible(false);
  playerStats.life -= enemyBullet.damage;
  this.hud.updateHealthBar();

  if (playerStats.life <= 0) {
    player.setActive(false).setVisible(false);
    displayGameOver(this);
  }
}

function pickUpWeapon(player, weaponPickup) {
  playerStats.currentWeapon = weaponPickup.weaponType;
  this.hud.updateWeaponStats();
  weaponPickup.destroy(); // Remove pickup from game
}

function addXP(scene, amount) {
  playerStats.xp += amount;
  if (playerStats.xp >= playerStats.xpToNextLevel) {
    levelUp(scene);
  }
  scene.hud.updateXPBar();

  // Add XP to current weapon
  const currentWeapon = tiposDeArmas[playerStats.currentWeapon];
  if (currentWeapon && currentWeapon.level < currentWeapon.maxLevel) {
    currentWeapon.xp += amount;
    if (currentWeapon.xp >= currentWeapon.xpToNextLevel) {
      currentWeapon.upgrade(currentWeapon);
      scene.hud.updateWeaponStats();
    }
  }
}

function levelUp(scene) {
  playerStats.level++;
  playerStats.xp -= playerStats.xpToNextLevel; // Carry over excess XP
  playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.5); // Increase XP needed for next level

  // Give player a choice of cards
  displayCards(scene);

  // Buff player stats on level up (optional, or handled by cards)
  playerStats.maxLife += 5;
  playerStats.life = playerStats.maxLife; // Full heal on level up
  playerStats.damage += 1;
  playerStats.speed += 5;

  scene.hud.updateXPBar();
  scene.hud.updateHealthBar();
  scene.hud.updatePlayerStatsPanel();
}


function displayCards(scene) {
  showingCards = true;
  player.setVelocity(0); // Stop player movement

  // Clear any previously chosen card tweens
  chosenCardTweens.forEach(tween => tween.stop());
  chosenCardTweens = []; // Clear the array

  // Clear existing choice cards
  choiceCardsGroup.clear(true, true);

  const availableCards = [...cards]; // Copy the cards array
  const chosen = [];

  for (let i = 0; i < 3; i++) {
    if (availableCards.length === 0) break;

    const randomIndex = Phaser.Math.Between(0, availableCards.length - 1);
    chosen.push(availableCards[randomIndex]);
    availableCards.splice(randomIndex, 1); // Remove chosen card from available
  }

  const startX = config.width / 2 - (chosen.length - 1) * 100;
  const startY = config.height / 2;

  chosen.forEach((cardData, index) => {
    const x = startX + index * 200;

    const cardBg = scene.add.rectangle(x, startY, 150, 200, cardData.cor || 0x333333, 0.9)
      .setStrokeStyle(4, 0xffffff)
      .setOrigin(0.5)
      .setInteractive()
      .setDepth(100); // Very high depth to ensure it's on top

    const cardTitle = scene.add.text(x, startY - 70, cardData.nome, {
      fontSize: '20px',
      color: '#fff',
      fontStyle: 'bold',
      align: 'center',
      wordWrap: {
        width: 130
      },
      shadow: {
        offsetX: 2,
        offsetY: 2,
        color: '#000',
        blur: 2,
        stroke: true,
        fill: true
      }
    }).setOrigin(0.5).setDepth(101);

    const cardDesc = scene.add.text(x, startY + 20, cardData.descricao, {
      fontSize: '14px',
      color: '#eee',
      align: 'center',
      wordWrap: {
        width: 130
      }
    }).setOrigin(0.5).setDepth(101);

    choiceCardsGroup.addMultiple([cardBg, cardTitle, cardDesc]);

    // Tween for visual effect
    const tween = scene.tweens.add({
      targets: [cardBg, cardTitle, cardDesc],
      y: '+=10',
      ease: 'Sine.easeInOut',
      duration: 800,
      yoyo: true,
      repeat: -1
    });
    chosenCardTweens.push(tween); // Store the tween

    cardBg.on('pointerover', () => {
      cardBg.setStrokeStyle(4, 0xFFD700); // Gold highlight
    });

    cardBg.on('pointerout', () => {
      cardBg.setStrokeStyle(4, 0xffffff);
    });

    cardBg.on('pointerdown', () => {
      // Stop and remove all tweens for choice cards
      chosenCardTweens.forEach(tween => tween.stop());
      chosenCardTweens = []; // Clear the array

      // Clear all choice cards from the screen
      choiceCardsGroup.clear(true, true);
      showingCards = false; // Allow player movement again

      try {
        cardData.efeito.call(scene); // Apply the chosen card's effect, passing the scene context
      } catch (e) {
        console.error("Error applying card effect:", e, cardData.nome);
        // Optionally, display an error message to the player or log it more prominently
      }
      scene.hud.updateActiveEffects(); // Update HUD for new active effects
    });
  });
}

function displayGameOver(scene) {
  // Stop enemies from moving and shooting
  enemies.children.entries.forEach(enemy => {
    enemy.setVelocity(0, 0);
    enemy.setActive(false);
  });
  enemyBullets.clear(true, true); // Clear any lingering enemy bullets

  waveInProgress = false;
  if (spawnEvent) {
    spawnEvent.remove();
  }

  if (!scene.gameOverText) {
    scene.gameOverText = scene.add.text(config.width / 2, config.height / 2 - 50, 'GAME OVER', {
      fontSize: '64px',
      color: '#ff0000',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(1000).setScrollFactor(0);
    scene.restartText = scene.add.text(config.width / 2, config.height / 2 + 20, 'Pressione ESPAÇO para Reiniciar', {
      fontSize: '24px',
      color: '#fff'
    }).setOrigin(0.5).setDepth(1000).setScrollFactor(0);
  } else {
    scene.gameOverText.setVisible(true);
    scene.restartText.setVisible(true);
  }
}

// --- HUD Class ---
class HUD {
  constructor(scene) {
    this.scene = scene;
    this.xpBarBg;
    this.xpBarFill;
    this.xpText;
    this.playerHealthBarBg;
    this.playerHealthBarFill;
    this.playerStatsPanelBg;
    this.playerStatsText;
    this.weaponStatsBg;
    this.weaponStatsText;
    this.activeEffectsText; // New: for active effects
  }

  create() {
    // XP Bar
    this.xpBarX = 10;
    this.xpBarY = 10;
    this.xpBarWidth = 200;
    this.xpBarHeight = 20;

    this.xpBarBg = this.scene.add.graphics().setDepth(10).setScrollFactor(0);
    this.xpBarFill = this.scene.add.graphics().setDepth(11).setScrollFactor(0);
    this.xpText = this.scene.add.text(this.xpBarX + this.xpBarWidth / 2, this.xpBarY + this.xpBarHeight / 2, '', {
      fontSize: '12px',
      color: '#fff'
    }).setOrigin(0.5).setDepth(12).setScrollFactor(0);

    // Health Bar
    this.playerHealthBarX = 10;
    this.playerHealthBarY = 40;
    this.playerHealthBarWidth = 200;
    this.playerHealthBarHeight = 20;

    this.playerHealthBarBg = this.scene.add.graphics().setDepth(10).setScrollFactor(0);
    this.playerHealthBarFill = this.scene.add.graphics().setDepth(11).setScrollFactor(0);

    // Player Stats Panel
    this.playerStatsPanelBg = this.scene.add.graphics().setDepth(10).setScrollFactor(0);
    this.playerStatsText = this.scene.add.text(20, 100, '', {
      fontSize: '14px',
      color: '#fff',
      lineSpacing: 5
    }).setDepth(11).setScrollFactor(0);

    // Weapon Stats Panel
    this.weaponStatsBg = this.scene.add.graphics().setDepth(10).setScrollFactor(0);
    this.weaponStatsText = this.scene.add.text(config.width - 210, 10, '', {
      fontSize: '14px',
      color: '#fff',
      align: 'right',
      lineSpacing: 5
    }).setOrigin(1, 0).setDepth(11).setScrollFactor(0);

    armaImagem = this.scene.add.image(config.width - 110, 100, 'pistol').setScale(0.5).setDepth(11).setScrollFactor(0);

    // Wave Text
    waveText = this.scene.add.text(config.width / 2, 20, '', {
      fontSize: '20px',
      color: '#fff',
      fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(10).setScrollFactor(0);

    // Active Effects Panel (New)
    this.activeEffectsText = this.scene.add.text(config.width - 210, 150, 'Efeitos Ativos:\n', {
      fontSize: '14px',
      color: '#00FFFF', // Cyan for effects
      align: 'right',
      wordWrap: { width: 200 }
    }).setOrigin(1, 0).setDepth(11).setScrollFactor(0);
    playerEffectsPanel.add(this.activeEffectsText); // Add to the group

    // Initial updates
    this.updateXPBar();
    this.updateHealthBar();
    this.updatePlayerStatsPanel();
    this.updateWeaponStats();
    this.updateWaveText();
    this.updateHUDCartas(this.scene); // Initial call for HUD cards
    this.updateActiveEffects(); // Initial call for active effects
  }

  update() {
    // These are updated in the main update loop or when stats change
    // this.updateXPBar();
    // this.updateHealthBar();
    // this.updatePlayerStatsPanel();
    // this.updateWeaponStats();
    // this.updateActiveEffects(); // Update active effects regularly
  }

  updateXPBar() {
    this.xpBarBg.clear();
    this.xpBarFill.clear();

    this.xpBarBg.fillStyle(0x000000, 0.6);
    this.xpBarBg.fillRect(this.xpBarX, this.xpBarY, this.xpBarWidth, this.xpBarHeight);

    const xpPercent = Phaser.Math.Clamp(playerStats.xp / playerStats.xpToNextLevel, 0, 1);
    this.xpBarFill.fillStyle(0x00ff00, 1);
    this.xpBarFill.fillRect(this.xpBarX, this.xpBarY, this.xpBarWidth * xpPercent, this.xpBarHeight);

    this.xpText.setText(`LV ${playerStats.level} XP: ${playerStats.xp}/${playerStats.xpToNextLevel}`);
  }

  updateHealthBar() {
    this.playerHealthBarBg.clear();
    this.playerHealthBarFill.clear();

    this.playerHealthBarBg.fillStyle(0x000000, 0.6);
    this.playerHealthBarBg.fillRect(this.playerHealthBarX, this.playerHealthBarY, this.playerHealthBarWidth, this.playerHealthBarHeight);

    const healthPercent = Phaser.Math.Clamp(playerStats.life / playerStats.maxLife, 0, 1);
    this.playerHealthBarFill.fillStyle(0x8A2BE2, 1);
    this.playerHealthBarFill.fillRect(this.playerHealthBarX, this.playerHealthBarY, this.playerHealthBarWidth * healthPercent, this.playerHealthBarHeight);
  }

  updatePlayerStatsPanel() {
    this.playerStatsPanelBg.clear();
    this.playerStatsPanelBg.fillStyle(0x111111, 0.5);
    this.playerStatsPanelBg.fillRect(10, 90, 200, 120); // Posição e tamanho do painel

    const fireRateMs = playerStats.fireRate / 1000;
    const statsText = `
      Classe: ${playerStats.playerClass}
      Vida: ${Math.floor(playerStats.life)}/${playerStats.maxLife}
      Velocidade: ${playerStats.speed}
      Dano: ${playerStats.damage}
      Cadência: ${fireRateMs.toFixed(2)}s
      Vel. Projétil: ${playerStats.bulletSpeed}
    `;
    this.playerStatsText.setText(statsText);
  }

  updateWeaponStats() {
    this.weaponStatsBg.clear();
    this.weaponStatsBg.fillStyle(0x111111, 0.5);
    this.weaponStatsBg.fillRect(config.width - 210, 10, 200, 120); // Posição e tamanho do painel

    const currentWeapon = tiposDeArmas[playerStats.currentWeapon];

    if (currentWeapon) { // Bug fix: Validate if currentWeapon exists
      const weaponStatsString = `
        Arma: ${currentWeapon.name} (Lv ${currentWeapon.level})
        Dano Base: ${(playerStats.damage * currentWeapon.damageMultiplier).toFixed(1)}
        Cadência: ${(currentWeapon.fireRateMultiplier * playerStats.fireRate / 1000).toFixed(2)}s
        Projéteis: ${currentWeapon.numBullets}
        XP: ${currentWeapon.xp}/${currentWeapon.xpToNextLevel}
      `;
      this.weaponStatsText.setText(weaponStatsString);
      armaImagem.setTexture(currentWeapon.image);
      armaImagem.setPosition(config.width - 110, 100);
    } else {
      this.weaponStatsText.setText("Arma: N/A"); // Handle case where currentWeapon is invalid
      armaImagem.setVisible(false);
    }
  }

  updateWaveText() {
    waveText.setText(`Wave ${currentWaveIndex + 1}`);
  }

  // Updated: Bug fixes and visual improvements for HUD cards
  atualizarHUDCartas(scene) {
    cardsHUDGroup.clear(true, true); // Always clear to prevent ghost elements

    const startX = 50;
    const startY = 240; // Adjusted Y position to avoid overlapping with player stats panel
    const gap = 60;

    // This array should ideally be `playerHeldCards` or similar if the player
    // accumulates cards to see them. For now, it just shows a placeholder if any.
    // If `playerCards` is meant to be the cards a player *has*, then this logic is fine.
    // If it's just for the choice, then this HUD might be removed or repurposed.
    // Assuming `playerCards` is meant to show *chosen* passive cards in HUD.
    // For this example, I'm just making sure it doesn't break if `playerCards` is empty.
    if (playerCards.length === 0) {
      // Optionally display "No Cards Yet" or just keep it empty
      // this.scene.add.text(startX, startY, "No Cards Yet", { fontSize: '16px', color: '#888' }).setDepth(5).setScrollFactor(0);
      return;
    }

    playerCards.forEach((card, index) => {
      const x = startX + index * gap;

      const bg = scene.add.rectangle(x, startY, 50, 70, card.cor || 0x999999, 0.9)
        .setStrokeStyle(2, 0xFFD700)
        .setDepth(5)
        .setScrollFactor(0);

      const title = scene.add.text(x, startY - 10, card.nome[0], {
        fontSize: '22px',
        color: '#fff',
        fontStyle: 'bold',
        shadow: {
          offsetX: 2,
          offsetY: 2,
          color: '#000',
          blur: 2,
          stroke: true,
          fill: true
        }
      }).setOrigin(0.5).setDepth(6).setScrollFactor(0);

      const nameTip = scene.add.text(x, startY + 30, card.nome, {
        fontSize: '11px',
        color: '#FFD700',
        fontStyle: 'italic',
        wordWrap: {
          width: 60
        },
        align: 'center'
      }).setOrigin(0.5).setDepth(6).setScrollFactor(0);

      cardsHUDGroup.addMultiple([bg, title, nameTip]);
    });
  }

  // New: Update active effects display
  updateActiveEffects() {
    let effectsText = "Efeitos Ativos:\n";

    if (playerStats.dashAvailable) {
      effectsText += "- Dash (SHIFT)\n";
    }
    if (playerStats.spikeAuraActive) {
      effectsText += "- Aura de Espinhos\n";
    }
    // Add more conditions for other active effects/buffs
    // Example: if (playerStats.temporarySpeedBoost) { effectsText += "- Velocidade Temporária\n"; }
    // For temporary effects, you'd need a timer associated with playerStats or a separate object.

    if (effectsText === "Efeitos Ativos:\n") {
      effectsText += "Nenhum";
    }

    this.activeEffectsText.setText(effectsText);
  }

  // Placeholder for temporary visual feedback
  displayTemporaryEffect(effectName, durationSeconds) {
    const tempText = this.scene.add.text(config.width / 2, config.height / 2 + 100, effectName, {
      fontSize: '32px',
      color: '#FFFF00',
      fontStyle: 'bold',
      shadow: {
        offsetX: 2,
        offsetY: 2,
        color: '#000',
        blur: 2,
        stroke: true,
        fill: true
      }
    }).setOrigin(0.5).setDepth(1000).setScrollFactor(0);

    this.scene.tweens.add({
      targets: tempText,
      alpha: 0,
      duration: durationSeconds * 1000,
      ease: 'Power1',
      onComplete: () => {
        tempText.destroy();
      }
    });
  }

}

game = new Phaser.Game(config);
</script>
</body>
</html>

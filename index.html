<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons V.1.2.7 - Multi-Enemy Update</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
  <link rel="apple-touch-icon" sizes="180x180" href="favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon.png">
  <link rel="icon" type="image/png" href="favcon.png">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0a0000ce;
    }
    canvas {
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
<script>
// Game configuration
const config = {
  type: Phaser.AUTO,
  width: 1300,
  height: 580,
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: { debug: false } // Set to 'true' for physics debug visualization
  },
  scene: {
    preload,
    create,
    update
  },
  // Global text styles for easier management
  textStyles: {
    main: { fontFamily: 'Cinzel', fontSize: '28px', color: '#A62E2E', stroke: '#000000', strokeThickness: 4, shadow: { offsetX: 2, offsetY: 2, color: '#000', blur: 4, stroke: true, fill: true } },
    wave: { fontFamily: 'Cinzel', fontSize: '24px', color: '#FFFFFF', stroke: '#000000', strokeThickness: 4 },
    gameOver: { fontFamily: 'Cinzel', fontSize: '48px', color: '#FF0000', stroke: '#000000', strokeThickness: 6, align: 'center' },
    revived: { fontFamily: 'Cinzel', fontSize: '36px', color: '#00FF00', stroke: '#000000', strokeThickness: 6, align: 'center' },
    levelUp: { fontFamily: 'Cinzel', fontSize: '40px', color: '#00FFFF', stroke: '#000000', strokeThickness: 6, align: 'center' },
    pickup: { fontSize: '18px', color: '#FFD700', fontStyle: 'bold', stroke: '#000', strokeThickness: 3 },
    cardTitle: { fontSize: '20px', color: '#fff', align: 'center', wordWrap: { width: 140 } },
    cardDesc: { fontSize: '14px', color: '#eee', align: 'center', wordWrap: { width: 140 } },
    xpText: { fontSize: '18px', color: '#FFFFFF' },
    failText: { fontFamily: 'Cinzel', fontSize: '36px', color: '#FF4500', stroke: '#000000', strokeThickness: 6, align: 'center' }
  }
};

// Game variables - Declared globally for accessibility
let player;
let cursors;
let bullets;
let enemies;
let enemyBullets;
let weapons;
let lastShootTime = 0;
let showingCards = false;
let wave = 1;
let cardsGroup; // Group for card choices
let spiritAlly = null; // Spirit ally sprite
let playerCards = []; // Array to store picked cards
let cardsHUDGroup; // Group for cards displayed in HUD
let currentBoss = null; // Reference to the current boss
let waveText; // Text object for displaying wave number
let hud; // HUD instance
let spiritAllyShootEvent = null; // Reference to spirit ally's shooting event
let damageAuraEvent = null; // Reference to damage aura event

// Player stats object - centralizes all player attributes
let playerStats = {
  life: 3,
  maxLife: 3,
  bulletDamage: 1,
  fireRate: 3000,
  hasShield: false,
  spiritAllyActive: false,
  spreadUpgrade: false,
  doubleBullets: false,
  dashAvailable: false,
  dashCooldown: false,
  slowEnemies: false, // Currently unused, consider implementing or removing
  reviveOnce: false,
  increasedDropRate: false,
  tripleBullets: false,
  playerSpeed: 400,
  healOnKill: false,
  damageAura: false,
  speedBoost: false, // Currently unused, consider implementing or removing
  bulletPiercing: false,
  thorns: false,
  bulletSpeedBoost: false,
  xp: 0,
  level: 1,
  xpToNextLevel: 100,
  waveXpGoal: 20
};

// Weapon types
const weaponTypes = {
  pistol: { damage: 1, fireRate: 3000, texture: 'weapon1', name: 'Pistol' },
  machinegun: { damage: 2, fireRate: 1000, texture: 'weapon2', name: 'Fury of Eryon' },
  raygun: { damage: 3, fireRate: 2000, texture: 'weapon3', name: 'Ray Launcher' }
};

// Enemy types
const enemyTypes = {
  normal: {
    texture: 'enemy_robot',
    baseHealth: 4,
    speed: 100,
    scale: 0.06,
    xpReward: 10,
    shoots: false,
    enemyDamage: 1 // Base damage for enemy bullets
  },
  fast: {
    texture: 'enemy_fast',
    baseHealth: 4,
    speed: 180,
    scale: 0.06,
    xpReward: 15,
    shoots: false,
    enemyDamage: 1
  },
  tank: {
    texture: 'enemy_tank',
    baseHealth: 9,
    speed: 70,
    scale: 0.08,
    xpReward: 25,
    shoots: true,
    bulletSpeed: 150,
    shootRate: 2000,
    enemyDamage: 1
  },
  boss: {
    texture: 'boss_robot',
    baseHealth: 50,
    speed: 80,
    scale: 0.15,
    xpReward: 500,
    shoots: true,
    bulletSpeed: 250,
    enemyDamage: 2 // Boss has higher base damage
  }
};

// Level configurations for structured waves
const levelConfigs = [
  // Wave 1
  {
    totalEnemies: 3,
    enemyDistribution: [{ type: 'normal', count: 3 }],
    xpBonusPerEnemy: 20
  },
  // Wave 2
  {
    totalEnemies: 5,
    enemyDistribution: [{ type: 'normal', count: 4 }, { type: 'fast', count: 1 }],
    xpBonusPerEnemy: 15
  },
  // Wave 3
  {
    totalEnemies: 7,
    enemyDistribution: [{ type: 'normal', count: 4 }, { type: 'fast', count: 2 }, { type: 'tank', count: 1 }],
    xpBonusPerEnemy: 10
  },
  // Wave 4
  {
    totalEnemies: 9,
    enemyDistribution: [{ type: 'normal', count: 3 }, { type: 'fast', count: 3 }, { type: 'tank', count: 3 }],
    xpBonusPerEnemy: 5
  },
  // Wave 5 (Boss Wave) - totalEnemies and enemyDistribution will be ignored if boss spawns
  {
    totalEnemies: 0,
    enemyDistribution: [],
    xpBonusPerEnemy: 0
  }
  // Add more waves here as the game progresses, adjusting for boss waves
  // Example: Wave 6-9 would be regular enemies, Wave 10 would be another boss
];

// Initialize the game
const game = new Phaser.Game(config);

// HUD class definition (moved outside functions for better scope)
class HUD {
  constructor(scene, player) {
    this.scene = scene;
    this.player = player;
    this.enemy = null; // Initialize enemy reference for HUD

    this.playerHealthBarBg = this.scene.add.graphics();
    this.playerHealthBarFill = this.scene.add.graphics();
    this.playerHealthBarX = 20;
    this.playerHealthBarY = 20;
    this.playerHealthBarWidth = 150;
    this.playerHealthBarHeight = 20;
    this.updateHealthBar();

    // Enemy Health Bar (reused for boss)
    this.enemyHealthBarBg = this.scene.add.graphics();
    this.enemyHealthBarFill = this.scene.add.graphics();
    this.enemyHealthBarX = config.width / 2 - 150; // Centered at the top for boss
    this.enemyHealthBarY = 20;
    this.enemyHealthBarWidth = 300;
    this.enemyHealthBarHeight = 30;
    this.enemyHealthBarText = this.scene.add.text(config.width / 2, 60, '', { fontSize: '18px', color: '#fff', stroke: '#000', strokeThickness: 2 }).setOrigin(0.5);

    this.xpBarBg = this.scene.add.graphics();
    this.xpBarFill = this.scene.add.graphics();
    this.xpText = this.scene.add.text(config.width / 2, config.height - 30, '', config.textStyles.xpText).setOrigin(0.5);
    this.xpBarX = config.width / 2 - 150;
    this.xpBarY = config.height - 20;
    this.xpBarWidth = 300;
    this.xpBarHeight = 10;
    this.updateXpBar();
  }

  update() {
    this.updateHealthBar(); // Always update player health bar

    // Update enemy/boss health bar
    if (this.enemy && this.enemy.active) {
      this.enemyHealthBarBg.clear();
      this.enemyHealthBarFill.clear();
      this.enemyHealthBarBg.fillStyle(0x000000, 0.6);
      this.enemyHealthBarBg.fillRect(this.enemyHealthBarX, this.enemyHealthBarY, this.enemyHealthBarWidth, this.enemyHealthBarHeight);
      const healthPercent = Phaser.Math.Clamp(this.enemy.health / this.enemy.maxHealth, 0, 1);
      this.enemyHealthBarFill.fillStyle(0xff0000, 1);
      this.enemyHealthBarFill.fillRect(this.enemyHealthBarX, this.enemyHealthBarY, this.enemyHealthBarWidth * healthPercent, this.enemyHealthBarHeight);
      this.enemyHealthBarText.setText(`${this.enemy.name || 'Enemy'} Health: ${Math.floor(this.enemy.health)}/${this.enemy.maxHealth}`);
      this.enemyHealthBarBg.setVisible(true);
      this.enemyHealthBarFill.setVisible(true);
      this.enemyHealthBarText.setVisible(true);
    } else {
      this.enemyHealthBarBg.setVisible(false);
      this.enemyHealthBarFill.setVisible(false);
      this.enemyHealthBarText.setVisible(false);
      this.enemyHealthBarText.setText(''); // Clear text when no enemy is active
    }
  }

  setEnemy(enemy) {
    this.enemy = enemy;
  }

  updateXpBar() {
    this.xpBarBg.clear();
    this.xpBarFill.clear();
    this.xpBarBg.fillStyle(0x000000, 0.6);
    this.xpBarBg.fillRect(this.xpBarX, this.xpBarY, this.xpBarWidth, this.xpBarHeight);
    const xpPercent = Phaser.Math.Clamp(playerStats.xp / playerStats.xpToNextLevel, 0, 1);
    this.xpBarFill.fillStyle(0x00FF00, 1);
    this.xpBarFill.fillRect(this.xpBarX, this.xpBarY, this.xpBarWidth * xpPercent, this.xpBarHeight);
    this.xpText.setText(`LV ${playerStats.level} XP: ${playerStats.xp}/${playerStats.xpToNextLevel}`);
  }

  updateHealthBar() {
    this.playerHealthBarBg.clear();
    this.playerHealthBarFill.clear();
    this.playerHealthBarBg.fillStyle(0x000000, 0.6);
    this.playerHealthBarBg.fillRect(this.playerHealthBarX, this.playerHealthBarY, this.playerHealthBarWidth, this.playerHealthBarHeight);
    const healthPercent = Phaser.Math.Clamp(playerStats.life / playerStats.maxLife, 0, 1);
    this.playerHealthBarFill.fillStyle(0x8A2BE2, 1);
    this.playerHealthBarFill.fillRect(this.playerHealthBarX, this.playerHealthBarY, this.playerHealthBarWidth * healthPercent, this.playerHealthBarHeight);
  }
}

function preload() {
  // Load custom font using WebFontLoader
  WebFont.load({
    google: {
      families: ['Cinzel']
    },
    active: () => {
      // Font is loaded, now load other assets that might use it
      this.load.image('cardBg', 'assets/card.png');
      this.load.image('player', 'assets/player.png');
      this.load.image('bullet', 'assets/bullet.png');
      this.load.image('weapon1', 'assets/pistolinha.png');
      this.load.image('weapon2', 'assets/metralha.png');
      this.load.image('weapon3', 'assets/lancarrio.png');
      this.load.image('fundogame', 'assets/fundogame.png');
      this.load.image('enemy_robot', 'assets/enemy_robot.png');
      this.load.image('enemy_fast', 'assets/enemy_fast.png');
      this.load.image('enemy_tank', 'assets/enemy_tank.png');
      this.load.image('boss_robot', 'assets/boss_robot.png');
    }
  });
}

function create() {
  this.add.image(config.width / 2, config.height / 2, 'fundogame').setDepth(-1);

  player = this.physics.add.sprite(400, 300, 'player').setCollideWorldBounds(true).setScale(0.05);

  // Initialize HUD
  hud = new HUD(this, player);

  // Use object pooling for bullets and enemy bullets
  bullets = this.physics.add.group({
    maxSize: 100,
    runChildUpdate: true
  });
  enemyBullets = this.physics.add.group({
    maxSize: 100,
    runChildUpdate: true
  });
  enemies = this.physics.add.group();
  weapons = this.physics.add.group();

  cursors = this.input.keyboard.createCursorKeys();

  spawnWeapons.call(this);

  this.physics.add.overlap(player, weapons, (player, weapon) => {
    pickupWeapon.call(this, weapon);
  });

  this.input.keyboard.on('keydown-Z', () => {
    if (playerStats.dashAvailable && !playerStats.dashCooldown) {
      dashPlayer.call(this);
    }
  });

  this.input.keyboard.on('keydown-SPACE', () => {
    if (!player.active) {
      // Reset player stats on restart
      playerStats = {
        life: 3,
        maxLife: 3,
        bulletDamage: 1,
        fireRate: 3000,
        hasShield: false,
        spiritAllyActive: false,
        spreadUpgrade: false,
        doubleBullets: false,
        dashAvailable: false,
        dashCooldown: false,
        slowEnemies: false,
        reviveOnce: false,
        increasedDropRate: false,
        tripleBullets: false,
        playerSpeed: 400,
        healOnKill: false,
        damageAura: false,
        speedBoost: false,
        bulletPiercing: false,
        thorns: false,
        bulletSpeedBoost: false,
        xp: 0,
        level: 1,
        xpToNextLevel: 100,
        waveXpGoal: 20
      };
      wave = 1;
      showingCards = false;
      playerCards = []; // Clear collected cards

      // Stop and clear boss events if restarting
      if (currentBoss) {
        if (currentBoss.healEvent) currentBoss.healEvent.destroy();
        if (currentBoss.shootEvent) currentBoss.shootEvent.destroy();
        currentBoss = null;
      }
      // Stop and clear spirit ally event
      if (spiritAllyShootEvent) {
        spiritAllyShootEvent.destroy();
        spiritAllyShootEvent = null;
        if (spiritAlly) spiritAlly.destroy(); // Ensure ally sprite is also removed
        playerStats.spiritAllyActive = false;
      }
      // Stop and clear damage aura event
      if (damageAuraEvent) {
        damageAuraEvent.destroy();
        damageAuraEvent = null;
        playerStats.damageAura = false;
      }

      this.scene.restart();
    }
  });

  // Bullet-enemy collision
  this.physics.add.overlap(bullets, enemies, (bullet, enemy) => {
    if (bullet.active && enemy.active) {
      enemy.health -= playerStats.bulletDamage;

      const particles = this.add.particles('bullet');
      particles.createEmitter({
        x: enemy.x,
        y: enemy.y,
        speed: { min: -50, max: 50 },
        scale: { start: 0.05, end: 0 },
        lifespan: 300,
        blendMode: 'ADD',
        quantity: 3
      });
      this.time.delayedCall(300, () => particles.destroy());

      if (!playerStats.bulletPiercing) {
        bullets.killAndHide(bullet);
        bullet.body.stop();
      }

      if (enemy.health <= 0) {
        enemies.killAndHide(enemy);
        enemy.body.stop();
        gainXp.call(this, enemy.xpReward);
        if (playerStats.healOnKill) {
          playerStats.life = Math.min(playerStats.life + 0.5, playerStats.maxLife);
          hud.updateHealthBar();
        }
        if (enemy === currentBoss) {
            if (currentBoss.healEvent) currentBoss.healEvent.destroy();
            if (currentBoss.shootEvent) currentBoss.shootEvent.destroy();
            currentBoss = null; // Clear boss reference
        }
      }
    }
  });

  // Enemy bullet-player collision
  this.physics.add.overlap(enemyBullets, player, (bullet, p) => {
    if (bullet.active && p.active) {
      // Use the bullet's own damage value (scaled by enemy base damage)
      playerStats.life -= bullet.damage;
      enemyBullets.killAndHide(bullet);
      bullet.body.stop();

      if (!playerStats.hasShield) {
        hud.updateHealthBar();
        p.setTint(0xff0000);
        this.time.delayedCall(100, () => p.clearTint());

        if (playerStats.thorns) {
          enemies.getChildren().forEach(enemy => {
            if (!enemy.active) return;
            const dist = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
            if (dist < 150) { // Thorns radius
              enemy.health -= 1; // Thorns damage
              if (enemy.health <= 0) {
                enemies.killAndHide(enemy);
                enemy.body.stop();
                gainXp.call(this, enemy.xpReward);
                if (enemy === currentBoss) {
                    if (currentBoss.healEvent) currentBoss.healEvent.destroy();
                    if (currentBoss.shootEvent) currentBoss.shootEvent.destroy();
                    currentBoss = null;
                }
              }
            }
          });
        }

        if (playerStats.life <= 0) {
          if (playerStats.reviveOnce) {
            playerStats.life = 1;
            playerStats.reviveOnce = false;
            hud.updateHealthBar();
            p.clearTint();
            const reviveText = this.add.text(config.width / 2, config.height / 2 - 50, 'REVIVED!', config.textStyles.revived).setOrigin(0.5);
            this.time.delayedCall(3000, () => reviveText.destroy());
          } else {
            p.setActive(false).setVisible(false);
            this.add.text(config.width / 2, config.height / 2, 'GAME OVER\nPress SPACE to Restart', config.textStyles.gameOver).setOrigin(0.5);
            // Ensure all game timers/events are stopped on game over
            if (currentBoss) {
              if (currentBoss.healEvent) currentBoss.healEvent.destroy();
              if (currentBoss.shootEvent) currentBoss.shootEvent.destroy();
            }
            if (spiritAllyShootEvent) spiritAllyShootEvent.destroy();
            if (damageAuraEvent) damageAuraEvent.destroy();
          }
        }
      } else {
        // Shield absorbs hit
        playerStats.hasShield = false;
        p.clearTint();
      }
    }
  });

  // HUD elements for weapon display
  const centerW = config.width / 2;
  const topOffset = 20;

  const box = this.add.rectangle(centerW, topOffset + 20, 300, 70, 0x111111, 0.3).setOrigin(0.5, 0);
  box.setStrokeStyle(2, 0x00ffff, 0.1);

  this.weaponNameText = this.add.text(centerW, topOffset, weaponTypes.pistol.name, config.textStyles.main).setOrigin(0.5, 0);
  this.weaponImage = this.add.image(centerW, topOffset + 50, weaponTypes.pistol.texture).setScale(0.1);

  this.hudElements = this.add.group([box, this.weaponNameText, this.weaponImage]);

  waveText = this.add.text(config.width - 20, 20, `Wave ${wave}`, config.textStyles.wave).setOrigin(1, 0);

  // Initialize cards HUD group
  cardsHUDGroup = this.add.group();

  spawnWave.call(this);
}

function update(time) {
  hud.update(); // Update HUD instance

  if (!player.active) return;

  // Player movement
  let vx = 0, vy = 0;
  if (cursors.left.isDown) vx = -1;
  else if (cursors.right.isDown) vx = 1;
  if (cursors.up.isDown) vy = -1;
  else if (cursors.down.isDown) vy = 1;

  const norm = Math.hypot(vx, vy) || 1;
  player.setVelocity((vx / norm) * playerStats.playerSpeed, (vy / norm) * playerStats.playerSpeed);

  // Player shooting
  if (time > lastShootTime + playerStats.fireRate) {
    shootRadial.call(this);
    lastShootTime = time;
  }

  // Enemy movement and shooting
  enemies.getChildren().forEach(enemy => {
    if (!enemy.active) return;
    this.physics.moveToObject(enemy, player, enemy.speed);

    // Enemy shooting logic (only for enemies that shoot, like 'tank' type)
    if (enemy.shoots && time > enemy.lastShootTime + enemy.shootRate) {
        shootEnemyBullet.call(this, enemy);
        enemy.lastShootTime = time;
    }
  });

  // Update closest enemy for HUD
  let targetEnemyForHUD = currentBoss && currentBoss.active ? currentBoss : null;

  if (!targetEnemyForHUD) {
      let minDistance = Infinity;
      enemies.getChildren().forEach(enemy => {
          if (enemy.active) {
              const distance = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
              if (distance < minDistance) {
                  minDistance = distance;
                  targetEnemyForHUD = enemy;
              }
          }
      });
  }
  hud.setEnemy(targetEnemyForHUD); // Update enemy reference in HUD

  // Spirit Ally movement
  if (playerStats.spiritAllyActive && spiritAlly && spiritAlly.active) {
    spiritAlly.x = player.x + 50;
    spiritAlly.y = player.y - 50;
  }

  // Check for wave completion
  if (enemies.countActive(true) === 0 && !showingCards) {
    showingCards = true;
    this.time.delayedCall(1000, () => showCardChoices.call(this));
  }
}

function shootRadial() {
  // Use `this` to access scene properties like `bullets.get`
  const count = playerStats.spreadUpgrade ? 24 : 12;
  const speed = playerStats.bulletSpeedBoost ? 900 : 700;

  for (let i = 0; i < count; i++) {
    const baseAngle = Phaser.Math.DegToRad((360 / count) * i);

    const createBullet = (angleOffset = 0) => {
      const angle = baseAngle + angleOffset;
      const bullet = bullets.get(player.x, player.y, 'bullet');
      if (bullet) {
        bullet.setActive(true).setVisible(true).setScale(0.02);
        this.physics.velocityFromRotation(angle, speed, bullet.body.velocity);
        // Deactivate bullet after a short time to return to pool
        this.time.delayedCall(500, () => {
          if (bullet && bullet.active) {
            bullets.killAndHide(bullet);
            bullet.body.stop();
          }
        });
      }
    };

    if (playerStats.tripleBullets) {
      createBullet(Phaser.Math.DegToRad(-5));
      createBullet(0);
      createBullet(Phaser.Math.DegToRad(5));
    } else if (playerStats.doubleBullets) {
      createBullet(Phaser.Math.DegToRad(-3));
      createBullet(Phaser.Math.DegToRad(3));
    } else {
      createBullet();
    }
  }
}

function shootEnemyBullet(enemy) {
    const bullet = enemyBullets.get(enemy.x, enemy.y, 'bullet');
    if (bullet) {
        bullet.setActive(true).setVisible(true).setScale(0.03).setTint(0xff0000); // Tint enemy bullets red
        // Assign damage to the bullet itself
        bullet.damage = enemy.enemyDamage; // Bullet carries enemy's damage
        this.physics.moveToObject(bullet, player, enemyTypes[enemy.name].bulletSpeed || 200); // Use enemy type's bullet speed
        this.time.delayedCall(3000, () => { // Bullet despawns after 3 seconds
            if (bullet && bullet.active) {
                enemyBullets.killAndHide(bullet);
                bullet.body.stop();
            }
        });
    }
}

function showCardChoices() {
  // Check if player has enough XP to level up, if not, wave failed
  if (playerStats.xp < playerStats.waveXpGoal && wave > 1) { // Only check from wave 2 onwards
    player.setActive(false).setVisible(false); // Hide player
    this.add.text(config.width / 2, config.height / 2, 'WAVE FAILED!\nInsufficient XP\nReturning to Wave 1\n(Press SPACE to Restart)', config.textStyles.failText).setOrigin(0.5);

    // Reset game state for restart
    playerStats = {
      life: 3, maxLife: 3, bulletDamage: 1, fireRate: 3000, hasShield: false, spiritAllyActive: false, spreadUpgrade: false,
      doubleBullets: false, dashAvailable: false, dashCooldown: false, slowEnemies: false, reviveOnce: false,
      increasedDropRate: false, tripleBullets: false, playerSpeed: 400, healOnKill: false, damageAura: false,
      speedBoost: false, bulletPiercing: false, thorns: false, bulletSpeedBoost: false, xp: 0, level: 1,
      xpToNextLevel: 100, waveXpGoal: 20
    };
    wave = 1; // Reset wave to 1
    showingCards = false;
    playerCards = []; // Clear collected cards

    // Clean up any active timers/events
    if (currentBoss) {
      if (currentBoss.healEvent) currentBoss.healEvent.destroy();
      if (currentBoss.shootEvent) currentBoss.shootEvent.destroy();
      currentBoss = null;
    }
    if (spiritAllyShootEvent) {
      spiritAllyShootEvent.destroy();
      spiritAllyShootEvent = null;
      if (spiritAlly) spiritAlly.destroy();
      playerStats.spiritAllyActive = false;
    }
    if (damageAuraEvent) {
      damageAuraEvent.destroy();
      damageAuraEvent = null;
      playerStats.damageAura = false;
    }

    this.scene.restart(); // Restart the scene
    return;
  }

  // Increase XP goal for next wave only if the wave was successful (or it's the first wave)
  playerStats.waveXpGoal = Math.floor(playerStats.waveXpGoal * 1.5);

  const cardOptions = [
    { name: 'Shield of Ivirik', desc: 'Protection that saves you from death once', color: 0xffc107, effect: () => { playerStats.hasShield = true; } },
    { name: 'Double Shot', desc: 'Fires two more bullets', color: 0x4caf50, effect: () => { playerStats.doubleBullets = true; } },
    { name: 'Dr. Anomoi\'s Blessing', desc: 'An automaton assists you in attack', color: 0x00bcd4, effect: activateSpiritAlly },
    { name: 'Spread Upgrade', desc: 'Fires bullets in a larger circle', color: 0x9c27b0, effect: () => { playerStats.spreadUpgrade = true; } },
    { name: 'Dash', desc: 'Quick run to escape', color: 0xf44336, effect: () => { playerStats.dashAvailable = true; } },
    { name: 'Piercing Projectile', desc: 'Bullets pierce enemies overwhelmingly', color: 0x03a9f4, effect: () => { playerStats.bulletPiercing = true; } },
    { name: 'Instant Recovery', desc: 'Recovers 2 life', color: 0x8bc34a, effect: () => { playerStats.life = Math.min(playerStats.life + 2, playerStats.maxLife); hud.updateHealthBar(); } },
    { name: 'Metalion\'s Fury', desc: 'Increases damage for 15s', color: 0xff5722, effect: () => {
        const originalDamage = playerStats.bulletDamage;
        playerStats.bulletDamage += 1;
        // Revert damage after duration
        this.time.delayedCall(15000, () => playerStats.bulletDamage = originalDamage);
      }
    },
    { name: 'Ghost Life', desc: 'Survive with 1 life on death', color: 0x673ab7, effect: () => { playerStats.reviveOnce = true; } },
    { name: 'Midnight Energy Drink', desc: 'Movement speed increased by 50% for 10s', color: 0xffeb3b, effect: () => {
        const originalSpeed = playerStats.playerSpeed;
        playerStats.playerSpeed *= 1.5;
        this.time.delayedCall(10000, () => playerStats.playerSpeed = originalSpeed);
      }
    },
    { name: 'Lethal Aura', desc: 'Deals continuous damage to nearby enemies', color: 0xcd201f, effect: () => {
        playerStats.damageAura = true;
        // Ensure only one aura event is active
        if (!damageAuraEvent) {
            damageAuraEvent = this.time.addEvent({
              delay: 1000, // Damage every 1 second
              loop: true,
              callback: () => {
                enemies.getChildren().forEach(e => {
                  if (e.active) {
                    const dist = Phaser.Math.Distance.Between(player.x, player.y, e.x, e.y);
                    if (dist < 100) { // Aura radius
                      e.health -= 1; // Aura damage
                      if (e.health <= 0) {
                        enemies.killAndHide(e);
                        e.body.stop();
                        gainXp.call(this, e.xpReward);
                        if (e === currentBoss) {
                            if (currentBoss.healEvent) currentBoss.healEvent.destroy();
                            if (currentBoss.shootEvent) currentBoss.shootEvent.destroy();
                            currentBoss = null;
                        }
                      }
                    }
                  }
                });
              },
              callbackScope: this
            });
        }
      }
    },
    { name: 'Neural Speed', desc: 'Fire rate 2x faster for 10s', color: 0x03a9f4, effect: () => {
        const originalRate = playerStats.fireRate;
        playerStats.fireRate /= 2;
        this.time.delayedCall(10000, () => playerStats.fireRate = originalRate);
      }
    },
    { name: 'Fragment Hack', desc: 'Doubled chance of weapons appearing in next waves', color: 0x607d8b, effect: () => {
        playerStats.increasedDropRate = true;
      }
    },
    { name: 'Chaos Breath', desc: 'Recovers all your life', color: 0x009688, effect: () => {
        playerStats.life = playerStats.maxLife;
        hud.updateHealthBar();
      }
    },
    { name: 'Plasma Mirror', desc: 'Reflects 30% damage back to enemy for 10s (Not fully implemented)', color: 0x673ab7, effect: () => {
        // This effect needs more complex physics and damage handling to be fully implemented.
        // For now, it might serve as a visual shield or a placeholder.
        playerStats.hasShield = true;
        // You would need to add logic in enemy bullet collision to reflect damage.
      }
    },
    { name: 'Triple Cannon', desc: 'Fires 3 bullets instead of 1', color: 0xff9800, effect: () => {
        playerStats.tripleBullets = true;
      }
    },
    { name: 'Asphalt Thorns', desc: 'Damage to nearby enemies when hit', color: 0xe91e63, effect: () => { playerStats.thorns = true; } },
    { name: 'Eagle Eye', desc: 'Your bullets fly faster', color: 0x5cb85c, effect: () => { playerStats.bulletSpeedBoost = true; } },
    { name: 'Reinforced Armor', desc: 'Increases your max life by 1', color: 0x7e57c2, effect: () => {
        playerStats.maxLife += 1;
        playerStats.life = playerStats.maxLife; // Heal to new max life
        hud.updateHealthBar();
      }
    },
    { name: 'Vampiric Touch', desc: 'Regain life when defeating enemies', color: 0x8b0000, effect: () => { playerStats.healOnKill = true; } },
    { name: 'Thunder Charge', desc: 'Dash stuns nearby enemies', color: 0x42a5f5, effect: () => {
        playerStats.dashAvailable = true;
        playerStats.stunOnDash = true;
      }
    },
  ];

  Phaser.Utils.Array.Shuffle(cardOptions);
  const selectedCards = cardOptions.slice(0, 3); // Select 3 random cards

  cardsGroup = this.add.group();

  const startX = this.cameras.main.centerX;
  const startY = this.cameras.main.centerY;
  const gap = 220;

  selectedCards.forEach((card, i) => {
    const x = startX + (i - 1) * gap;
    const y = startY;

    const container = this.add.container(x, y);
    const bgImage = this.add.image(0, 0, 'cardBg').setDisplaySize(160, 240);

    const title = this.add.text(0, -80, card.name, config.textStyles.cardTitle).setOrigin(0.5);
    const desc = this.add.text(0, 0, card.desc, config.textStyles.cardDesc).setOrigin(0.5);

    container.add([bgImage, title, desc]);
    container.setSize(160, 240); // Set container size for interactivity
    container.setInteractive();

    this.tweens.add({
      targets: container,
      y: y - 20,
      yoyo: true,
      repeat: -1,
      duration: 1000,
      ease: 'Sine.easeInOut'
    });

    container.on('pointerover', () => {
      container.setScale(1.1);
    });
    container.on('pointerout', () => {
      container.setScale(1);
    });

    container.on('pointerdown', () => {
      this.tweens.add({
        targets: container,
        scale: 0.9,
        duration: 100,
        yoyo: true,
        ease: 'Power1',
        onComplete: () => {
          card.effect.call(this); // Apply card effect
          cardsGroup.clear(true, true); // Clear all card choices

          playerCards.push(card); // Add card to player's collected cards
          updateCardsHUD(this); // Update HUD to show new card

          showingCards = false; // Allow game to resume
          wave++; // Increment wave
          waveText.setText(`Wave ${wave}`); // Update wave text
          spawnWave.call(this); // Start next wave
          spawnWeapons.call(this); // Spawn new weapons for next wave
        }
      });
    });
    cardsGroup.add(container); // Add container to cards group
  });
}

function activateSpiritAlly() {
  // If a spirit ally already exists, destroy it before creating a new one
  if (spiritAlly) {
    spiritAlly.destroy();
    spiritAlly = null; // Clear the reference
  }
  // Clear previous spirit ally shoot event if it exists
  if (spiritAllyShootEvent) {
      spiritAllyShootEvent.destroy();
      spiritAllyShootEvent = null;
  }

  spiritAlly = this.physics.add.sprite(player.x, player.y, 'player').setScale(0.03).setAlpha(0.7);
  playerStats.spiritAllyActive = true;

  // Add an event to make the spirit ally shoot
  spiritAllyShootEvent = this.time.addEvent({
    delay: 1500, // Spirit ally shoots every 1.5 seconds
    loop: true,
    callback: () => {
      if (!playerStats.spiritAllyActive || !spiritAlly || !spiritAlly.active) return;
      const closestEnemy = enemies.getChildren().reduce((closest, enemy) => {
        if (!enemy.active) return closest;
        const dist = Phaser.Math.Distance.Between(spiritAlly.x, spiritAlly.y, enemy.x, enemy.y);
        if (dist < closest.distance) {
          return { enemy: enemy, distance: dist };
        }
        return closest;
      }, { enemy: null, distance: Infinity });

      if (closestEnemy.enemy) {
        const bullet = bullets.get(spiritAlly.x, spiritAlly.y, 'bullet');
        if (bullet) {
          bullet.setActive(true).setVisible(true).setScale(0.02).setTint(0x00FFFF); // Tint ally bullets
          this.physics.moveToObject(bullet, closestEnemy.enemy, 500);
          this.time.delayedCall(1000, () => {
            if (bullet && bullet.active) {
              bullets.killAndHide(bullet);
              bullet.body.stop();
            }
          });
        }
      }
    },
    callbackScope: this
  });

  // Add a timer to destroy the spirit ally after 15 seconds
  this.time.delayedCall(15000, () => {
    if (spiritAlly) spiritAlly.destroy();
    playerStats.spiritAllyActive = false;
    // Destroy the shooting event when the ally disappears
    if (spiritAllyShootEvent) {
        spiritAllyShootEvent.destroy();
        spiritAllyShootEvent = null;
    }
  }, [], this);
}

function spawnWave() {
  // Clear all active enemies from the previous wave
  enemies.getChildren().forEach(enemy => enemies.killAndHide(enemy));

  if (wave % 5 === 0) { // Spawn boss every 5 waves
      spawnBoss.call(this);
      return;
  }

  const currentLevelConfig = levelConfigs[wave - 1]; // Adjust for 0-indexed array
  const scalingFactor = 1 + (wave - 1) * 0.012; // 1.2% increase per wave (e.g., wave 1: 1.0, wave 2: 1.012, wave 3: 1.024)

  let totalEnemiesToSpawn;
  let xpBonusForThisWave = 0;

  if (currentLevelConfig) {
    totalEnemiesToSpawn = currentLevelConfig.totalEnemies;
    xpBonusForThisWave = currentLevelConfig.xpBonusPerEnemy || 0;

    currentLevelConfig.enemyDistribution.forEach(dist => {
      for (let i = 0; i < dist.count; i++) {
        const x = Phaser.Math.Between(100, config.width - 100);
        const y = Phaser.Math.Between(100, config.height - 100);
        const typeProps = enemyTypes[dist.type];

        if (!typeProps) {
          console.warn(`Unknown enemy type: ${dist.type}`);
          continue;
        }

        const enemy = enemies.get(x, y, typeProps.texture);
        if (enemy) {
          enemy.setActive(true).setVisible(true).setScale(typeProps.scale);
          // Apply scaling for health, speed, and enemyDamage
          enemy.health = Math.ceil(typeProps.baseHealth * scalingFactor); // Round up health
          enemy.maxHealth = enemy.health; // Set max health for health bar
          enemy.speed = Math.ceil(typeProps.speed * scalingFactor); // Round up speed
          enemy.setCollideWorldBounds(true);
          enemy.xpReward = typeProps.xpReward + xpBonusForThisWave;
          enemy.name = dist.type; // Store enemy type name
          enemy.shoots = typeProps.shoots;
          enemy.lastShootTime = 0; // Initialize last shoot time for each enemy
          enemy.shootRate = typeProps.shootRate;
          enemy.enemyDamage = Math.ceil(typeProps.enemyDamage * scalingFactor); // Scale enemy damage
        }
      }
    });
  } else {
    // Generic logic for waves not defined in levelConfigs (higher waves)
    totalEnemiesToSpawn = Math.floor(wave * 2.5);
    for (let i = 0; i < totalEnemiesToSpawn; i++) {
      const x = Phaser.Math.Between(100, config.width - 100);
      const y = Phaser.Math.Between(100, config.height - 100);

      let enemyTypeKey = 'normal';
      if (wave >= 3 && Phaser.Math.RND.between(1, 100) < (30 + wave * 3)) {
        enemyTypeKey = 'fast';
      }
      if (wave >= 5 && Phaser.Math.RND.between(1, 100) < (20 + wave * 2)) {
        enemyTypeKey = 'tank';
      }
      if (wave >= 7 && Phaser.Math.RND.between(1, 100) < 60) {
        enemyTypeKey = Phaser.Utils.Array.GetRandom(['fast', 'tank']);
      }

      const typeProps = enemyTypes[enemyTypeKey];
      const enemy = enemies.get(x, y, typeProps.texture);
      if (enemy) {
        enemy.setActive(true).setVisible(true).setScale(typeProps.scale);
        // Apply scaling for health, speed, and enemyDamage
        enemy.health = Math.ceil(typeProps.baseHealth * scalingFactor);
        enemy.maxHealth = enemy.health;
        enemy.speed = Math.ceil(typeProps.speed * scalingFactor);
        enemy.setCollideWorldBounds(true);
        enemy.xpReward = typeProps.xpReward;
        enemy.name = enemyTypeKey;
        enemy.shoots = typeProps.shoots;
        enemy.lastShootTime = 0;
        enemy.shootRate = typeProps.shootRate;
        enemy.enemyDamage = Math.ceil(typeProps.enemyDamage * scalingFactor);
      }
    }
  }
}

function spawnBoss() {
  const typeProps = enemyTypes.boss;
  const x = config.width / 2;
  const y = 100;
  const scalingFactor = 1 + (wave - 1) * 0.012; // Apply scaling to boss too

  currentBoss = enemies.get(x, y, typeProps.texture);
  if (currentBoss) {
    currentBoss.setActive(true).setVisible(true).setScale(typeProps.scale);
    currentBoss.health = Math.ceil(typeProps.baseHealth * scalingFactor);
    currentBoss.maxHealth = currentBoss.health;
    currentBoss.speed = Math.ceil(typeProps.speed * scalingFactor);
    currentBoss.xpReward = typeProps.xpReward + Math.floor(wave * 20);
    currentBoss.setCollideWorldBounds(true);
    currentBoss.name = 'Boss Robot';
    currentBoss.enemyDamage = Math.ceil(typeProps.enemyDamage * scalingFactor); // Scale boss damage

    // Boss Healing Event
    // Destroy existing heal event if present (e.g., if a boss is spawned again)
    if (currentBoss.healEvent) currentBoss.healEvent.destroy();
    currentBoss.healEvent = this.time.addEvent({
        delay: 25000, // Heal every 25 seconds
        loop: true,
        callback: () => {
            if (currentBoss && currentBoss.active && currentBoss.health < currentBoss.maxHealth) {
                const healAmount = currentBoss.maxHealth * 0.10; // Heal 10% of max health
                currentBoss.health = Math.min(currentBoss.health + healAmount, currentBoss.maxHealth);
                const healText = this.add.text(currentBoss.x, currentBoss.y - 50, `+${Math.floor(healAmount)} HP`, { fontSize: '24px', color: '#00FF00', stroke: '#000', strokeThickness: 4 }).setOrigin(0.5);
                this.time.delayedCall(1000, () => healText.destroy());
            }
        },
        callbackScope: this
    });

    // Boss Shooting Patterns Event
    // Destroy existing shoot event if present
    if (currentBoss.shootEvent) currentBoss.shootEvent.destroy();
    currentBoss.shootPatternIndex = 0; // Initialize pattern index
    currentBoss.shootEvent = this.time.addEvent({
        delay: 3000, // New pattern every 3 seconds
        loop: true,
        callback: () => {
            if (currentBoss && currentBoss.active) {
                bossShootPattern.call(this, currentBoss);
            }
        },
        callbackScope: this
    });

    this.physics.moveToObject(currentBoss, player, currentBoss.speed); // Boss initially moves towards player
  }
}

function bossShootPattern(boss) {
    const bulletSpeed = boss.bulletSpeed;
    const scene = this; // Reference to the Phaser scene

    switch (boss.shootPatternIndex) {
        case 0: // Spread shot towards player
            const numBulletsSpread = 5;
            const angleStep = 20; // Degrees
            const targetAngle = Phaser.Math.RadToDeg(Phaser.Math.Angle.Between(boss.x, boss.y, player.x, player.y));
            const startAngleSpread = targetAngle - (numBulletsSpread - 1) / 2 * angleStep;

            for (let i = 0; i < numBulletsSpread; i++) {
                const angle = Phaser.Math.DegToRad(startAngleSpread + i * angleStep);
                const bullet = enemyBullets.get(boss.x, boss.y, 'bullet');
                if (bullet) {
                    bullet.setActive(true).setVisible(true).setScale(0.04).setTint(0xff0000);
                    bullet.damage = boss.enemyDamage; // Assign boss damage to bullet
                    scene.physics.velocityFromRotation(angle, bulletSpeed, bullet.body.velocity);
                    scene.time.delayedCall(3000, () => { if (bullet && bullet.active) { enemyBullets.killAndHide(bullet); bullet.body.stop(); }});
                }
            }
            break;

        case 1: // Radial shot (360 degrees)
            const numBulletsRadial = 12;
            for (let i = 0; i < numBulletsRadial; i++) {
                const angle = Phaser.Math.DegToRad((360 / numBulletsRadial) * i);
                const bullet = enemyBullets.get(boss.x, boss.y, 'bullet');
                if (bullet) {
                    bullet.setActive(true).setVisible(true).setScale(0.04).setTint(0xff0000);
                    bullet.damage = boss.enemyDamage; // Assign boss damage to bullet
                    scene.physics.velocityFromRotation(angle, bulletSpeed, bullet.body.velocity);
                    scene.time.delayedCall(3000, () => { if (bullet && bullet.active) { enemyBullets.killAndHide(bullet); bullet.body.stop(); }});
                }
            }
            break;

        case 2: // Burst shot towards player
            const numBursts = 3;
            scene.time.repeatEvent({
                delay: 300, // Delay between each bullet in burst
                repeat: numBursts - 1, // Repeat 2 more times for a total of 3
                callback: () => {
                    const bullet = enemyBullets.get(boss.x, boss.y, 'bullet');
                    if (bullet) {
                        bullet.setActive(true).setVisible(true).setScale(0.04).setTint(0xff0000);
                        bullet.damage = boss.enemyDamage; // Assign boss damage to bullet
                        scene.physics.moveToObject(bullet, player, bulletSpeed * 1.5); // Faster bullets in burst
                        scene.time.delayedCall(3000, () => { if (bullet && bullet.active) { enemyBullets.killAndHide(bullet); bullet.body.stop(); }});
                    }
                },
                callbackScope: scene
            });
            break;
    }

    boss.shootPatternIndex = (boss.shootPatternIndex + 1) % 3; // Cycle through patterns
}

function dashPlayer() {
  if (playerStats.dashCooldown) return; // Prevent dash if on cooldown

  playerStats.dashCooldown = true; // Activate cooldown

  let dx = 0, dy = 0;
  if (cursors.left.isDown) dx = -1;
  else if (cursors.right.isDown) dx = 1;
  if (cursors.up.isDown) dy = -1;
  else if (cursors.down.isDown) dy = 1;

  if (dx === 0 && dy === 0) {
    playerStats.dashCooldown = false; // No movement, so no dash, reset cooldown immediately
    return;
  }

  const dashDistance = 150;
  const targetX = player.x + dx * dashDistance;
  const targetY = player.y + dy * dashDistance;

  this.tweens.add({
    targets: player,
    x: targetX,
    y: targetY,
    duration: 150, // Dash duration
    ease: 'Power2',
    onComplete: () => {
      if (playerStats.stunOnDash) {
        enemies.getChildren().forEach(enemy => {
          if (enemy.active) {
            const dist = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
            if (dist < 100) { // Stun radius
              enemy.body.setVelocity(0, 0); // Stop enemy movement
              enemy.setTint(0x0000ff); // Visual stun feedback
              this.time.delayedCall(1000, () => enemy.clearTint()); // Clear tint after stun duration
            }
          }
        });
      }
    }
  });

  // Dash cooldown timer
  this.time.delayedCall(1000, () => { // Cooldown duration of 1 second
    playerStats.dashCooldown = false;
  });
}

function gainXp(amount) {
  playerStats.xp += amount;
  hud.updateXpBar(); // Update XP bar immediately

  if (playerStats.xp >= playerStats.xpToNextLevel) {
    playerStats.level++;
    playerStats.xp -= playerStats.xpToNextLevel; // Carry over excess XP
    playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.5); // Increase XP requirement
    playerStats.bulletDamage = parseFloat((playerStats.bulletDamage * 1.012).toFixed(2)); // Slight damage increase per level, keeping 2 decimal places for precision
    hud.updateXpBar(); // Update XP bar again for new level/goal

    const levelUpText = this.add.text(config.width / 2, config.height / 2 + 50, `LEVEL UP! Level ${playerStats.level}`, config.textStyles.levelUp).setOrigin(0.5);
    this.tweens.add({
      targets: levelUpText,
      alpha: 0,
      duration: 2500,
      ease: 'Power1',
      onComplete: () => levelUpText.destroy()
    });
  }
}

function spawnWeapons() {
    // Clear existing weapons to avoid clutter and ensure fresh spawns
    weapons.clear(true, true);

    const numWeaponsToSpawn = playerStats.increasedDropRate ? 3 : 2; // Increased drop rate if card is active

    for (let i = 0; i < numWeaponsToSpawn; i++) {
        const weaponKeys = Object.keys(weaponTypes);
        const randomWeaponType = Phaser.Utils.Array.GetRandom(weaponKeys);
        const weaponProps = weaponTypes[randomWeaponType];

        const x = Phaser.Math.Between(100, config.width - 100);
        const y = Phaser.Math.Between(100, config.height - 100);

        const weapon = weapons.create(x, y, weaponProps.texture);
        weapon.setScale(0.1);
        weapon.name = weaponProps.name; // Store name for display
        weapon.damage = weaponProps.damage;
        weapon.fireRate = weaponProps.fireRate;

        // Add a tween for a subtle floating effect
        this.tweens.add({
            targets: weapon,
            y: weapon.y + 10,
            duration: 800,
            ease: 'Sine.easeInOut',
            yoyo: true,
            repeat: -1
        });
    }
}

function pickupWeapon(weapon) {
    playerStats.bulletDamage = weapon.damage;
    playerStats.fireRate = weapon.fireRate;

    // Update HUD to reflect new weapon
    this.weaponNameText.setText(weapon.name);
    this.weaponImage.setTexture(weapon.texture);

    // Show pickup text
    const pickupText = this.add.text(weapon.x, weapon.y - 30, `+${weapon.name}!`, config.textStyles.pickup).setOrigin(0.5);
    this.tweens.add({
        targets: pickupText,
        y: pickupText.y - 50,
        alpha: 0,
        duration: 1000,
        ease: 'Power1',
        onComplete: () => pickupText.destroy()
    });

    weapon.destroy(); // Remove the picked up weapon
}

function updateCardsHUD(scene) {
    // Clear existing cards in HUD
    cardsHUDGroup.clear(true, true);

    const startX = 20;
    const startY = config.height - 100;
    const cardSpacing = 40;

    playerCards.forEach((card, index) => {
        const cardIcon = scene.add.text(startX + (index * cardSpacing), startY, '◈', {
            fontSize: '24px',
            color: '#FFFFFF',
            stroke: '#000000',
            strokeThickness: 2
        }).setOrigin(0, 0.5);

        // Optional: Add card name on hover
        cardIcon.setInteractive();
        cardIcon.on('pointerover', () => {
            // Check if hoverText exists before destroying to prevent errors
            const existingHoverText = scene.children.getByName('hoverText');
            if (existingHoverText) {
                existingHoverText.destroy();
            }
            scene.add.text(cardIcon.x, cardIcon.y - 20, card.name, { fontSize: '12px', color: '#FFF' }).setOrigin(0.5).setName('hoverText');
        });
        cardIcon.on('pointerout', () => {
            const existingHoverText = scene.children.getByName('hoverText');
            if (existingHoverText) {
                existingHoverText.destroy();
            }
        });

        cardsHUDGroup.add(cardIcon);
    });
}
</script>
</body>
</html>

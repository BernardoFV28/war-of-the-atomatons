<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons V1.5 - A Cruzada da Rainha</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0a0000ce;
    }
    canvas {
      display: block;
      margin: auto;
    }
  </style>

</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 1380,
  height: 580,
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: { debug: false }
  },
  scene: {
    preload,
    create,
    update
  }
};

let waveText;
let hudGroup;
let armaNomeText;
let armaImagem;
let player, cursors;
let bullets, enemies, enemyBullets, armas, itemsGroup;
let lastShoot = 0;
let score = 0;
let scoreText;
let healthText;
let playerHealth = 100;
let playerMaxHealth = 100; // New: Max health variable
let playerSpeed = 400; // New: Player speed variable
let playerDamage = 10; // New: Player base damage
let wave = 1;
let enemiesToSpawn = 5;
let enemiesKilledThisWave = 0;
let enemySpawnDelay = 1000;
let lastEnemySpawnTime = 0;
let gameOver = false;
let bossMode = false;
let bossHealthBar;
let bossHealthBarBackground;
let bossNameText;
let boss; // Declarar a variável boss globalmente

// New variables for Obstacles and Mechanics
let obstaclesGroup;
let powerUpGroup;
let cursedItemGroup; // For cursed items
let holographicClonesGroup; // For holographic clones

let killStreak = 0;
let comboText;
let frenzyActive = false;
let frenzyTimer;
let playerOriginalDamage; // To store original damage before frenzy
let playerOriginalTint; // To store original tint for visual feedback
let playerIsSlowed = false; // Flag to check if player is currently slowed
let playerSpeedRestoreTimer = null; // Timer for speed restoration

// Temporary effect display
let temporaryEffectText;
let temporaryEffectTimer;

// Player Inventory and Items (from your original code)
const playerInventory = {
  activableItems: {
    "Óculos de Visão Térmica": { count: 1, cooldown: 15000, lastUsed: 0, ready: true },
    "Módulo de Escudo": { count: 1, cooldown: 20000, lastUsed: 0, ready: true },
    "Circuito de Sobrecarga": { count: 1, cooldown: 25000, lastUsed: 0, ready: true },
    "DPE (Dispositivo de Posicionamento Espacial)": { count: 1, cooldown: 30000, lastUsed: 0, ready: true },
    "Ampola de Cura": { count: 1, cooldown: 10000, lastUsed: 0, ready: true },
    // New item for Holographic Clone
    "Projetor Holográfico": { count: 1, cooldown: 45000, lastUsed: 0, ready: true }
  },
  passiveItems: {}
};

const itemOptions = [
  { nome: "Óculos de Visão Térmica", tipo: "activable", hotkey: "Q" },
  { nome: "Módulo de Escudo", tipo: "activable", hotkey: "E" },
  { nome: "Circuito de Sobrecarga", tipo: "activable", hotkey: "R" },
  { nome: "DPE (Dispositivo de Posicionamento Espacial)", tipo: "activable", hotkey: "F" },
  { nome: "Ampola de Cura", tipo: "activable", hotkey: "G" },
  { nome: "Projetor Holográfico", tipo: "activable", hotkey: "T" }
];

// UI Class for Inventory Display
class InventoryUI {
  constructor(scene) {
      this.scene = scene;
      this.inventoryText = this.scene.add.text(10, config.height - 150, '', {
          fontSize: '16px',
          color: '#00FF00',
          backgroundColor: '#333333',
          padding: { x: 5, y: 5 }
      }).setScrollFactor(0).setDepth(100);

      this.inventoryText.setText('Inventário:\n');
      this.updateInventoryDisplay();
  }

  updateInventoryDisplay() {
      let inventoryDisplay = "Inventário:\n";
      let hasActivable = false;
      const time = this.scene.time.now;

      for (const itemKey in playerInventory.activableItems) {
          const itemData = playerInventory.activableItems[itemKey];
          if (itemData.count > 0) {
              hasActivable = true;
              let status = "";
              if (!itemData.ready) {
                  const remainingTime = Math.ceil((itemData.cooldown - (time - itemData.lastUsed)) / 1000);
                  status = ` (Recarga: ${remainingTime}s)`;
              } else {
                  status = " (PRONTO)";
              }
              const itemInfo = itemOptions.find(opt => opt.nome === itemKey);
              const hotkey = itemInfo ? ` (${itemInfo.hotkey})` : '';

              inventoryDisplay += `- ${itemKey}${hotkey}${status}\n`;
          }
      }
      if (!hasActivable) {
          inventoryDisplay += "Nenhum\n";
      }

      this.inventoryText.setText(inventoryDisplay);
  }

  displayTemporaryEffect(effectName, durationSeconds) {
    if (temporaryEffectText) {
        temporaryEffectText.destroy();
    }
    temporaryEffectText = this.scene.add.text(config.width / 2, config.height / 2 + 100, effectName, {
      fontSize: '32px',
      color: '#FFFF00',
      fontStyle: 'bold',
      shadow: {
        offsetX: 2,
        offsetY: 2,
        color: '#000000',
        blur: 4,
        stroke: true,
        fill: true
      }
    }).setOrigin(0.5).setDepth(100);

    if (temporaryEffectTimer) {
        temporaryEffectTimer.destroy();
    }
    temporaryEffectTimer = this.scene.time.delayedCall(durationSeconds * 1000, () => {
        if (temporaryEffectText) {
            temporaryEffectText.destroy();
            temporaryEffectText = null;
        }
    }, [], this.scene);
  }
}

let inventoryUI; // Instance of InventoryUI

function preload() {
    this.load.image('player', 'assets/player.png');
    this.load.image('bullet', 'assets/bullet.png');
    this.load.image('enemy', 'assets/enemy.png');
    this.load.image('enemyBullet', 'assets/enemy_bullet.png');
    this.load.image('pistol', 'assets/pistolinha.png');
    this.load.image('shotgun', 'assets/lancarraio.png');
    this.load.image('rifle', 'assets/rifle.png');
    this.load.image('laserGun', 'assets/laser_gun.png');
    this.load.image('plasmaGun', 'assets/plasma_gun.png');
    // New: Obstacle Assets
    this.load.image('scrapBlock', 'assets/scrap_block.png');
    this.load.image('electricCoil', 'assets/electric_coil.png');
    this.load.image('explosiveDrone', 'assets/explosive_drone.png');
    this.load.image('turret', 'assets/turret.png');
    this.load.image('magneticDistortion', 'assets/magnetic_distortion.png');
    // New: Power-up Assets
    this.load.image('powerUpSpeed', 'assets/powerup_speed.png');
    this.load.image('powerUpHealth', 'assets/powerup_health.png');
    this.load.image('powerUpShield', 'assets/powerup_shield.png');
    // New: Cursed Item Asset
    this.load.image('cursedItem', 'assets/cursed_item.png');
    // New: Holographic Clone Asset
    this.load.image('holographicClone', 'assets/holographic_clone.png');

    // Placeholder assets for now. Replace with actual cyberpunk assets.
    // You'll need to create these assets in an 'assets' folder in the same directory as your HTML.
}

function create() {
    // Player
    player = this.physics.add.sprite(config.width / 4, config.height / 2, 'player');
    player.setCollideWorldBounds(true);
    player.setOrigin(0.5);
    player.setDepth(5); // Player depth above obstacles

    cursors = this.input.keyboard.createCursorKeys();

    // Groups
    bullets = this.physics.add.group({
        defaultKey: 'bullet',
        maxSize: 30
    });
    enemies = this.physics.add.group();
    enemyBullets = this.physics.add.group();
    armas = this.physics.add.group();
    itemsGroup = this.physics.add.group(); // This group is likely for drops from enemies

    // New groups for obstacles and mechanics
    obstaclesGroup = this.physics.add.group();
    powerUpGroup = this.physics.add.group();
    cursedItemGroup = this.physics.add.group();
    holographicClonesGroup = this.physics.add.group();

    // HUD
    scoreText = this.add.text(10, 10, 'Score: 0', { fontSize: '20px', fill: '#FFF' }).setScrollFactor(0);
    healthText = this.add.text(10, 30, `Health: ${playerHealth}/${playerMaxHealth}`, { fontSize: '20px', fill: '#FFF' }).setScrollFactor(0);
    waveText = this.add.text(config.width - 150, 10, 'Wave: 1', { fontSize: '20px', fill: '#FFF' }).setScrollFactor(0);

    // Combo Text
    comboText = this.add.text(config.width / 2, 50, 'Combo: 0', {
        fontSize: '24px',
        fill: '#FFD700', // Gold color
        fontStyle: 'bold',
        shadow: { offsetX: 2, offsetY: 2, color: '#000000', blur: 4, stroke: true, fill: true }
    }).setOrigin(0.5).setScrollFactor(0).setDepth(100).setVisible(false); // Hidden initially

    // Initialize Inventory UI
    inventoryUI = new InventoryUI(this);

    // Initial Spawns
    spawnEnemies();
    spawnObstacles(wave); // Spawn initial obstacles for Wave 1 (will be empty unless wave >= 2)

    // Collisions
    this.physics.add.collider(bullets, enemies, hitEnemy, null, this);
    this.physics.add.overlap(player, enemies, hitPlayer, null, this);
    this.physics.add.overlap(player, enemyBullets, hitPlayer, null, this);
    this.physics.add.overlap(player, armas, pickUpArma, null, this);
    this.physics.add.overlap(player, itemsGroup, pickUpItem, null, this); // For general drops

    // New Collisions for Obstacles and Mechanics
    this.physics.add.collider(bullets, obstaclesGroup, hitObstacle, null, this); // Bullets hit obstacles
    this.physics.add.collider(player, obstaclesGroup, playerHitObstacle, null, this); // Player hit obstacles
    this.physics.add.collider(enemyBullets, obstaclesGroup, hitObstacle, null, this); // Enemy bullets hit obstacles
    this.physics.add.overlap(player, powerUpGroup, pickUpPowerUp, null, this);
    this.physics.add.overlap(player, cursedItemGroup, pickUpCursedItem, null, this);
    // Holographic clone collision - enemies should target it but it won't take damage in the traditional sense
    this.physics.add.collider(holographicClonesGroup, enemies, (clone, enemy) => {
        // Enemies will be distracted by the clone. No damage to clone.
        // You can add logic here for enemy behavior if they hit the clone, e.g., brief stun or re-target.
    }, null, this);

    // Keyboard controls for activable items
    this.input.keyboard.on('keydown-Q', () => useActivableItem("Óculos de Visão Térmica", this));
    this.input.keyboard.on('keydown-E', () => useActivableItem("Módulo de Escudo", this));
    this.input.keyboard.on('keydown-R', () => useActivableItem("Circuito de Sobrecarga", this));
    this.input.keyboard.on('keydown-F', () => useActivableItem("DPE (Dispositivo de Posicionamento Espacial)", this));
    this.input.keyboard.on('keydown-G', () => useActivableItem("Ampola de Cura", this));
    this.input.keyboard.on('keydown-T', () => useActivableItem("Projetor Holográfico", this));

    // Store original player damage
    playerOriginalDamage = playerDamage;
    playerOriginalTint = player.tint;
}

function update(time, delta) {
    if (gameOver) {
        return;
    }

    // Player Movement
    player.setVelocity(0);
    if (cursors.left.isDown) {
        player.setVelocityX(-playerSpeed);
    } else if (cursors.right.isDown) {
        player.setVelocityX(playerSpeed);
    }
    if (cursors.up.isDown) {
        player.setVelocityY(-playerSpeed);
    } else if (cursors.down.isDown) {
        player.setVelocityY(playerSpeed);
    }

    // Player Shooting (simplified for example, assume 'Space' to shoot)
    if (Phaser.Input.Keyboard.JustDown(this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE)) && time > lastShoot) {
        shootBullet(player.x, player.y);
        lastShoot = time + 200; // Cooldown of 200ms
    }

    // Enemy AI and Spawning
    enemies.children.each(function(enemy) {
        if (enemy.active) {
            // Simple enemy movement: move towards player or clone if active
            if (holographicClonesGroup.getLength() > 0) {
                // If a clone exists, make enemies target the closest one for distraction
                const closestClone = this.physics.closest(enemy, holographicClonesGroup.getChildren());
                if (closestClone) {
                    this.physics.moveToObject(enemy, closestClone, enemy.speed);
                } else {
                     this.physics.moveToObject(enemy, player, enemy.speed);
                }
            } else {
                this.physics.moveToObject(enemy, player, enemy.speed);
            }


            // Simple enemy shooting
            if (time > enemy.lastShotTime + enemy.fireRate) {
                // Enemies shoot at their current target (player or clone)
                let target = player;
                if (holographicClonesGroup.getLength() > 0) {
                    const closestClone = this.physics.closest(enemy, holographicClonesGroup.getChildren());
                    if (closestClone) {
                        target = closestClone;
                    }
                }
                shootEnemyBullet(enemy.x, enemy.y, target);
                enemy.lastShotTime = time;
            }
        }
    }, this);

    // Boss health bar update (if boss mode is active)
    if (bossMode && bossHealthBar && bossHealthBarBackground && boss && boss.active) {
        bossHealthBar.width = (boss.health / boss.maxHealth) * bossHealthBarBackground.width;
    }

    // Wave progression and enemy spawning
    if (enemiesKilledThisWave >= enemiesToSpawn && !bossMode) {
        startNextWave();
    } else if (!bossMode && time > lastEnemySpawnTime + enemySpawnDelay && enemies.countActive(true) < enemiesToSpawn) {
        spawnEnemies();
        lastEnemySpawnTime = time;
    }

    // Update inventory display (for cooldowns)
    inventoryUI.updateInventoryDisplay();

    // Update combo text visibility
    if (killStreak > 0) {
        comboText.setVisible(true);
        comboText.setText(`Combo: ${killStreak}`);
        if (killStreak >= 15 && !frenzyActive) { // Activate frenzy if 15+ combo and not already active
            activateFrenzy.call(this);
        }
    } else {
        comboText.setVisible(false);
    }
}

function shootBullet(x, y) {
    const bullet = bullets.get(x, y);
    if (bullet) {
        bullet.setActive(true).setVisible(true);
        bullet.setVelocityX(400);
        bullet.setTint(frenzyActive ? 0xFFD700 : 0xFFFFFF); // Yellow tint for frenzy bullets
    }
}

function shootEnemyBullet(x, y, target) {
    const enemyBullet = enemyBullets.get(x, y);
    if (enemyBullet) {
        enemyBullet.setActive(true).setVisible(true);
        this.physics.moveToObject(enemyBullet, target, 150); // Enemy bullets move towards player or clone
    }
}

function hitEnemy(bullet, enemy) {
    bullet.setActive(false).setVisible(false);
    enemy.health -= playerDamage; // Use playerDamage
    if (enemy.health <= 0) {
        enemy.destroy();
        score += 100;
        scoreText.setText('Score: ' + score);
        enemiesKilledThisWave++;
        killStreak++; // Increment kill streak
        dropPowerUp(enemy.x, enemy.y); // Chance to drop power-up
        dropCursedItem(enemy.x, enemy.y); // Chance to drop cursed item
    } else {
        // If enemy is hit but not destroyed, reset kill streak if player has taken damage recently
        // For simplicity, kill streak only resets on player damage, not just any hit.
    }
}

function hitPlayer(player, target) {
    // If player has a shield, ignore damage
    if (player.immune) {
        // Visual feedback for shield hit
        this.add.tween({
            targets: player,
            alpha: { from: 0.5, to: 0.8 },
            ease: 'Sine.easeInOut',
            duration: 100,
            yoyo: true,
            repeat: 0
        });
        target.destroy();
        return;
    }

    let damageTaken = 10;
    if (player.damageMultiplier) { // Apply cursed item damage multiplier
        damageTaken *= player.damageMultiplier;
    }

    target.destroy();
    playerHealth -= damageTaken;
    healthText.setText(`Health: ${Math.max(0, playerHealth)}/${playerMaxHealth}`); // Ensure health doesn't go below 0
    killStreak = 0; // Reset kill streak on player hit
    if (frenzyActive) {
        deactivateFrenzy(); // Deactivate frenzy on hit
    }

    if (playerHealth <= 0) {
        endGame(this);
    }
}

function pickUpArma(player, arma) {
    // Implement weapon pickup logic (not detailed in this request but good to keep)
    arma.destroy();
    // Update player weapon, change shooting behavior, etc.
}

function pickUpItem(player, item) {
    // General item pickup logic (e.g., from enemies)
    item.destroy();
    // Apply item effects
}

// New Obstacle Collision Handlers
function hitObstacle(projectile, obstacle) {
    // For explosive drones, bullets detonate them
    if (obstacle.getData('type') === 'explosiveDrone') {
        obstacle.health -= projectile.getData('damage') || 10; // Use bullet damage
        if (obstacle.health <= 0) {
            obstacle.detonate();
        }
    }
    projectile.setActive(false).setVisible(false); // Bullets are destroyed on contact with obstacles
    // Add particle effect or sound for impact if desired
}

function playerHitObstacle(player, obstacle) {
    // For static obstacles, just prevent movement or apply specific effects
    if (obstacle.getData('type') === 'explosiveDrone') {
        obstacle.detonate(); // Custom method for explosive drone
    } else if (obstacle.getData('type') === 'electricCoil') {
        applySlowEffect(player, 3); // Apply slow for 3 seconds
    }
    // Prevent player from moving through solid obstacles by making them immovable
    // and using Phaser's default collider behavior.
    // No direct velocity change needed here if using collider.
}

// Obstacle Spawning
function spawnObstacles(wave) {
    // Clear existing obstacles before spawning new ones for the wave
    obstaclesGroup.clear(true, true);

    const obstacleTypes = [];
    if (wave >= 2) {
        obstacleTypes.push('scrapBlock');
    }
    if (wave >= 4) {
        obstacleTypes.push('electricCoil');
    }
    if (wave >= 6) {
        obstacleTypes.push('explosiveDrone');
    }
    if (wave >= 8) {
        obstacleTypes.push('turret');
    }
    if (wave >= 10) {
        obstacleTypes.push('magneticDistortion');
    }

    if (obstacleTypes.length === 0) {
        return; // No obstacles for this wave
    }

    // Determine number of obstacles based on wave
    const numObstacles = Math.min(Math.floor(wave / 2) + 1, 10 + Math.floor(wave / 5)); // Increase max obstacles gradually

    for (let i = 0; i < numObstacles; i++) {
        const type = Phaser.Utils.Array.GetRandom(obstacleTypes);
        let obstacle;

        // Random position, avoiding player spawn area and keeping within game bounds
        // Also try to avoid placing directly on top of other obstacles (simple retry logic)
        let x, y;
        let attempts = 0;
        const minDistance = 100; // Minimum distance between obstacles
        do {
            x = Phaser.Math.Between(config.width * 0.4, config.width * 0.9); // Spawn mostly on the right side
            y = Phaser.Math.Between(config.height * 0.1, config.height * 0.9);
            let tooClose = false;
            obstaclesGroup.children.each(existingObstacle => {
                if (Phaser.Math.Distance.Between(x, y, existingObstacle.x, existingObstacle.y) < minDistance) {
                    tooClose = true;
                }
            });
            if (!tooClose) break;
            attempts++;
        } while (attempts < 10); // Limit attempts to prevent infinite loop if space is too constrained


        switch (type) {
            case 'scrapBlock':
                obstacle = obstaclesGroup.create(x, y, 'scrapBlock');
                obstacle.setImmovable(true);
                obstacle.setDepth(2); // Below enemies, above background
                obstacle.setData('type', 'scrapBlock');
                obstacle.body.setSize(obstacle.width * 0.8, obstacle.height * 0.8); // Adjust collider size
                break;
            case 'electricCoil':
                obstacle = obstaclesGroup.create(x, y, 'electricCoil');
                obstacle.setImmovable(true);
                obstacle.setDepth(2);
                obstacle.setData('type', 'electricCoil');
                obstacle.body.setSize(obstacle.width * 0.7, obstacle.height * 0.7); // Adjust collider size
                // Add an update loop for electric coils to emit pulses
                this.time.addEvent({
                    delay: 3000, // Every 3 seconds
                    callback: () => emitElectricPulse.call(this, obstacle), // Use call for context
                    loop: true,
                    callbackScope: this
                });
                break;
            case 'explosiveDrone':
                obstacle = obstaclesGroup.create(x, y, 'explosiveDrone');
                obstacle.setImmovable(true);
                obstacle.setDepth(2);
                obstacle.setData('type', 'explosiveDrone');
                obstacle.health = 50 + (wave * 5); // Drones get tougher
                obstacle.detonate = function() {
                    // Visual/Audio feedback for explosion
                    const explosion = this.scene.add.circle(this.x, this.y, 50, 0xFF0000, 0.5); // Red circle for explosion
                    this.scene.tweens.add({
                        targets: explosion,
                        radius: 100,
                        alpha: 0,
                        ease: 'Quart.easeOut',
                        duration: 300,
                        onComplete: () => explosion.destroy()
                    });

                    // Damage player if within radius
                    const distanceToPlayer = Phaser.Math.Distance.Between(player.x, player.y, this.x, this.y);
                    if (distanceToPlayer < 150) { // Explosion radius
                        let damage = 20 + (wave * 2); // Damage scales with wave
                        if (player.immune) { // Check for shield
                            // Shield absorbs damage, provide feedback
                            this.scene.add.tween({
                                targets: player,
                                alpha: { from: 0.5, to: 0.8 },
                                ease: 'Sine.easeInOut',
                                duration: 100,
                                yoyo: true,
                                repeat: 0
                            });
                        } else {
                            if (player.damageMultiplier) damage *= player.damageMultiplier; // Apply cursed item damage multiplier
                            playerHealth -= damage;
                            healthText.setText(`Health: ${Math.max(0, playerHealth)}/${playerMaxHealth}`);
                            killStreak = 0; // Reset combo on damage
                            if (frenzyActive) deactivateFrenzy();
                            if (playerHealth <= 0) endGame(this.scene);
                        }
                    }
                    this.destroy(); // Remove drone after detonation
                };
                // Collision with bullets will also apply damage to it
                this.physics.add.collider(bullets, obstacle, (bullet, drone) => {
                    bullet.destroy();
                    drone.health -= playerDamage; // Player damage applies to drone
                    if (drone.health <= 0) {
                        drone.detonate();
                    }
                }, null, this);
                break;
            case 'turret':
                obstacle = obstaclesGroup.create(x, y, 'turret');
                obstacle.setImmovable(true);
                obstacle.setDepth(2);
                obstacle.setData('type', 'turret');
                obstacle.fireRate = Phaser.Math.Between(1500, 3000) - (wave * 50); // Turret fire rate
                if (obstacle.fireRate < 500) obstacle.fireRate = 500;
                obstacle.lastShotTime = 0;
                // Add a periodic event for turrets to shoot
                this.time.addEvent({
                    delay: obstacle.fireRate,
                    callback: () => shootTurretBullet.call(this, obstacle),
                    loop: true,
                    callbackScope: this
                });
                break;
            case 'magneticDistortion':
                obstacle = obstaclesGroup.create(x, y, 'magneticDistortion');
                obstacle.setImmovable(true);
                obstacle.setDepth(2);
                obstacle.setData('type', 'magneticDistortion');
                obstacle.setCircle(50); // Set a circular body for magnetic effect
                // Add an overlap for projectiles to be affected by distortion
                this.physics.add.overlap(bullets, obstacle, deflectProjectile, null, this);
                this.physics.add.overlap(enemyBullets, obstacle, deflectProjectile, null, this); // Enemy bullets also affected
                break;
        }
    }
}

function emitElectricPulse(coil) {
    if (!coil.active) return; // Ensure coil is still active

    // Visual for pulse (e.g., expanding circle or glow)
    const pulse = this.add.circle(coil.x, coil.y, 10, 0x00FFFF, 0.3); // Cyan pulse
    this.tweens.add({
        targets: pulse,
        radius: 150,
        alpha: 0,
        ease: 'Quart.easeOut',
        duration: 1000,
        onComplete: () => pulse.destroy()
    });

    // Check for player overlap with pulse area
    const distanceToPlayer = Phaser.Math.Distance.Between(player.x, player.y, coil.x, coil.y);
    if (distanceToPlayer < 150) { // Radius of slow effect
        applySlowEffect.call(this, player, 2); // Apply slow for 2 seconds
    }
}

function applySlowEffect(target, duration) {
    if (playerIsSlowed) { // Prevent stacking slow effects
        if (playerSpeedRestoreTimer) {
            playerSpeedRestoreTimer.remove(false); // Reset timer
        }
    } else {
        playerIsSlowed = true;
        const originalSpeed = playerSpeed; // Store original speed
        playerSpeed *= 0.5; // Halve player speed
    }

    inventoryUI.displayTemporaryEffect(".", duration); // Show effect text

    playerSpeedRestoreTimer = this.time.delayedCall(duration * 1000, () => {
        playerSpeed = originalPlayerSpeed; // Restore original speed
        playerIsSlowed = false;
        playerSpeedRestoreTimer = null;
    }, [], this);
}

function shootTurretBullet(turret) {
    if (!turret.active) return; // Don't shoot if turret is destroyed

    const bullet = enemyBullets.get(turret.x, turret.y);
    if (bullet) {
        bullet.setActive(true).setVisible(true);
        // Turrets shoot at the player's current position
        this.physics.moveToObject(bullet, player, 200 + (wave * 5)); // Turret bullets get faster
        bullet.setTint(0xFF8C00); // Orange tint for turret bullets
    }
}

function deflectProjectile(projectile, distortionZone) {
    if (!projectile.active) return;

    // Calculate a new velocity to "deflect" the projectile
    // Simple deflection: apply a force outwards from the center of the distortion zone
    const angleToDistortion = Phaser.Math.Angle.Between(distortionZone.x, distortionZone.y, projectile.x, projectile.y);
    const deflectionForce = 150; // How strongly to deflect

    // Calculate new velocity components
    const newVx = Math.cos(angleToDistortion) * deflectionForce;
    const newVy = Math.sin(angleToDistortion) * deflectionForce;

    // Apply the deflection velocity while trying to retain some of the original speed
    // This makes it less abrupt.
    const currentSpeed = Phaser.Math.Distance.Between(0, 0, projectile.body.velocity.x, projectile.body.velocity.y);
    const combinedVx = projectile.body.velocity.x * 0.5 + newVx * 0.5;
    const combinedVy = projectile.body.velocity.y * 0.5 + newVy * 0.5;

    // Normalize and re-apply speed
    const combinedSpeed = Phaser.Math.Distance.Between(0, 0, combinedVx, combinedVy);
    if (combinedSpeed > 0) {
        projectile.setVelocity(
            (combinedVx / combinedSpeed) * currentSpeed,
            (combinedVy / combinedSpeed) * currentSpeed
        );
    } else {
        // If combined speed is zero, just apply the deflection force
        projectile.setVelocity(newVx, newVy);
    }

    projectile.setTint(0x00FF00); // Green tint for deflected bullets
}

// Frenzy Mode
function activateFrenzy() {
    if (frenzyActive) return; // Prevent multiple activations

    frenzyActive = true;
    playerDamage *= 2; // Double player damage
    player.setTint(0xFFD700); // Yellow tint for player
    inventoryUI.displayTemporaryEffect("FRENESI ", 10); // Show effect text

    frenzyTimer = this.time.delayedCall(10000, deactivateFrenzy, [], this); // 10 seconds duration
}

function deactivateFrenzy() {
    if (!frenzyActive) return;

    frenzyActive = false;
    playerDamage = playerOriginalDamage; // Restore original damage
    player.setTint(playerOriginalTint); // Restore original tint
    if (frenzyTimer) {
        frenzyTimer.remove(false); // Stop the timer if it's still running
        frenzyTimer = null;
    }
}

// Power-ups
function dropPowerUp(x, y) {
    // 20% chance to drop a power-up
    if (Math.random() < 0.2) {
        const powerUpTypes = ['speed', 'health', 'shield'];
        const type = Phaser.Utils.Array.GetRandom(powerUpTypes);
        let powerUp;

        switch (type) {
            case 'speed':
                powerUp = powerUpGroup.create(x, y, 'powerUpSpeed');
                break;
            case 'health':
                powerUp = powerUpGroup.create(x, y, 'powerUpHealth');
                break;
            case 'shield':
                powerUp = powerUpGroup.create(x, y, 'powerUpShield');
                break;
        }
        powerUp.setData('type', type);
        powerUp.setDepth(6); // Above player
        powerUp.setVelocityY(50); // Drop down slowly
        powerUp.setCollideWorldBounds(true);
        powerUp.setBounceY(0.5); // Bounce slightly
    }
}

function pickUpPowerUp(player, powerUp) {
    powerUp.destroy();
    const type = powerUp.getData('type');
    let effectDuration = 10; // Default duration

    switch (type) {
        case 'speed':
            const originalPlayerSpeed = playerSpeed;
            playerSpeed *= 1.5; // 50% speed increase
            inventoryUI.displayTemporaryEffect(".", effectDuration);
            this.time.delayedCall(effectDuration * 1000, () => {
                playerSpeed = originalPlayerSpeed;
            }, [], this);
            break;
        case 'health':
            playerHealth = Math.min(playerMaxHealth, playerHealth + 30); // Heal 30, up to max
            healthText.setText(`Health: ${playerHealth}/${playerMaxHealth}`);
            inventoryUI.displayTemporaryEffect(".", 1); // Short display
            break;
        case 'shield':
            player.setAlpha(0.5); // Visual for shield
            player.immune = true; // Make player immune to damage
            inventoryUI.displayTemporaryEffect(".", effectDuration);
            this.time.delayedCall(effectDuration * 1000, () => {
                player.setAlpha(1);
                player.immune = false;
            }, [], this);
            break;
    }
}

// Cursed Items
function dropCursedItem(x, y) {
    // 5% chance to drop a cursed item
    if (Math.random() < 0.05) {
        const cursedItem = cursedItemGroup.create(x, y, 'cursedItem');
        cursedItem.setData('type', 'random'); // Can be specific types if needed
        cursedItem.setDepth(6);
        cursedItem.setVelocityY(50);
        cursedItem.setTint(0x8B0000); // Dark red tint
    }
}

function pickUpCursedItem(player, cursedItem) {
    cursedItem.destroy();
    const cursedEffects = [
        { name: ".", effect: () => { playerMaxHealth = Math.max(50, playerMaxHealth - 20); playerHealth = Math.min(playerHealth, playerMaxHealth); healthText.setText(`Health: ${playerHealth}/${playerMaxHealth}`); } },
        { name: ".", effect: () => { player.damageMultiplier = 1.5; }, revert: () => { player.damageMultiplier = 1; } }, // Player takes 50% more damage
        { name: ".", effect: () => { playerSpeed *= 0.7; }, revert: () => { playerSpeed /= 0.7; } }
    ];

    const chosenEffect = Phaser.Utils.Array.GetRandom(cursedEffects);
    chosenEffect.effect();
    inventoryUI.displayTemporaryEffect(chosenEffect.name, 10); // Display for 10 seconds

    if (chosenEffect.revert) {
        this.time.delayedCall(10000, chosenEffect.revert, [], this);
    }
}

// Holographic Clone Item Usage
function createHolographicClone() {
    const clone = holographicClonesGroup.create(player.x - 50, player.y, 'holographicClone'); // Spawn slightly to the left
    clone.setDepth(4); // Below player, above obstacles
    clone.setAlpha(0.6); // Semi-transparent
    clone.setImmovable(true); // Doesn't move with physics interactions
    clone.health = 1000; // High health so it doesn't die instantly, but can be "destroyed" after duration
    clone.isClone = true; // Custom property to identify it as a clone

    // Clone behavior: briefly distract enemies by making them target the clone
    enemies.children.each(enemy => {
        if (enemy.active && enemy.body) {
            enemy.targetOverride = clone; // Temporary target
        }
    });

    // Remove clone after 5 seconds
    this.time.delayedCall(5000, () => {
        clone.destroy();
        // Revert enemy targets to player
        enemies.children.each(enemy => {
            if (enemy.active && enemy.body && enemy.targetOverride === clone) {
                delete enemy.targetOverride; // Remove temporary target override
            }
        });
    }, [], this);
}


function spawnEnemies() {
    let enemyCount = Math.floor(wave * 1.5); // More enemies per wave
    for (let i = 0; i < enemyCount; i++) {
        const x = Phaser.Math.Between(config.width * 0.7, config.width * 0.95);
        const y = Phaser.Math.Between(50, config.height - 50);
        let enemy = enemies.create(x, y, 'enemy');
        enemy.setCollideWorldBounds(true);
        enemy.setBounce(1);
        enemy.setVelocity(Phaser.Math.Between(-100, 100), Phaser.Math.Between(-100, 100));
        enemy.health = 30 + (wave * 5); // Enemies get tougher
        enemy.speed = 100 + (wave * 5); // Enemies get faster
        enemy.fireRate = 2000 - (wave * 50); // Enemies shoot faster (min 500ms)
        if (enemy.fireRate < 500) enemy.fireRate = 500;
        enemy.lastShotTime = 0;
        enemy.setDepth(3); // Enemies above obstacles
    }
}

function startNextWave() {
    wave++;
    waveText.setText('Wave: ' + wave);
    enemiesToSpawn = Math.floor(5 + (wave * 2.5)); // Increase enemies per wave more
    enemiesKilledThisWave = 0;
    enemySpawnDelay = Math.max(500, 1000 - (wave * 50)); // Decrease spawn delay
    lastEnemySpawnTime = this.time.now;

    // Mini-Boss at every 3rd wave
    if (wave % 3 === 0) {
        spawnMiniBoss.call(this, wave);
    } else {
        spawnEnemies(); // Spawn regular enemies if not a mini-boss wave
    }

    spawnObstacles.call(this, wave); // Spawn new obstacles for the new wave
}

function spawnMiniBoss(currentWave) {
    bossMode = true;
    enemies.clear(true, true); // Clear existing regular enemies

    const miniBoss = this.physics.add.sprite(config.width * 0.8, config.height / 2, 'enemy'); // Use enemy sprite for now
    miniBoss.setCollideWorldBounds(true);
    miniBoss.setBounce(1);
    miniBoss.setVelocity(-50, 0); // Slower movement
    miniBoss.health = 200 + (currentWave * 20); // Much more health
    miniBoss.maxHealth = miniBoss.health;
    miniBoss.speed = 80 + (currentWave * 5);
    miniBoss.fireRate = 1000 - (currentWave * 20);
    if (miniBoss.fireRate < 300) miniBoss.fireRate = 300;
    miniBoss.lastShotTime = 0;
    miniBoss.setTint(0xFF0000); // Red tint for mini-boss
    miniBoss.setScale(1.5); // Larger size
    miniBoss.setDepth(3);

    // Make the boss part of the enemies group for collision detection
    enemies.add(miniBoss);

    boss = miniBoss; // Assign to global boss variable

    // Create Boss Health Bar
    bossHealthBarBackground = this.add.graphics();
    bossHealthBarBackground.fillStyle(0x000000, 0.5);
    bossHealthBarBackground.fillRect(config.width / 2 - 150, 20, 300, 20);
    bossHealthBarBackground.setDepth(101).setScrollFactor(0);

    bossHealthBar = this.add.graphics();
    bossHealthBar.fillStyle(0xFF0000, 1);
    bossHealthBar.fillRect(config.width / 2 - 150, 20, 300, 20);
    bossHealthBar.setDepth(102).setScrollFactor(0);

    bossNameText = this.add.text(config.width / 2, 45, 'MINI-CHEFE', {
        fontSize: '18px',
        fill: '#FF0000',
        fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(103).setScrollFactor(0);

    // Override hitEnemy for boss specific logic
    this.physics.add.collider(bullets, boss, hitBoss, null, this);
}

function hitBoss(bullet, boss) {
    bullet.setActive(false).setVisible(false);
    boss.health -= playerDamage; // Use playerDamage
    if (boss.health <= 0) {
        boss.destroy();
        score += 5000; // Big score for boss kill
        scoreText.setText('Score: ' + score);
        bossMode = false; // End boss mode
        // Clean up boss health bar
        if (bossHealthBar) bossHealthBar.destroy();
        if (bossHealthBarBackground) bossHealthBarBackground.destroy();
        if (bossNameText) bossNameText.destroy();
        // Start next wave after boss
        startNextWave.call(this);
    }
}

function useActivableItem(itemName, scene) {
  const itemData = playerInventory.activableItems[itemName];
  const time = scene.time.now;

  if (itemData && itemData.count > 0 && itemData.ready) {
      itemData.ready = false;
      itemData.lastUsed = time;

      // Apply item effect
      switch (itemName) {
          case "Óculos de Visão Térmica":
              inventoryUI.displayTemporaryEffect(".", 5);
              // Implement visual effect for thermal vision (e.g., tinting screen, highlighting enemies)
              // For simplicity, just display text
              break;
          case "Módulo de Escudo":
              player.setAlpha(0.5); // Visual for shield
              player.immune = true; // Make player immune to damage
              inventoryUI.displayTemporaryEffect(".", 5);
              scene.time.delayedCall(5000, () => {
                  player.setAlpha(1);
                  player.immune = false;
              }, [], scene);
              break;
          case "Circuito de Sobrecarga":
              const originalDamage = playerDamage;
              playerDamage *= 2.5; // Huge damage boost
              inventoryUI.displayTemporaryEffect(".", 3);
              scene.time.delayedCall(3000, () => {
                  playerDamage = originalDamage;
              }, [], scene);
              break;
          case "DPE (Dispositivo de Posicionamento Espacial)":
              // Teleport player to a random safe spot
              const newX = Phaser.Math.Between(player.x - 100, player.x + 100);
              const newY = Phaser.Math.Between(player.y - 100, player.y + 100);
              player.setPosition(newX, newY);
              inventoryUI.displayTemporaryEffect(".", 1);
              break;
          case "Ampola de Cura":
              playerHealth = Math.min(playerMaxHealth, playerHealth + 50); // Heal 50 health
              healthText.setText(`Health: ${playerHealth}/${playerMaxHealth}`);
              inventoryUI.displayTemporaryEffect(".", 1);
              break;
          case "Projetor Holográfico":
                createHolographicClone.call(scene); // Call the new clone function
                inventoryUI.displayTemporaryEffect(".", 5);
                break;
      }

      // Start cooldown timer
      scene.time.delayedCall(itemData.cooldown, () => {
          itemData.ready = true;
          inventoryUI.updateInventoryDisplay(); // Update display once ready
      }, [], scene);
  } else if (itemData && !itemData.ready) {
      const remainingTime = Math.ceil((itemData.cooldown - (time - itemData.lastUsed)) / 1000);
      inventoryUI.displayTemporaryEffect(`${itemName} em Recarga: ${remainingTime}s`, 1);
  }
}

function endGame(scene) {
    gameOver = true;
    player.setTint(0xff0000); // Red tint for game over
    scene.physics.pause();

    scene.add.text(config.width / 2, config.height / 2, 'GAME OVER', {
        fontSize: '64px',
        fill: '#FF0000',
        fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(200);

    scene.add.text(config.width / 2, config.height / 2 + 70, `Score Final: ${score}`, {
        fontSize: '32px',
        fill: '#FFFFFF'
    }).setOrigin(0.5).setDepth(200);

    // Optional: Restart game on click
    scene.input.once('pointerdown', () => {
        scene.scene.restart();
        resetGameVariables();
    });
}

function resetGameVariables() {
    playerHealth = 100;
    playerMaxHealth = 100;
    playerSpeed = 400;
    playerDamage = 10;
    score = 0;
    wave = 1;
    enemiesToSpawn = 5;
    enemiesKilledThisWave = 0;
    enemySpawnDelay = 1000;
    lastEnemySpawnTime = 0;
    gameOver = false;
    bossMode = false;
    if (bossHealthBar) bossHealthBar.destroy();
    if (bossHealthBarBackground) bossHealthBarBackground.destroy();
    if (bossNameText) bossNameText.destroy();
    killStreak = 0;
    frenzyActive = false;
    if (frenzyTimer) {
        frenzyTimer.remove(false);
        frenzyTimer = null;
    }
    playerOriginalDamage = 10; // Reset to initial
    playerOriginalTint = 0xFFFFFF; // Reset to white (default)
    playerIsSlowed = false;
    if (playerSpeedRestoreTimer) {
        playerSpeedRestoreTimer.remove(false);
        playerSpeedRestoreTimer = null;
    }

    // Reset activable item cooldowns
    for (const itemKey in playerInventory.activableItems) {
        playerInventory.activableItems[itemKey].ready = true;
        playerInventory.activableItems[itemKey].lastUsed = 0;
    }
}

const game = new Phaser.Game(config);
</script>
</body>
</html>

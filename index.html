<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons - Dungeon Floor (CORRIGIDO)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000008c7; font-family: 'Arial', sans-serif; }
    canvas { display: block; margin: auto; }
    
    /* Estilos de UI e Menus */
    .menu-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: flex; justify-content: center; align-items: center; z-index: 1000; color: #FFF; }
    .menu-container { background-color: #222; border: 2px solid #555; padding: 20px; border-radius: 12px; text-align: center; width: 90%; max-width: 900px; box-shadow: 0 0 25px #00FFFF; }
    .menu-title { font-size: 40px; margin-bottom: 20px; color: #00FFFF; text-transform: uppercase; }
    
    /* Botões */
    .btn { background-color: #008CBA; color: white; padding: 12px 25px; border: none; border-radius: 6px; cursor: pointer; font-size: 18px; font-weight: bold; margin: 10px; transition: background-color 0.2s, transform 0.1s; }
    .btn:hover { background-color: #005f7f; transform: scale(1.05); }
    .btn-disabled { background-color: #555; cursor: not-allowed; }

    /* Skill Tree */
    .skill-tree { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-top: 20px; }
    .skill-card { background-color: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px; text-align: center; }
    .skill-title { font-size: 18px; color: #FFD700; margin-bottom: 5px; }
    .skill-level { font-size: 14px; color: #aaa; margin-bottom: 10px; }
    .skill-cost { font-size: 16px; color: #FFF; font-weight: bold; }
  </style>
</head>
<body>
<script>

// ==================================================================================================
// --- 1. CONFIGURAÇÕES E DADOS GLOBAIS ---
// ==================================================================================================

const ORIGINAL_SCALES = {
    PLAYER: 0.08,
    BULLET: 0.01,
    GEM: 0.04
};

const GAME_CONFIG = {
    PLAYER: {
        SPEED: 300,
        MAX_HP: 3,
        MAGNET: 150,
        DASH: { DIST: 300, CD: 3000 }
    },
    LIMITS: {
        MAX_ENEMIES_ON_SCREEN: 50, 
        MAX_GEMS: 60
    },
    WAVE: {
        START_COUNT: 15,
        INC_PER_WAVE: 5,
        SPAWN_DELAY: 1000
    }
};

const enemyTypes = {
  normal: { texture: 'enemy_robot', baseHealth: 4, speed: 100, scale: 0.06, xpValue: 5, chance: 1.0 },
  fast: { texture: 'enemy_fast', baseHealth: 3, speed: 200, scale: 0.06, xpValue: 8, minWave: 3, chance: 0.3 },
  tank: { texture: 'enemy_tank', baseHealth: 15, speed: 50, scale: 0.08, xpValue: 15, minWave: 5, chance: 0.2 }
};

const SKILL_TREE = {
    DanoBase: {
        name: "Dano Base",
        desc: (level) => `Aumenta o dano inicial em ${level * 10}% (Atual: ${(level + 1) * 10}%).`,
        maxLevel: 5,
        cost: (level) => 100 + level * 75,
        effectKey: 'damageMult',
        defaultStat: 1,
        applier: (stat, level) => stat + (level * 0.1),
        dependsOn: null,
    },
    TaxaDeTiro: {
        name: "Taxa de Tiro",
        desc: (level) => `Reduz o tempo entre tiros em ${level * 5}ms (Atual: ${level * 5}ms).`,
        maxLevel: 4,
        cost: (level) => 150 + level * 100,
        effectKey: 'fireRateReduction',
        defaultStat: 0,
        applier: (stat, level) => stat + (level * 5),
        dependsOn: 'DanoBase',
    },
    VidaMaxima: {
        name: "Vida Máxima",
        desc: (level) => `Aumenta a vida máxima inicial em ${level} ponto(s).`,
        maxLevel: 3,
        cost: (level) => 150 + level * 100,
        effectKey: 'maxHpBonus',
        defaultStat: 0,
        applier: (stat, level) => stat + level,
        dependsOn: null,
    },
    VelocidadeMovimento: {
        name: "Velocidade de Movimento",
        desc: (level) => `Aumenta a velocidade inicial em ${level * 10}pts.`,
        maxLevel: 5,
        cost: (level) => 75 + level * 50,
        effectKey: 'speedBonus',
        defaultStat: 0,
        applier: (stat, level) => stat + (level * 10),
        dependsOn: 'VidaMaxima',
    },
    RaioIma: {
        name: "Raio do Imã",
        desc: (level) => `Aumenta o raio de coleta de XP em ${level * 10}pts.`,
        maxLevel: 5,
        cost: (level) => 75 + level * 50,
        effectKey: 'magnetBonus',
        defaultStat: 0,
        applier: (stat, level) => stat + (level * 10),
        dependsOn: null,
    },
};

// Globais
let player, cursors, bullets, enemies, xpGems, hud;
let isPaused = true; 
let currentScene; 
let spawnEvent = null; // Para controlar o loop de spawn

let playerStats = { 
    hp: 3, maxHp: 3, damage: 2, fireRate: 800, speed: GAME_CONFIG.PLAYER.SPEED, 
    xp: 0, level: 1, xpToNext: 50, currency: 0, magnet: GAME_CONFIG.PLAYER.MAGNET,
    piercing: 1, doubleShot: false, dashUnlocked: false, dashCool: false,
    skillLevels: {
        DanoBase: 0, TaxaDeTiro: 0, VidaMaxima: 0, VelocidadeMovimento: 0, RaioIma: 0
    },
    skillEffects: {} 
};

let gameState = {
    wave: 1,
    enemiesToSpawn: 0, 
    enemiesAlive: 0    
};

let lastShot = 0;


// ==================================================================================================
// --- 2. CLASSE DA CENA PRINCIPAL ---
// ==================================================================================================

class MainScene extends Phaser.Scene {
    constructor() { super({ key: 'MainScene' }); }

    preload() {
        // Assets e Fallbacks (mantidos)
        this.load.image('player', 'assets/player.png');
        this.load.image('bullet', 'assets/bullet.png');
        this.load.image('enemy_robot', 'assets/enemy_robot.png');
        this.load.image('enemy_fast', 'assets/enemy_fast.png');
        this.load.image('enemy_tank', 'assets/enemy_tank.png');
        this.load.image('boss_robot', 'assets/boss_robot.png');
        this.load.image('gem', 'assets/ammo.png'); 
        this.load.image('dungeon_floor', 'assets/dungeon_floor.png'); 
        
        this.load.on('fileload', (file) => {
            if (file.key === 'dungeon_floor' && !this.textures.exists('dungeon_floor')) this.load.image('dungeon_floor', 'https://img.itch.zone/aW1hZ2UvNjg3Mzg3LzM4NDgyODQucG5n/original/KkF6tN.png');
            // ... outros fallbacks
        });
    }

    create() {
        currentScene = this; 

        loadProgress(); 
        applySkillTreeEffects(); 
        
        // --- SETUP DO JOGO ---
        this.add.tileSprite(0, 0, this.scale.width, this.scale.height, 'dungeon_floor')
            .setOrigin(0)
            .setScrollFactor(0)
            .setAlpha(0.8);

        player = this.physics.add.sprite(this.scale.width/2, this.scale.height/2, 'player').setScale(ORIGINAL_SCALES.PLAYER);
        player.setCollideWorldBounds(true);
        
        bullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 50 });
        enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true, maxSize: GAME_CONFIG.LIMITS.MAX_ENEMIES_ON_SCREEN });
        xpGems = this.physics.add.group({ classType: Gem, runChildUpdate: true, maxSize: GAME_CONFIG.LIMITS.MAX_GEMS });

        this.physics.add.overlap(bullets, enemies, this.hitEnemy, null, this);
        this.physics.add.collider(player, enemies, this.hitPlayer, null, this);
        this.physics.add.overlap(player, xpGems, this.collectGem, null, this);

        cursors = this.input.keyboard.createCursorKeys();
        this.input.keyboard.on('keydown-SPACE', () => this.dash());

        hud = new HUD(this);
        
        // --- CORREÇÃO DE INICIALIZAÇÃO: Pausa e Mostra Menu ---
        // O loop de spawn e startWave(1) NÃO ESTÃO mais aqui.
        isPaused = true; 
        this.physics.pause(); 
        showStartMenu(this); 
    }

    // --- NOVO MÉTODO PARA INICIAR O JOGO/SPAWN DE MOBS ---
    startMatch() {
        // Reseta o estado do jogo e começa a Onda 1
        gameState.wave = 0; // Vai para 1 no startWave
        gameState.enemiesToSpawn = 0;

        this.startWave(1); 
        
        // Inicia o loop de spawn
        spawnEvent = this.time.addEvent({ 
            delay: GAME_CONFIG.WAVE.SPAWN_DELAY, 
            callback: this.trySpawnEnemy, 
            callbackScope: this, 
            loop: true 
        });

        // Retoma o jogo
        this.physics.resume();
        isPaused = false;
    }

    update(time, delta) {
        if (isPaused) return;
        
        // Lógica de movimento e tiro (inalterada)
        player.setVelocity(0);
        const spd = playerStats.speed;
        if (cursors.left.isDown) player.setVelocityX(-spd);
        else if (cursors.right.isDown) player.setVelocityX(spd);
        if (cursors.up.isDown) player.setVelocityY(-spd);
        else if (cursors.down.isDown) player.setVelocityY(spd);

        if (time > lastShot) {
            let closest = null;
            let minDist = 450;
            enemies.children.each(e => {
                if (e.active) {
                    const d = Phaser.Math.Distance.Between(player.x, player.y, e.x, e.y);
                    if (d < minDist) { minDist = d; closest = e; }
                }
            });

            if (closest) {
                this.shoot(closest);
                lastShot = time + playerStats.fireRate;
            }
        }
    }

    // --- Lógica de Onda ---
    startWave(waveNum) {
        gameState.wave = waveNum;
        const totalEnemies = GAME_CONFIG.WAVE.START_COUNT + ((waveNum - 1) * GAME_CONFIG.WAVE.INC_PER_WAVE);
        
        gameState.enemiesToSpawn = totalEnemies;
        
        hud.showMsg(`ONDA ${waveNum} INICIADA!`, '#00FFFF');
        hud.updateStats();
    }
    
    trySpawnEnemy() {
        if (isPaused) return; 
        
        if (gameState.enemiesToSpawn <= 0) return;

        if (enemies.countActive() >= GAME_CONFIG.LIMITS.MAX_ENEMIES_ON_SCREEN) return;

        this.spawnOneEnemy();
    }

    spawnOneEnemy() {
        const edge = Math.random() < 0.5 ? 'x' : 'y';
        let x, y;
        if (edge === 'x') {
            x = Math.random() < 0.5 ? -50 : this.scale.width + 50;
            y = Math.random() * this.scale.height;
        } else {
            x = Math.random() * this.scale.width;
            y = Math.random() < 0.5 ? -50 : this.scale.height + 50;
        }

        let enemyType = enemyTypes.normal;
        if (gameState.wave >= enemyTypes.tank.minWave && Math.random() < enemyTypes.tank.chance) {
            enemyType = enemyTypes.tank;
        } else if (gameState.wave >= enemyTypes.fast.minWave && Math.random() < enemyTypes.fast.chance) {
            enemyType = enemyTypes.fast;
        }

        const e = enemies.get();
        if (e) {
            e.spawn(x, y, enemyType, gameState.wave);
            gameState.enemiesToSpawn--; 
            hud.updateStats(); 
        }
    }
    
    checkWaveEnd() {
        if (gameState.enemiesToSpawn <= 0 && enemies.countActive() === 0) {
            hud.showMsg("ONDA CONCLUÍDA! Preparando próxima...", "#00FF00");
            this.time.delayedCall(2000, () => {
                this.startWave(gameState.wave + 1);
            });
        }
    }

    // --- Outros Métodos (mantidos) ---
    shoot(target) { /* ... */ }
    hitEnemy(bullet, enemy) { /* ... */ }
    dropGem(x, y, val) { /* ... */ }
    collectGem(player, gem) { /* ... */ }
    hitPlayer(player, enemy) { /* ... */ }
    dash() { /* ... */ }
}


// ==================================================================================================
// --- 3. CLASES AUXILIARES (MANTIDAS) ---
// ==================================================================================================

class Bullet extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { super(scene, x, y, 'bullet'); }
    fire(x, y, angle) { /* ... */ }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) { super.preUpdate(time, delta); if (this.lifespan <= 0) this.kill(); this.lifespan -= delta; }
}

class Enemy extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { super(scene, x, y, 'enemy_robot'); }
    spawn(x, y, typeData, waveDifficulty) { /* ... */ }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.active) this.scene.physics.moveToObject(this, player, this.speed);
    }
}

class Gem extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { super(scene, x, y, 'gem'); }
    spawn(x, y, val) { /* ... */ }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.active) {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y);
            if (dist < playerStats.magnet) this.scene.physics.moveToObject(this, player, 400);
        }
    }
}

class HUD { /* ... */ }

// ==================================================================================================
// --- 4. FUNÇÕES DE PERSISTÊNCIA E APLICAÇÃO DE SKILLS (MANTIDAS) ---
// ==================================================================================================

function saveProgress() { /* ... */ }
function loadProgress() { /* ... */ }
function applySkillTreeEffects() { /* ... */ }


// ==================================================================================================
// --- 5. FUNÇÕES DE UI (MENUS ATUALIZADOS) ---
// ==================================================================================================

function showStartMenu(scene) {
    const overlay = document.createElement('div');
    overlay.className = 'menu-overlay';
    
    const box = document.createElement('div');
    box.className = 'menu-container';
    box.style.maxWidth = '500px';

    box.innerHTML = `<h2 class="menu-title">WAR OF THE AUTOMATONS</h2>
        <p style="font-size: 20px; color: #aaa;">Sucata: <span id="currency-display" style="color: #FFD700; font-weight: bold;">${playerStats.currency}</span></p>
        <button id="start-btn" class="btn">COMEÇAR JOGO</button>
        <button id="skill-tree-btn" class="btn">ÁRVORE DE HABILIDADES</button>
    `;

    box.querySelector('#start-btn').onclick = () => {
        overlay.remove();
        // Chamada AGORA para iniciar a lógica de jogo e spawn de mobs
        scene.startMatch(); 
    };

    box.querySelector('#skill-tree-btn').onclick = () => {
        showSkillTreeMenu(scene, overlay);
    };

    overlay.appendChild(box);
    document.body.appendChild(overlay);
}

function showSkillTreeMenu(scene, previousOverlay) { /* ... */ }
function showLevelUp(scene) { /* ... */ }

// ==================================================================================================
// --- 6. INICIALIZAÇÃO DO JOGO ---
// ==================================================================================================

const game = new Phaser.Game({
    type: Phaser.AUTO, width: window.innerWidth, height: window.innerHeight,
    backgroundColor: '#000', parent: document.body,
    physics: { default: 'arcade', arcade: { debug: false } },
    scene: [MainScene]
});

window.addEventListener('resize', () => game.scale.resize(window.innerWidth, window.innerHeight));
</script>
</body>
</html>

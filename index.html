<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons V.1.2.7 - Multi-Enemy Update</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
      body {
      margin: 0;
      overflow: hidden;
      background: #0a0000ce;
    }
    canvas {
      display: block;
      margin: auto;}
  </style>
</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 1300,
  height: 580,
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: { debug: false }
  },
  scene: {
    preload,
    create,
    update
  }
};

let waveText;
let hudGroup;
let armaNomeText;
let armaImagem;
let player, cursors;
let bullets, enemies, enemyBullets, armas;
let lastShoot = 0;
let showingCards = false; // Flag to indicate if card choices are active
let showingLevelUpChoices = false; // Flag for level up choices
let wave = 1; //onda
let cardsGroup; //grupo de cartas
let playerSpeed = 400; //velocidade inicial do jogador
let spiritAlly = null; //aliado
let playerCards = []; // Cartas que o jogador pegou
let cardsHUDGroup; // Grupo visual do HUD de cartas

// NEW: Player Level and XP related variables
let xpText;
let levelText;
let levelUpChoicesGroup;


let playerStats = {
  life: 3,                    // Coraçãozin tá firme
  maxLife: 3,                 // Adicionado para referência de vida máxima
  bulletDamage: 1,           // Dano padrão da bala
  baseFireRate: 3000,            // Base delay entre tiros (from current weapon)
  hasShield: false,          // Tem escudo ou não
  spiritAllyActive: false,   // Espírito aliado tá junto?
  spreadUpgrade: false,      // Tiro espalhado desbloqueado?
  doubleBullets: false,      // Dois tiros de uma vez?
  dashAvailable: false,      // Pode usar dash?
  dashCooldown: false,       // Tá em cooldown?
  slowEnemies: false,        // Inimigos lentos (efeito de carta) - NOT USED YET
  reviveOnce: false,         // Ressuscita uma vez?
  increasedDropRate: false,  // Mais chance de drop de arma?
  tripleBullets: false,      // Três tiros, modo overpowered
  healOnKill: false,         // Cura ao matar?
  damageAura: false,         // Aura de dano por perto
  speedBoost: false,         // Velocidade turbinada - NOT USED YET
  bulletPiercing: false,      // Bala atravessa inimigos?
  thorns: false,              // Dano nos inimigos ao ser atingido
  reflectDamage: false,       // Reflete dano de volta (needs proper implementation)
  homingBullets: false,       // Balas teleguiadas (needs proper implementation)

  // NEW RPG STATS
  level: 1,
  xp: 0,
  xpToNextLevel: 10, // Initial XP for level 2
  atkVelocityBonus: 1, // Multiplier for fireRate (e.g., 0.9 for 10% faster)
  lifeBonus: 0,        // Flat bonus to maxLife
  defenseBonus: 0,     // Percentage damage reduction (e.g., 0.1 for 10% reduction)
  playerSpeedBonus: 0, // Flat bonus to playerSpeed
  currentFireRateModifier: 1 // For temporary fire rate boosts like "Velocidade Neuronal"
};

const tiposDeArmas = {
  arma1: { dano: 1, fireRate: 3000 }, // Pistola 
  arma2: { dano: 2, fireRate: 1000 }, // Metralhadora média
  arma3: { dano: 3, fireRate: 2000 } // Lança-raio brabo
};

// --- NOVAS DEFINIÇÕES DE INIMIGOS ---
const enemyTypes = {
  normal: {
    texture: 'enemy',
    baseHealth: 4,
    speed: 100,
    scale: 0.06,
    xpReward: 5
  },
  fast: {
    texture: 'enemy_fast',
    baseHealth: 4,
    speed: 180,
    scale: 0.06,
    xpReward: 7
  },
  tank: {
    texture: 'enemy_tank',
    baseHealth: 9,
    speed: 70,
    scale: 0.08,
    xpReward: 10
  }
};
// --- FIM NOVAS DEFINIÇÕES DE INIMIGOS ---

const game = new Phaser.Game(config);

function preload() {
  this.load.image('cardBg', 'assets/card.png');
  this.load.image('player', 'assets/player.png');
  this.load.image('bullet', 'assets/bullet.png');
  this.load.image('arma1', 'assets/pistolinha.png');
  this.load.image('arma2', 'assets/metralha.png');
  this.load.image('arma3', 'assets/lancarrio.png');
  this.load.image('fundogame', 'assets/fundogame.png'); 
  this.load.image('cora', 'assets/cora.png');

  // --- NOVO: Carregando as texturas dos novos inimigos ---
  this.load.image('enemy', 'assets/enemy_robot.png'); // Inimigo normal
  this.load.image('enemy_fast', 'assets/enemy_fast.png'); // Inimigo rápido
  this.load.image('enemy_tank', 'assets/enemy_tank.png'); // Inimigo tanque
  this.load.image('boss', 'assets/boss_robot.png'); // Adiciona a textura do boss
  // --- FIM NOVO ---
}

function create() {
      
  this.add.image(config.width / 2, config.height / 2, 'fundogame').setDepth(-1);

  player = this.physics.add.sprite(400, 300, 'player').setCollideWorldBounds(true).setScale(0.05);
  // Removed player.health and player.maxHealth assignments here as playerStats is the source of truth

  bullets = this.physics.add.group();
  enemies = this.physics.add.group();
  enemyBullets = this.physics.add.group();
  armas = this.physics.add.group();

  cursors = this.input.keyboard.createCursorKeys();

  // Initialize HUD and related text/images before calling spawnArmas or any update
  hudGroup = this.add.group();
  cardsHUDGroup = this.add.group(); // Grupo que vai mostrar as cartas
  levelUpChoicesGroup = this.add.group(); // Group for level up choices

  armaNomeText = this.add.text(config.width / 2, 20, 'Pistolinha', {
    fontFamily: 'Cinzel',
    fontSize: '28px',
    color: '#A62E2E',
    stroke: '#000000',
    strokeThickness: 4,
    shadow: { offsetX: 2, offsetY: 2, color: '#000', blur: 4, stroke: true, fill: true }
  }).setOrigin(0.5, 0);

  const box = this.add.rectangle(config.width / 2, 40, 300, 70, 0x111111, 0.3).setOrigin(0.5, 0);
  box.setStrokeStyle(2, 0x00ffff, 0.1);
  hudGroup.add(box);

  armaImagem = this.add.image(config.width / 2, 70, 'arma1').setScale(0.1);
  hudGroup.addMultiple([armaNomeText, armaImagem]);

  waveText = this.add.text(config.width - 20, 20, `Fase ${wave}`, {
    fontFamily: 'Cinzel',
    fontSize: '24px',
    color: '#FFFFFF',
    stroke: '#000000',
    strokeThickness: 4
  }).setOrigin(1, 0);

  // NEW: XP and Level HUD
  levelText = this.add.text(20, config.height - 50, `Nível: ${playerStats.level}`, {
    fontFamily: 'Cinzel',
    fontSize: '20px',
    color: '#FFF',
    stroke: '#000',
    strokeThickness: 3
  }).setOrigin(0, 0);
  xpText = this.add.text(20, config.height - 20, `XP: ${playerStats.xp} / ${playerStats.xpToNextLevel}`, {
    fontFamily: 'Cinzel',
    fontSize: '16px',
    color: '#FFD700',
    stroke: '#000',
    strokeThickness: 2
  }).setOrigin(0, 0);

  // Boss Health Bar UI elements (initially hidden)
  this.bossHealthBarBg = this.add.graphics().setDepth(100);
  this.bossHealthBarFill = this.add.graphics().setDepth(101);
  this.bossNameText = this.add.text(0, 0, '', { 
    fontSize: '20px', 
    color: '#FFD700', 
    stroke: '#000000', 
    strokeThickness: 3 
  }).setOrigin(0.5).setDepth(102);

  this.bossHealthBarBg.setVisible(false);
  this.bossHealthBarFill.setVisible(false);
  this.bossNameText.setVisible(false);

  this.hud = new HUD(this, player); // Initialize HUD after player and other HUD elements are set up

  spawnArmas.call(this); // Now arma types will be correctly passed

  this.physics.add.overlap(player, armas, (player, arma) => {
    pegarArma.call(this, arma);
  });

  this.input.keyboard.on('keydown-Z', () => {
    if (playerStats.dashAvailable && !playerStats.dashCooldown) {
      dashPlayer.call(this);
    }
  });

  this.input.keyboard.on('keydown-SPACE', () => {
    if (!player.active && !showingCards && !showingLevelUpChoices) { // Only restart if not in card/level up screen
      this.time.delayedCall(500, () => {
        // Clear existing UI elements for a clean restart
        this.hud.heartsGroup.clear(true, true);
        hudGroup.clear(true, true); // Clear main HUD group
        cardsHUDGroup.clear(true, true); // Clear cards HUD
        levelUpChoicesGroup.clear(true, true); // Clear level up choices

        this.scene.restart();
        // Reset player stats for a new game
        playerStats = {
          life: 3, maxLife: 3, bulletDamage: 1, baseFireRate: 3000, hasShield: false,
          spiritAllyActive: false, spreadUpgrade: false, doubleBullets: false,
          dashAvailable: false, dashCooldown: false, slowEnemies: false,
          reviveOnce: false, increasedDropRate: false, tripleBullets: false,
          healOnKill: false, damageAura: false, speedBoost: false, bulletPiercing: false,
          thorns: false, reflectDamage: false, homingBullets: false,
          level: 1, xp: 0, xpToNextLevel: 10,
          atkVelocityBonus: 1, lifeBonus: 0, defenseBonus: 0, playerSpeedBonus: 0,
          currentFireRateModifier: 1
        };
        wave = 1;
        playerCards = [];
      });
    }
  });

  spawnWave.call(this);

  this.physics.add.overlap(bullets, enemies, (b, e) => {
    if (b.active && e.active) {
      if (!playerStats.bulletPiercing) b.destroy();

      e.health = (e.health || 0) - playerStats.bulletDamage; // Ensure health is a number, default to 0 for safety

      if (e.health <= 0) {
        e.destroy();
        if (playerStats.healOnKill) { // healOnKill check
          playerStats.life = Math.min(playerStats.life + 1, playerStats.maxLife);
          this.hud.update();
        }
        // NEW: Grant XP on enemy defeat
        gainXP.call(this, e.xpReward || 0); // Use xpReward from enemy type
      } else if (playerStats.bulletPiercing) {
        // Add particle effect for piercing bullets
        const particles = this.add.particles('bullet');
        particles.createEmitter({
          x: e.x,
          y: e.y,
          speed: { min: -50, max: 50 },
          scale: { start: 0.05, end: 0 },
          lifespan: 300,
          blendMode: 'ADD',
          quantity: 6
        });
      }
    }
  });

  this.physics.add.overlap(player, enemies, (p, e) => { // Player-enemy collision
    if (p.active && e.active) {
      e.destroy(); // Enemy is destroyed on collision
      // Apply defenseBonus to damage taken (base damage is 1 per collision)
      const damageTaken = Math.max(1 * (1 - playerStats.defenseBonus), 0.1); 
      
      if (!playerStats.hasShield) {
        playerStats.life -= damageTaken;
        this.hud.update();
        p.setTint(0xff0000);
        this.time.delayedCall(100, () => p.clearTint());
        if (playerStats.life <= 0) {
          handlePlayerDeath.call(this, p);
        }
      } else {
        playerStats.hasShield = false;
        p.clearTint();
      }
      if (playerStats.thorns && e.active) { // Thorns effect
        e.health -= 1; // Or a specific thorn damage
        if (e.health <= 0) e.destroy();
      }
    }
  });

  this.physics.add.overlap(enemyBullets, player, (b, p) => {
    if (b.active && p.active) {
      b.destroy();
      // Apply defenseBonus to damage taken
      const damageTaken = Math.max(1 * (1 - playerStats.defenseBonus), 0.1);

      if (!playerStats.hasShield) {
        playerStats.life -= damageTaken; // Decrement player life
        this.hud.update(); // Update HUD
        p.setTint(0xff0000);
        this.time.delayedCall(100, () => p.clearTint());

        if (playerStats.life <= 0) {
          handlePlayerDeath.call(this, p);
        }
      } else {
        playerStats.hasShield = false;
        this.cameras.main.setZoom(1); // Assuming this is for visual feedback of shield breaking
        p.clearTint();
      }
      if (playerStats.reflectDamage) { // Reflect damage effect
        // A simple reflection: damage a random active enemy
        const randomEnemy = Phaser.Utils.Array.GetRandom(enemies.getChildren().filter(e => e.active));
        if (randomEnemy) { // Check if randomEnemy exists
          randomEnemy.health -= playerStats.bulletDamage * 0.3; // Reflect 30% of player's damage as per card desc
          if (randomEnemy.health <= 0) randomEnemy.destroy();
        }
      }
    }
  });


  this.time.addEvent({
    delay: 9000, // Reduced delay for faster enemy shooting
    loop: true,
    callback: () => {
      enemies.getChildren().forEach(enemy => {
        if (!enemy.active || enemy.isBoss) return; // Bosses handle their own shooting
        const bullet = enemyBullets.create(enemy.x, enemy.y, 'bullet').setScale(0.03);
        const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
        this.physics.velocityFromRotation(angle, 150, bullet.body.velocity);
      });
    }
  });
}

function spawnArmas() {
  const tipos = Object.keys(tiposDeArmas);

  for (let i = 0; i < 3; i++) {
    const x = Phaser.Math.Between(100, config.width - 100); // Adjust spawn range
    const y = Phaser.Math.Between(100, config.height - 100); // Adjust spawn range
    const tipo = Phaser.Utils.Array.GetRandom(tipos); // Randomly select a weapon type
    const arma = armas.create(x, y, tipo).setScale(0.02);
    arma.tipo = tipo;
  }
}

function pegarArma(arma) {
  const props = tiposDeArmas[arma.tipo];

  playerStats.bulletDamage = props.dano;
  playerStats.baseFireRate = props.fireRate; // Store the base fire rate of the weapon
  player.currentWeapon = arma.tipo; // Store current weapon type

  arma.destroy();

  const nomeArmasMap = {
    arma1: 'Pistolinha',
    arma2: 'Fúria de Eryon',
    arma3: 'Lança-Raio'
  };

  atualizarHUDarma(nomeArmasMap[arma.tipo], arma.tipo);

  // Feedback visual style favela-glitch
  this.add.text(player.x, player.y - 30, `Pegou ${nomeArmasMap[arma.tipo]}!`, {
    fontSize: '18px',
    color: '#FFD700',
    fontStyle: 'bold',
    stroke: '#000',
    strokeThickness: 3
  }).setOrigin(0.5).setDepth(99).setScrollFactor(0).setAlpha(0.7)
    .setInteractive()
    .on('pointerdown', txt => txt.destroy());
}

function atualizarHUDarma(nomeArma, keyImagem) {
  armaNomeText.setText(nomeArma);
  armaImagem.setTexture(keyImagem);
}

function atualizarHUDCartas(scene) {
  cardsHUDGroup.clear(true, true); // Limpa antes de redesenhar

  // Use a map to count card occurrences
  const cardCounts = {};
  playerCards.forEach(card => {
    cardCounts[card.nome] = (cardCounts[card.nome] || 0) + 1;
  });

  let xOffset = 50;
  // Make sure cards don't go off screen for too many cards, wrap or scroll needed for many cards
  const maxCardsPerRow = Math.floor((config.width - 100) / 60); // Approx.
  let row = 0;
  let cardIndex = 0;

  for (const cardName in cardCounts) {
    const count = cardCounts[cardName];
    const card = playerCards.find(c => c.nome === cardName); // Find the original card object to get its color
    if (!card) continue; // Should not happen

    const currentX = 50 + (cardIndex % maxCardsPerRow) * 60;
    const currentY = 140 + row * 80; // New row every maxCardsPerRow cards

    const bg = scene.add.rectangle(currentX, currentY, 50, 70, card.cor || 0x999999, 0.8)
      .setStrokeStyle(2, 0xffffff)
      .setTint(card.cor || 0x999999); // Apply the card's specific color
    const title = scene.add.text(currentX, currentY - 10, card.nome[0], { // Adjusted Y for better centering
      fontSize: '24px',
      color: '#fff'
    }).setOrigin(0.5);

    cardsHUDGroup.add(bg);
    cardsHUDGroup.add(title);

    if (count > 1) {
      const countText = scene.add.text(currentX, currentY + 25, `x${count}`, { // Adjusted Y below the card
        fontSize: '16px',
        color: '#FFD700',
        stroke: '#000',
        strokeThickness: 2
      }).setOrigin(0.5);
      cardsHUDGroup.add(countText);
    }
    cardIndex++;
    if (cardIndex % maxCardsPerRow === 0) {
        row++; // Move to next row
    }
  }
}

function update(time) {
  this.hud.update();
  levelText.setText(`Nível: ${playerStats.level}`);
  xpText.setText(`XP: ${playerStats.xp} / ${playerStats.xpToNextLevel}`);

  if (!player.active || showingCards || showingLevelUpChoices) return; // Pause game logic if choices are active

  let vx = 0, vy = 0;
  if (cursors.left.isDown) vx = -1;
  else if (cursors.right.isDown) vx = 1;

  if (cursors.up.isDown) vy = -1;
  else if (cursors.down.isDown) vy = 1;

  const norm = Math.hypot(vx, vy) || 1;
  player.setVelocity((vx / norm) * (playerSpeed + playerStats.playerSpeedBonus), (vy / norm) * (playerSpeed + playerStats.playerSpeedBonus));

  if (time > lastShoot + (playerStats.baseFireRate * playerStats.atkVelocityBonus * playerStats.currentFireRateModifier)) { // Apply ATK Velocity Bonus and temporary modifier
    shootRadial.call(this);
    lastShoot = time;
  }

  enemies.getChildren().forEach(enemy => {
    if (!enemy.active) return;
    const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
    // Usa a velocidade específica do tipo de inimigo
    this.physics.velocityFromRotation(angle, enemy.speed, enemy.body.velocity); 
    
    if (playerStats.damageAura) { // Damage Aura effect
      const dist = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
      if (dist < 100) { // Aura radius
        enemy.health -= 0.01; // Small continuous damage
        if (enemy.health <= 0) {
            enemy.destroy();
            if (playerStats.healOnKill) { // healOnKill check if aura kills
                playerStats.life = Math.min(playerStats.life + 1, playerStats.maxLife);
                this.hud.update();
            }
            gainXP.call(this, enemy.xpReward || 0);
        }
      }
    }
    
    // NEW: Homing bullets logic (simple version)
    if (playerStats.homingBullets && enemy.active) {
        bullets.getChildren().forEach(bullet => {
            // Check if this bullet should be homing and if its target is still valid
            if (bullet.active && bullet.trackingTarget === enemy && enemy.active) { 
                const angleToEnemy = Phaser.Math.Angle.Between(bullet.x, bullet.y, enemy.x, enemy.y);
                this.physics.velocityFromRotation(angleToEnemy, bullet.speed || 700, bullet.body.velocity);
            }
        });
    }
  });

  // Update enemy health bar for the closest enemy
  let closestEnemy = null;
  let minDistance = Infinity;
  enemies.getChildren().forEach(enemy => {
    if (enemy.active) {
      const distance = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
      if (distance < minDistance) {
        minDistance = distance;
        closestEnemy = enemy;
      }
    }
  });
  this.hud.setEnemy(closestEnemy);

  // Boss health bar update
  const boss = enemies.getChildren().find(e => e.isBoss);
  if (boss && boss.active) {
    const barWidth = 300;
    const barHeight = 30;
    const barX = (config.width - barWidth) / 2;
    const barY = config.height - 50;

    this.bossHealthBarBg.clear();
    this.bossHealthBarBg.fillStyle(0x000000, 0.6);
    this.bossHealthBarBg.fillRect(barX, barY, barWidth, barHeight);
    this.bossHealthBarBg.setVisible(true);

    const healthPercent = Phaser.Math.Clamp(boss.health / boss.maxHealth, 0, 1);
    this.bossHealthBarFill.clear();
    this.bossHealthBarFill.fillStyle(0xff0000, 1);
    this.bossHealthBarFill.fillRect(barX, barY, barWidth * healthPercent, barHeight);
    this.bossHealthBarFill.setVisible(true);

    this.bossNameText.setText('BOSS: ' + boss.enemyTypeKey.toUpperCase());
    this.bossNameText.setPosition(config.width / 2, barY - 15);
    this.bossNameText.setVisible(true);

  } else {
    this.bossHealthBarBg.setVisible(false);
    this.bossHealthBarFill.setVisible(false);
    this.bossNameText.setVisible(false);
  }

  // Check for wave completion only if no choices are being shown
  if (enemies.countActive() === 0 && !showingCards && !showingLevelUpChoices) {
    // Check for level up first
    if (playerStats.xp >= playerStats.xpToNextLevel) {
        levelUp.call(this);
    } else {
        // If not leveled up, proceed with card choices
        showingCards = true;
        showCardChoices.call(this);
    }
  }
}

// NEW: XP and Leveling Functions
function gainXP(amount) {
  playerStats.xp += amount;
  xpText.setText(`XP: ${playerStats.xp} / ${playerStats.xpToNextLevel}`);
}

function levelUp() {
  playerStats.level++;
  playerStats.xp -= playerStats.xpToNextLevel; // Carry over excess XP
  playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.5); // Increase XP needed for next level

  levelText.setText(`Nível: ${playerStats.level}`);
  xpText.setText(`XP: ${playerStats.xp} / ${playerStats.xpToNextLevel}`);

  // Refill health on level up (optional, but common in RPGs)
  playerStats.life = playerStats.maxLife; 
  this.hud.update();

  showingLevelUpChoices = true;
  showLevelUpChoices.call(this);
}

function showLevelUpChoices() {
    const statOptions = [
        { name: 'Velocidade de Ataque', desc: '+10% Velocidade de Ataque (Reduz recarga)', effect: () => { playerStats.atkVelocityBonus *= 0.9; pegarArma.call(this, {tipo: player.currentWeapon || 'arma1'}); } }, // Update current weapon fire rate
        { name: 'Vida Máxima', desc: '+1 Vida Máxima', effect: () => { playerStats.maxLife += 1; playerStats.life = playerStats.maxLife; this.hud.createHearts(); this.hud.update(); } },
        { name: 'Defesa', desc: '+5% Redução de Dano', effect: () => { playerStats.defenseBonus = Math.min(playerStats.defenseBonus + 0.05, 0.5); } }, // Max 50% defense
        { name: 'Velocidade de Movimento', desc: '+50 Velocidade de Movimento', effect: () => { playerStats.playerSpeedBonus += 50; } },
    ];

    Phaser.Utils.Array.Shuffle(statOptions);
    const selectedStatChoices = statOptions.slice(0, 3); // Choose 3 random stat options

    // Add an option to get a card instead of stats
    selectedStatChoices.push({
        name: 'Carta Aleatória', desc: 'Escolha uma carta aleatória (como no fim da onda)', effect: () => {
            levelUpChoicesGroup.clear(true, true);
            showingLevelUpChoices = false;
            showingCards = true; // Set flag to true for card choice
            showCardChoices.call(this); // Go directly to card choices
            return; // Skip normal wave logic
        }
    });

    levelUpChoicesGroup.clear(true, true); // Clear existing group if any

    const startX = this.cameras.main.centerX;
    const startY = this.cameras.main.centerY;
    const gap = 220;

    selectedStatChoices.forEach((choice, i) => {
        const x = startX + (i - (selectedStatChoices.length -1)/2) * gap; // Center the choices
        const y = startY;

        const container = this.add.container(x, y);
        const bgImage = this.add.image(0, 0, 'cardBg').setDisplaySize(160, 240).setTint(0xADD8E6); // Light blue tint for stat choices

        const title = this.add.text(0, -80, choice.name, { fontSize: '20px', color: '#000', align: 'center', wordWrap: { width: 140 } }).setOrigin(0.5);
        const desc = this.add.text(0, 0, choice.desc, { fontSize: '14px', color: '#333', align: 'center', wordWrap: { width: 140 } }).setOrigin(0.5);

        container.add([bgImage, title, desc]);

        container.setSize(160, 240);
        container.setInteractive();

        this.tweens.add({
            targets: container,
            y: y - 20,
            yoyo: true,
            repeat: -1,
            duration: 1000,
            ease: 'Sine.easeInOut'
        });

        container.on('pointerover', () => {
            container.setScale(1.1);
        });

        container.on('pointerout', () => {
            container.setScale(1);
        });

        container.on('pointerdown', () => {
            this.tweens.add({
                targets: container,
                scale: 0.9,
                duration: 100,
                yoyo: true,
                ease: 'Power1',
                onComplete: () => {
                    choice.effect();
                    levelUpChoicesGroup.clear(true, true);
                    showingLevelUpChoices = false;
                    // If the choice was not to pick a card, proceed to next wave
                    if (choice.name !== 'Carta Aleatória') {
                        wave++;
                        waveText.setText(`Fase ${wave}`);
                        spawnWave.call(this);
                    }
                }
            });
        });

        levelUpChoicesGroup.add(container);
    });
}


function handlePlayerDeath(p) {
  if (playerStats.reviveOnce) {
    playerStats.life = 1;
    playerStats.reviveOnce = false;
    this.hud.update();
    p.clearTint();
    // Add a visual/audio cue for revival
    this.add.text(p.x, p.y - 50, 'REVIVED!', {
      fontSize: '24px',
      color: '#00FF00',
      fontStyle: 'bold',
      stroke: '#000',
      strokeThickness: 4
    }).setOrigin(0.5).setDepth(99);
  } else {
    p.setActive(false).setVisible(false);
    // Game Over logic here
    const gameOverText = this.add.text(config.width / 2, config.height / 2, 'GAME OVER\nPress SPACE to Restart', {
      fontFamily: 'Cinzel',
      fontSize: '48px',
      color: '#FF0000',
      stroke: '#000000',
      strokeThickness: 6,
      align: 'center'
    }).setOrigin(0.5);
  }
}

function shootRadial() {
  const count = playerStats.spreadUpgrade ? 24 : 12;
  const speed = 700;

  for (let i = 0; i < count; i++) {
    const baseAngle = Phaser.Math.DegToRad((360 / count) * i);

    // Funçãozinha pra criar tiro com ângulo e variação
    const criarBala = (angleOffset = 0) => {
      const angle = baseAngle + angleOffset;
      const bullet = bullets.create(player.x, player.y, 'bullet').setScale(0.02);
      bullet.speed = speed; // Store speed for homing bullets

      this.time.delayedCall(1000, () => { // Bullets self-destruct after 1 sec
        if (bullet && bullet.active) bullet.destroy();
      });

      // NEW: Homing bullet target assignment
      if (playerStats.homingBullets) {
        let closestEnemy = null;
        let minDist = Infinity;
        enemies.getChildren().forEach(enemy => {
            if (enemy.active) {
                const dist = Phaser.Math.Distance.Between(bullet.x, bullet.y, enemy.x, enemy.y);
                if (dist < minDist) {
                    minDist = dist;
                    closestEnemy = enemy;
                }
            }
        });
        if (closestEnemy) {
            bullet.trackingTarget = closestEnemy; // Assign target for homing
        }
      }

      this.physics.velocityFromRotation(angle, speed, bullet.body.velocity);
    };

    // Se tiver triplo: 3 balas
    if (playerStats.tripleBullets) {
      criarBala(Phaser.Math.DegToRad(-5));
      criarBala(0);
      criarBala(Phaser.Math.DegToRad(5));

    // Se for só duplo: 2 balas
    } else if (playerStats.doubleBullets) {
      criarBala(Phaser.Math.DegToRad(-3));
      criarBala(Phaser.Math.DegToRad(3));

    // Se não, só 1 mesmo
    } else {
      criarBala();
    }
  }
}

function showCardChoices() {
  const cardOptions = [
    { nome: 'Escudo de Ivirik', desc: 'Proteção que te salva da morte uma vez', cor: 0xffc107, efeito: () => { playerStats.hasShield = true; } },
    { nome: 'Tiro Duplo', desc: 'Dispara duas vezes mais balas', cor: 0x4caf50, efeito: () => { playerStats.doubleBullets = true; } },
    { nome: 'Bênção do dr Anomoi', desc: 'um automato te ajuda no ataque', cor: 0x00bcd4, efeito: ativarSpiritAlly },
    { nome: 'Upgrade do Spread', desc: 'Dispara balas em círculo maior', cor: 0x9c27b0, efeito: () => { playerStats.spreadUpgrade = true; } },
    { nome: 'Dash ', desc: 'Corrida rápida para escapar', cor: 0xf44336, efeito: () => { playerStats.dashAvailable = true; } },
    { nome: 'Projétil Perfurante', desc: 'Balas atravessam inimigos de forma avassaladora', cor: 0x03a9f4, efeito: () => { playerStats.bulletPiercing = true; } },
    { nome: 'Recuperação Instantânea', desc: 'Recupera 2 de vida', cor: 0x8bc34a, efeito: () => { playerStats.life = Math.min(playerStats.life + 2, playerStats.maxLife); this.hud.update(); } },
    { nome: 'Fúria de Metalion', desc: 'Aumenta o dano por 15s', cor: 0xff5722, efeito: () => { playerStats.bulletDamage += 1; this.time.delayedCall(15000, () => playerStats.bulletDamage -= 1); } }, 
    { nome: 'Vida Fantasma', desc: 'Sobrevive com 1 de vida ao morrer', cor: 0x673ab7, efeito: () => { playerStats.reviveOnce = true; } }, 
    { nome: 'Energético da Meia-Noite', desc: 'Velocidade de movimento aumentada em 50% por 10s', cor: 0xffeb3b, efeito: () => {
    const originalPlayerSpeedBonus = playerStats.playerSpeedBonus; // Store the current bonus
        playerStats.playerSpeedBonus += playerSpeed * 0.5; // Add 50% of base playerSpeed to bonus
        this.time.delayedCall(10000, () => playerStats.playerSpeedBonus = originalPlayerSpeedBonus); // Restore original bonus
      } },

      { nome: 'Aura Letal', desc: 'Causa dano contínuo nos inimigos próximos', cor: 0xcd201f, efeito: () => {
        playerStats.damageAura = true;
        // The continuous damage logic is handled in the update loop
      } },

      { nome: 'Velocidade Neuronal', desc: 'Recarga de tiro 2x mais rápida por 10s', cor: 0x03a9f4, efeito: () => {
        playerStats.currentFireRateModifier /= 2; // Halve the modifier (makes fire rate faster)
        this.time.delayedCall(10000, () => playerStats.currentFireRateModifier *= 2); // Restore modifier
      } },

      { nome: 'Hack dos Fragmentos', desc: 'Chance dobrada de aparecer armas nas próximas ondas', cor: 0x607d8b, efeito: () => {
        playerStats.increasedDropRate = true;
      } },

      { nome: 'Respiro do Caos', desc: 'Recupera toda sua vida', cor: 0x009688, efeito: () => {
        playerStats.life = playerStats.maxLife;
        this.hud.update();
      } },

      { nome: 'Espelho de Plasma', desc: 'Reflete 30% do dano de volta ao inimigo por 10s', cor: 0x673ab7, efeito: () => {
        playerStats.reflectDamage = true;
        this.time.delayedCall(10000, () => playerStats.reflectDamage = false);
      } },

      { nome: 'Canhão Triplo', desc: 'Atira 3 balas em vez de 1', cor: 0xff9800, efeito: () => {
        playerStats.tripleBullets = true;
      } },
    { nome: 'Espinhos do Asfalto', desc: 'Dano nos inimigos ao ser atingido', cor: 0xe91e63, efeito: () => { playerStats.thorns = true; } },
    // NEW CARDS
    { nome: 'Cura ao Abater', desc: 'Cura-se um pouco ao eliminar um inimigo', cor: 0x4CAF50, efeito: () => { playerStats.healOnKill = true; } },
    { nome: 'Fortalecimento Estrutural', desc: 'Aumenta sua vida máxima em 1', cor: 0x9E9E9E, efeito: () => { playerStats.maxLife += 1; playerStats.life = playerStats.maxLife; this.hud.createHearts(); this.hud.update(); } },
    { nome: 'Punição Lenta', desc: 'Deixa inimigos mais lentos por 5s', cor: 0x2196F3, efeito: () => { 
        enemies.getChildren().forEach(enemy => {
            // Store original speed to restore it correctly
            enemy.originalSpeed = enemy.originalSpeed || enemy.speed; // Ensure originalSpeed exists
            enemy.speed *= 0.5; // Halve enemy speed
            this.time.delayedCall(5000, () => {
                // Only restore if the enemy is still active and exists
                if (enemy && enemy.active) { 
                    enemy.speed = enemy.originalSpeed; // Restore original speed
                }
            });
        });
    }},
    { nome: 'Tiro Teleguiado', desc: 'Suas balas perseguem inimigos por 3s', cor: 0xFFEB3B, efeito: () => {
        playerStats.homingBullets = true;
        this.time.delayedCall(3000, () => { playerStats.homingBullets = false; });
    }},
    { nome: 'Explosão Arcana', desc: 'Causa uma grande explosão ao redor do jogador', cor: 0x9C27B0, efeito: () => {
        const explosionRadius = 200;
        enemies.getChildren().forEach(enemy => {
            const dist = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
            if (dist < explosionRadius) {
                enemy.health -= 5; // Fixed explosion damage
                if (enemy.health <= 0) {
                    enemy.destroy();
                    if (playerStats.healOnKill) { // healOnKill check if explosion kills
                        playerStats.life = Math.min(playerStats.life + 1, playerStats.maxLife);
                        this.hud.update();
                    }
                    gainXP.call(this, enemy.xpReward || 0); // Grant XP on explosion kill
                }
            }
        });
        // Visual feedback for explosion
        const graphics = this.add.graphics({ fillStyle: { color: 0xFFFFFF, alpha: 0.5 } });
        graphics.fillCircle(player.x, player.y, explosionRadius);
        this.tweens.add({
            targets: graphics,
            alpha: 0,
            scale: 2,
            duration: 300,
            onComplete: () => graphics.destroy()
        });
    }}
  ];

  Phaser.Utils.Array.Shuffle(cardOptions);
  const selectedCards = cardOptions.slice(0, 3); // Always show 3 cards

  cardsGroup = this.add.group();

  const startX = this.cameras.main.centerX;
  const startY = this.cameras.main.centerY;
  const gap = 220;

  selectedCards.forEach((card, i) => {
    const x = startX + (i - 1) * gap;
    const y = startY;

    const container = this.add.container(x, y);
    const bgImage = this.add.image(0, 0, 'cardBg').setDisplaySize(160, 240).setTint(card.cor); // Apply card color
  
    const title = this.add.text(0, -80, card.nome, { fontSize: '20px', color: '#fff', align: 'center', wordWrap: { width: 140 } }).setOrigin(0.5);
    const desc = this.add.text(0, 0, card.desc, { fontSize: '14px', color: '#eee', align: 'center', wordWrap: { width: 140 } }).setOrigin(0.5);

    container.add([bgImage, title, desc]);

    container.setSize(160, 240);
    container.setInteractive();

    this.tweens.add({
      targets: container,
      y: y - 20,
      yoyo: true,
      repeat: -1,
      duration: 1000,
      ease: 'Sine.easeInOut'
    });

    container.on('pointerover', () => {
      container.setScale(1.1);
    });

    container.on('pointerout', () => {
      container.setScale(1);
    });

    container.on('pointerdown', () => {
      this.tweens.add({
        targets: container,
        scale: 0.9,
        duration: 100,
        yoyo: true,
        ease: 'Power1',
        onComplete: () => {
          card.efeito();
          cardsGroup.clear(true, true);

          playerCards.push(card);
          atualizarHUDCartas(this);

          showingCards = false;
          wave++;
          waveText.setText(`Fase ${wave}`);
          spawnWave.call(this);
        }
      });
    });

    cardsGroup.add(container);
  });
}

function ativarSpiritAlly() {
  if (spiritAlly) spiritAlly.destroy();

  spiritAlly = this.physics.add.sprite(player.x, player.y, 'player').setScale(0.03).setAlpha(0.7);
  playerStats.spiritAllyActive = true;

  this.time.addEvent({
    delay: 15000,
    callback: () => {
      if (spiritAlly) spiritAlly.destroy();
      playerStats.spiritAllyActive = false;
    },
    callbackScope: this 
  });
}
// --- LÓGICA ATUALIZADA DO SPAWN DE ONDA ---
function spawnWave() {
  // Clear existing enemies and enemy bullets before spawning a new wave
  enemies.clear(true, true);
  enemyBullets.clear(true, true);

  if (wave % 5 === 0) { // Every 5 waves, spawn a boss
    spawnBoss.call(this);
  } else {
    const totalEnemiesToSpawn = Math.floor(wave * 2.5); // Número total de inimigos, ajustado para crescer um pouco mais rápido

    for (let i = 0; i < totalEnemiesToSpawn; i++) {
      const x = Phaser.Math.Between(100, config.width - 100); 
      const y = Phaser.Math.Between(100, config.height - 100); 

      let enemyTypeKey = 'normal'; // Tipo de inimigo padrão

      // Define probabilities for each enemy type based on wave
      let normalChance = 100;
      let fastChance = 0;
      let tankChance = 0;

      if (wave >= 3) {
          normalChance -= (5 + wave * 2); // Reduce normal chance
          fastChance += (5 + wave * 2); // Increase fast chance
      }
      if (wave >= 5) {
          normalChance -= (5 + wave * 1.5); // Further reduce normal
          tankChance += (5 + wave * 1.5); // Increase tank chance
      }

      // Clamp chances to ensure they are within valid range (0-100)
      normalChance = Phaser.Math.Clamp(normalChance, 0, 100);
      fastChance = Phaser.Math.Clamp(fastChance, 0, 100 - normalChance); 
      tankChance = Phaser.Math.Clamp(tankChance, 0, 100 - normalChance - fastChance); 

      const totalChance = normalChance + fastChance + tankChance;
      const normalizedRand = Phaser.Math.Between(0, totalChance); 

      if (normalizedRand < normalChance) {
          enemyTypeKey = 'normal';
      } else if (normalizedRand < normalChance + fastChance) {
          enemyTypeKey = 'fast';
      } else {
          enemyTypeKey = 'tank';
      }
      
      const typeProps = enemyTypes[enemyTypeKey];
      const enemy = enemies.create(x, y, typeProps.texture).setScale(typeProps.scale);
      
      enemy.health = typeProps.baseHealth + Math.floor(wave / 2); // Vida base + escalonamento pela wave
      enemy.maxHealth = enemy.health;
      enemy.speed = typeProps.speed + Math.floor(wave * 2); // Velocidade base + escalonamento pela wave
      enemy.xpReward = typeProps.xpReward; // Store XP reward
      enemy.setCollideWorldBounds(true);
      enemy.enemyTypeKey = enemyTypeKey; // Store the type for potential future use (e.g., specific behaviors)
    }
  }
  if (playerStats.increasedDropRate) {
    spawnArmas.call(this); // Spawn more weapons if the card is active
  }
}

function spawnBoss() {
  console.log("Spawning Boss!");
  const x = config.width / 2;
  const y = config.height / 4;
  
  // Boss stats scale with wave number (every 5 waves)
  // Example: Wave 5 = multiplier 1, Wave 10 = multiplier 2, Wave 15 = multiplier 3
  const bossMultiplier = (wave / 5); 
  const bossHealthMultiplier = 1 + bossMultiplier * 2; // 2x stronger every 5 waves
  const bossSpeedMultiplier = 1 + bossMultiplier * 0.5; // Slightly faster
  const bossDamageMultiplier = 1 + bossMultiplier * 0.5; // More damage

  const boss = enemies.create(x, y, 'boss').setScale(0.2); // Adjust scale as needed
  boss.isBoss = true;
  boss.health = 50 * bossHealthMultiplier; 
  boss.maxHealth = boss.health;
  boss.speed = 80 * bossSpeedMultiplier;
  boss.xpReward = 50 * bossMultiplier; // Boss gives more XP
  boss.setCollideWorldBounds(true);
  boss.enemyTypeKey = 'boss';

  // Boss attack pattern (example: more frequent or multiple bullets)
  this.time.addEvent({
    delay: 3000 / bossDamageMultiplier, // Faster attacks with more waves
    loop: true,
    callback: () => {
      if (boss && boss.active && player.active) {
        const bullet = enemyBullets.create(boss.x, boss.y, 'bullet').setScale(0.05);
        const angle = Phaser.Math.Angle.Between(boss.x, boss.y, player.x, player.y);
        this.physics.velocityFromRotation(angle, 200, bullet.body.velocity);
      }
    }
  });
}

// --- FIM LÓGICA ATUALIZADA DO SPAWN DE ONDA ---

function dashPlayer() {
  if (playerStats.dashCooldown) return;

  playerStats.dashCooldown = true;

  let dx = 0, dy = 0;
  if (cursors.left.isDown) dx = -1;
  else if (cursors.right.isDown) dx = 1;
  if (cursors.up.isDown) dy = -1;
  else if (cursors.down.isDown) dy = 1;

  if (dx === 0 && dy === 0) {
    playerStats.dashCooldown = false;
    return;
  }

  const dashDistance = 150;

  this.tweens.add({
    targets: player,
    x: player.x + dx * dashDistance,
    y: player.y + dy * dashDistance,
    duration: 150,
    ease: 'Power2',
    onComplete: () => {
      playerStats.dashCooldown = false;
    }
  });
}

class HUD {
  constructor(scene, player) {
    this.scene = scene;
    this.player = player;

    // Removed this.maxHealth and this.currentHealth here, directly use playerStats

    this.heartSize = 30;
    this.heartSpacing = 10;

    this.heartsGroup = this.scene.add.group();

    this.createHearts();

    // Barra de vida do inimigo
    this.enemyHealthBarBg = this.scene.add.graphics();
    this.enemyHealthBarFill = this.scene.add.graphics();

    this.enemyHealthBarX = 20;
    this.enemyHealthBarY = 60;
    this.enemyHealthBarWidth = 150;
    this.enemyHealthBarHeight = 20;

    this.enemy = null; // inimigo que tá na mira
  }

  createHearts() {
    this.heartsGroup.clear(true, true);

    for (let i = 0; i < playerStats.maxLife; i++) { // Use playerStats.maxLife here
      const x = 20 + i * (this.heartSize + this.heartSpacing);
      const heart = this.scene.add.image(x, 20, 'cora')
        .setScrollFactor(0)
        .setScale(this.heartSize / 16)
        .setOrigin(0, 0);
      this.heartsGroup.add(heart);
    }
  }

  update() {
    // Atualiza corações conforme vida do player
    for (let i = 0; i < this.heartsGroup.getLength(); i++) {
      const heart = this.heartsGroup.getChildren()[i];
      if (i < playerStats.life) { // Use playerStats.life
        heart.setAlpha(1);
      } else {
        heart.setAlpha(0.3);
      }
    }

    // Atualiza barra de vida do inimigo (se tiver algum inimigo ativo na mira)
    if (this.enemy && this.enemy.active && !this.enemy.isBoss) { // Don't show for boss
      this.enemyHealthBarBg.clear();
      this.enemyHealthBarFill.clear();

      this.enemyHealthBarBg.fillStyle(0x000000, 0.6);
      this.enemyHealthBarBg.fillRect(this.enemyHealthBarX, this.enemyHealthBarY, this.enemyHealthBarWidth, this.enemyHealthBarHeight);

      const healthPercent = Phaser.Math.Clamp(this.enemy.health / this.enemy.maxHealth, 0, 1);
      this.enemyHealthBarFill.fillStyle(0xff0000, 1);
      this.enemyHealthBarFill.fillRect(this.enemyHealthBarX, this.enemyHealthBarY, this.enemyHealthBarWidth * healthPercent, this.enemyHealthBarHeight);
    } else {
      // Limpa barra quando não tem inimigo ou se é um boss
      this.enemyHealthBarBg.clear();
      this.enemyHealthBarFill.clear();
    }
  }

  setEnemy(enemy) {
    this.enemy = enemy;
  }
}

</script>

</body>
</html>

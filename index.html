<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0a0000ce;
    }
    canvas {
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
  
<script>
const config = {
  type: Phaser.AUTO,
  width: 1300,
  height: 590,
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: { debug: false }
  },
  scene: {
    preload,
    create,
    update
  }
};

let waveText;
let hudGroup;
let armaNomeText;
let armaImagem;
let player, cursors;
let bullets, enemies, enemyBullets, armas;
let lastShoot = 0;
let showingCards = false;
let wave = 1;
let cardsGroup;
let playerSpeed = 200;
let spiritAlly = null;

let playerStats = {
  life: 3,
  bulletDamage: 1,
  fireRate: 3000,
  hasShield: false,
  spiritAllyActive: false,
  spreadUpgrade: false,
  doubleBullets: false,
  dashAvailable: false,
  dashCooldown: false
};

const tiposDeArmas = {
  arma1: { dano: 1, fireRate: 1300 }, // Pistola rápida
  arma2: { dano: 2, fireRate: 1000 }, // Metralhadora média
  arma3: { dano: 3, fireRate: 2000 } // Lança-raio brabo
};

const game = new Phaser.Game(config);

function preload() {
  this.load.image('player', 'assets/player.png');
  this.load.image('enemy', 'assets/enemy.png');
  this.load.image('bullet', 'assets/bullet.png');
  this.load.image('arma1', 'assets/pistola.png');
  this.load.image('arma2', 'assets/metralha.png');
  this.load.image('arma3', 'assets/lancarrio.png');
  this.load.image('fundogame', 'assets/fundogame.png');
}

function create() {
  this.add.image(config.width / 2, config.height / 2, 'fundogame').setDepth(-1);

  player = this.physics.add.sprite(400, 300, 'player').setCollideWorldBounds(true).setScale(0.05);

  bullets = this.physics.add.group();
  enemies = this.physics.add.group();
  enemyBullets = this.physics.add.group();
  armas = this.physics.add.group();

  cursors = this.input.keyboard.createCursorKeys();

  spawnArmas.call(this);

  this.physics.add.overlap(player, armas, (player, arma) => {
    pegarArma.call(this, arma);
  });

  this.input.keyboard.on('keydown-Z', () => {
    if (playerStats.dashAvailable && !playerStats.dashCooldown) {
      dashPlayer.call(this);
    }
  });

  this.input.keyboard.on('keydown-SPACE', () => {
    if (!player.active) {
      this.cameras.main.fadeOut(500, 0, 0, 0);
      this.time.delayedCall(500, () => {
        this.scene.restart();
      });
    }
  });

  spawnWave.call(this);

  this.physics.add.overlap(bullets, enemies, (b, e) => {
    if (b.active && e.active) {
      b.destroy();
      e.health = (e.health || 1) - playerStats.bulletDamage;
      if (e.health <= 0) e.destroy();
    }
  });

  this.physics.add.overlap(enemyBullets, player, (b, p) => {
    if (b.active && p.active) {
      b.destroy();
      if (!playerStats.hasShield) {
        p.setTint(0xff0000);
        this.time.delayedCall(100, () => p.clearTint());
      } else {
        playerStats.hasShield = false;
        this.cameras.main.setZoom(1);
        p.clearTint();
      }
    }
    bullets.children.each(function(bullet) {
  if (bullet.active) {
    if (this.time.now - bullet.spawnTime > bullet.lifespan) {
      bullet.setActive(false);
      bullet.setVisible(false);
      bullet.body.enable = false;
    }
  }
}, this);

  });

  hudGroup = this.add.group();

  armaNomeText = this.add.text(config.width / 2, 20, 'Pistolinha', {
    fontFamily: 'Arial Black',
    fontSize: '28px',
    color: '#FFD700',
    stroke: '#000000',
    strokeThickness: 4,
    shadow: { offsetX: 2, offsetY: 2, color: '#000', blur: 4, stroke: true, fill: true }
  }).setOrigin(0.5, 0);

  const box = this.add.rectangle(config.width / 2, 40, 300, 70, 0x111111, 0.3).setOrigin(0.5, 0);
  box.setStrokeStyle(2, 0x00ffff, 0.7);
  hudGroup.add(box);

  armaImagem = this.add.image(config.width / 2, 70, 'arma1').setScale(0.3);
  hudGroup.addMultiple([armaNomeText, armaImagem]);

  waveText = this.add.text(config.width - 20, 20, `Fase ${wave}`, {
    fontFamily: 'Cinzel',
    fontSize: '24px',
    color: '#FFFFFF',
    stroke: '#000000',
    strokeThickness: 4
  }).setOrigin(1, 0);

  this.time.addEvent({
    delay: 9000,
    loop: true,
    callback: () => {
      enemies.getChildren().forEach(enemy => {
        if (!enemy.active) return;
        const bullet = enemyBullets.create(enemy.x, enemy.y, 'bullet').setScale(0.01);
        const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
        this.physics.velocityFromRotation(angle, 150, bullet.body.velocity);
      });
    }
  });
}

function spawnArmas() {
  const tipos = Object.keys(tiposDeArmas);

  for (let i = 0; i < 3; i++) {
    const tipo = Phaser.Utils.Array.GetRandom(tipos);
    const x = Phaser.Math.Between(100, 1200);
    const y = Phaser.Math.Between(100, 500);
    const arma = armas.create(x, y, tipo).setScale(0.01);
    arma.tipo = tipo;
  }
}

function pegarArma(arma) {
  const props = tiposDeArmas[arma.tipo];

  playerStats.bulletDamage = props.dano;
  playerStats.fireRate = props.fireRate;

  arma.destroy();

  const nomeArmasMap = {
    arma1: 'Pistolinha',
    arma2: 'Fúria de Eryon',
    arma3: 'Lança-Raio'
  };

  atualizarHUDarma(nomeArmasMap[arma.tipo], arma.tipo);

  // Feedback visual style favela-glitch
  this.add.text(player.x, player.y - 30, `Pegou ${nomeArmasMap[arma.tipo]}!`, {
    fontSize: '18px',
    color: '#FFD700',
    fontStyle: 'bold',
    stroke: '#000',
    strokeThickness: 3
  }).setOrigin(0.5).setDepth(99).setScrollFactor(0).setAlpha(0.9)
    .setInteractive()
    .on('pointerdown', txt => txt.destroy());
}

function atualizarHUDarma(nomeArma, keyImagem) {
  armaNomeText.setText(nomeArma);
  armaImagem.setTexture(keyImagem);
}

function update(time) {
  if (!player.active) return;

  let vx = 0, vy = 0;
  if (cursors.left.isDown) vx = -1;
  else if (cursors.right.isDown) vx = 1;

  if (cursors.up.isDown) vy = -1;
  else if (cursors.down.isDown) vy = 1;

  const norm = Math.hypot(vx, vy) || 1;
  player.setVelocity((vx / norm) * playerSpeed, (vy / norm) * playerSpeed);

  if (time > lastShoot + playerStats.fireRate) {
    shootRadial.call(this);
    lastShoot = time;
  }

  enemies.getChildren().forEach(enemy => {
    if (!enemy.active) return;
    const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
    this.physics.velocityFromRotation(angle, 100, enemy.body.velocity);
  });

  if (enemies.countActive() === 0 && !showingCards) {
    showingCards = true;
    showCardChoices.call(this);
  }
}

function shootRadial() {
  const count = playerStats.spreadUpgrade ? 24 : 12;
  const speed = 700;

  for (let i = 0; i < count; i++) {
    const angle = Phaser.Math.DegToRad((360 / count) * i);
    const bullet = bullets.create(player.x, player.y, 'bullet').setScale(0.01);
    this.physics.velocityFromRotation(angle, speed, bullet.body.velocity);
  }
}

function showCardChoices() {
  const cardOptions = [
    { nome: 'Escudo da Favela', desc: 'Proteção que te salva da morte uma vez', efeito: () => { playerStats.hasShield = true; } },
    { nome: 'Tiro Duplo', desc: 'Dispara duas vezes mais balas', efeito: () => { playerStats.doubleBullets = true; } },
    { nome: 'Bênção do Espírito', desc: 'Espírito aliado ajuda no ataque', efeito: ativarSpiritAlly },
    { nome: 'Upgrade do Spread', desc: 'Dispara balas em círculo maior', efeito: () => { playerStats.spreadUpgrade = true; } },
    { nome: 'Dash da Quebrada', desc: 'Corrida rápida para escapar', efeito: () => { playerStats.dashAvailable = true; } }
  ];

  cardsGroup = this.add.group();

  const startX = 200;
  const startY = 200;
  const gap = 180;

  cardOptions.forEach((card, i) => {
    const cardContainer = this.add.container(startX + i * gap, startY);

    const cardBg = this.add.rectangle(0, 0, 150, 200, 0x222222, 0.8).setStrokeStyle(2, 0x00ffff);
    const cardNome = this.add.text(0, -70, card.nome, { fontSize: '18px', color: '#fff' }).setOrigin(0.5);
    const cardDesc = this.add.text(0, 10, card.desc, { fontSize: '14px', color: '#ddd', wordWrap: { width: 140 } }).setOrigin(0.5);

    cardContainer.add([cardBg, cardNome, cardDesc]);
    cardContainer.setSize(150, 200);
    cardContainer.setInteractive();

    cardContainer.on('pointerdown', () => {
      card.efeito();
      cardsGroup.clear(true, true);
      showingCards = false;
      wave++;
      waveText.setText(`Fase ${wave}`);
      spawnWave.call(this);
    });

    cardsGroup.add(cardContainer);
  });
}

function ativarSpiritAlly() {
  if (spiritAlly) spiritAlly.destroy();

  spiritAlly = this.physics.add.sprite(player.x, player.y, 'player').setScale(0.03).setAlpha(0.7);
  playerStats.spiritAllyActive = true;

  this.time.addEvent({
    delay: 15000,
    callback: () => {
      if (spiritAlly) spiritAlly.destroy();
      playerStats.spiritAllyActive = false;
    }
  });
}

function dashPlayer() {
  playerStats.dashCooldown = true;
  this.tweens.add({
    targets: player,
    x: player.x + (cursors.left.isDown ? -150 : cursors.right.isDown ? 150 : 0),
    y: player.y + (cursors.up.isDown ? -150 : cursors.down.isDown ? 150 : 0),
    duration: 150,
    ease: 'Power2',
    onComplete: () => {
      playerStats.dashCooldown = false;
    }
  });
}
function shootBullet(x, y, velocityX, velocityY) {
  const bullet = bullets.get(x, y); // pega uma bala do pool

  if (bullet) {
    bullet.setActive(true);
    bullet.setVisible(true);
    bullet.body.enable = true;

    bullet.setVelocity(velocityX, velocityY);

    // Depois de 2 segundos, destrói a bala
    bullet.lifespan = 1000; // 2 segundos em milissegundos
    bullet.spawnTime = this.time.now; // registra o tempo de criação
  }
}

function spawnWave() {
  for (let i = 0; i < wave * 3; i++) {
    const x = Phaser.Math.Between(100, 1200);
    const y = Phaser.Math.Between(100, 500);
    const enemy = enemies.create(x, y, 'enemy').setScale(0.05);
    enemy.health = 3 + wave;
    enemy.setCollideWorldBounds(true);
  }
}

</script>

</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons V.1.2.7 - Multi-Enemy Update</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0a0000ce;
    }
    canvas {
      display: block;
      margin: auto;}
  </style>
</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 1300,
  height: 580,
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: { debug: false }
  },
  scene: {
    preload,
    create,
    update
  }
};

let waveText;
let hudGroup;
let armaNomeText;
let armaImagem;
let player, cursors;
let bullets, enemyBullets;
let enemies;
let score = 0;
let scoreText;
let currentWave = 1;
let enemiesPerWave = 5;
let spawnTimer;
let enemiesAlive = 0;
let enemiesToSpawn = 0;
let bossHealthBarBg, bossHealthBarFill;
let bossNameText;

let playerStats = {
  life: 5,
  maxLife: 5,
  speed: 200,
  fireRate: 300, // milissegundos entre tiros
  bulletSpeed: 500,
  bulletDamage: 1,
  currentWeapon: 'pistol',
  canShoot: true
};

const weapons = {
  pistol: {
    name: 'Pistola',
    damage: 1,
    fireRate: 300,
    bulletSpeed: 500,
    ammo: Infinity,
    bulletSprite: 'bullet', // Default bullet
    icon: 'pistol_icon'
  },
  machinegun: {
    name: 'Metralhadora',
    damage: 0.5,
    fireRate: 100,
    bulletSpeed: 600,
    ammo: 150,
    bulletSprite: 'bullet', // Default bullet
    icon: 'machinegun_icon'
  },
  shotgun: {
    name: 'Escopeta',
    damage: 1.5,
    fireRate: 700,
    bulletSpeed: 400,
    ammo: 30,
    pellets: 5, // Para escopeta
    bulletSprite: 'bullet', // Could use a specific shotgun pellet sprite if you have one
    icon: 'shotgun_icon'
  },
  laser: {
    name: 'Laser',
    damage: 2,
    fireRate: 150,
    bulletSpeed: 700,
    ammo: 100,
    isLaser: true, // Flag para projéteis de laser
    bulletSprite: 'laser_bullet',
    icon: 'laser_icon'
  },
  rocketlauncher: {
    name: 'Lança-Foguetes',
    damage: 5,
    fireRate: 1000,
    bulletSpeed: 300,
    ammo: 10,
    isExplosive: true, // Flag para explosões
    bulletSprite: 'rocket',
    icon: 'rocketlauncher_icon'
  }
};

let activePowerUps = {};
let powerUpDuration = 10000; // 10 segundos
let powerUpGroup; // Grupo para os power-ups

let cards = {
  lifeBoost: {
    nome: 'Vida Extra',
    descricao: 'Aumenta sua vida máxima em 1.',
    efeito: (scene) => {
      playerStats.maxLife++;
      playerStats.life = playerStats.maxLife; // Cura total ao ganhar vida extra
      scene.hud.updateHearts(); // Atualiza o HUD de corações
    },
    cor: 0x4CAF50, // Verde
    sprite: 'heart_powerup'
  },
  speedBoost: {
    nome: 'Super Velocidade',
    descricao: 'Aumenta a velocidade do jogador.',
    efeito: (scene) => {
      playerStats.speed += 50;
      scene.time.delayedCall(powerUpDuration, () => {
        playerStats.speed -= 50;
      });
    },
    cor: 0x2196F3, // Azul
    sprite: 'speed_powerup'
  },
  fireRateBoost: {
    nome: 'Tiro Rápido',
    descricao: 'Diminui o tempo entre os tiros.',
    efeito: (scene) => {
      playerStats.fireRate -= 50;
      if (playerStats.fireRate < 50) playerStats.fireRate = 50; // Limite mínimo
      scene.time.delayedCall(powerUpDuration, () => {
        playerStats.fireRate += 50;
      });
    },
    cor: 0xFF9800, // Laranja
    sprite: 'firerate_powerup'
  },
  damageBoost: {
    nome: 'Dano Brutal',
    descricao: 'Aumenta o dano das suas balas.',
    efeito: (scene) => {
      playerStats.bulletDamage += 0.5;
      scene.time.delayedCall(powerUpDuration, () => {
        playerStats.bulletDamage -= 0.5;
      });
    },
    cor: 0xF44336, // Vermelho
    sprite: 'damage_powerup'
  },
  multishot: {
    nome: 'Tiro Múltiplo',
    descricao: 'Atira 3 balas em um pequeno arco.',
    efeito: (scene) => {
      activePowerUps.multiShot = true;
      scene.time.delayedCall(powerUpDuration, () => {
        delete activePowerUps.multiShot;
      });
    },
    cor: 0x9C27B0, // Roxo
    sprite: 'multishot_powerup'
  },
  grenade: {
    nome: 'Granada',
    descricao: 'Joga uma granada que explode.',
    efeito: (scene) => {
      // Implementar lógica da granada
      console.log('Granada ativada!');
    },
    cor: 0x607D8B, // Cinza
    sprite: 'grenade_powerup'
  }
};

let playerWeapons = {
  pistol: true,
  machinegun: false,
  shotgun: false,
  laser: false,
  rocketlauncher: false
};

let currentCardChoices = [];
let cardsHUDGroup; // Novo grupo para o HUD das cartas
let activeCardCount = {}; // Contador de cartas ativas

// Classe HUD para gerenciar a interface do usuário
class HUD extends Phaser.Scene {
  constructor() {
    super({ key: 'HUD', active: true });
    this.enemy = null; // Inimigo atualmente visado para barra de vida
    this.heartSize = 32; // Tamanho dos corações
  }

  preload() {
    // No images to preload in HUD, main scene handles it
  }

  create() {
    const mainScene = this.scene.get('default');

    scoreText = this.add.text(10, 10, 'Pontos: 0', { fontSize: '20px', fill: '#fff' }).setScrollFactor(0);
    waveText = this.add.text(this.game.config.width - 10, 10, 'Onda: 1', { fontSize: '20px', fill: '#fff' }).setOrigin(1, 0).setScrollFactor(0);

    hudGroup = this.add.group();
    hudGroup.add(scoreText);
    hudGroup.add(waveText);

    // Adiciona o HUD da arma (agora com imagem)
    armaImagem = this.add.image(10 + 16, 40 + 16, weapons[playerStats.currentWeapon].icon).setScale(0.8).setScrollFactor(0).setDepth(1);
    armaNomeText = this.add.text(armaImagem.x + armaImagem.displayWidth / 2 + 5, armaImagem.y - armaImagem.displayHeight / 2 + 5, weapons[playerStats.currentWeapon].name, { fontSize: '18px', fill: '#fff' }).setScrollFactor(0);
    this.ammoText = this.add.text(armaNomeText.x, armaNomeText.y + 20, '', { fontSize: '16px', fill: '#fff' }).setScrollFactor(0);
    hudGroup.add(armaImagem);
    hudGroup.add(armaNomeText);
    hudGroup.add(this.ammoText);

    // HUD de corações
    this.heartsGroup = this.add.group();
    this.updateHearts();

    // HUD para as cartas (inicialmente vazio)
    cardsHUDGroup = this.add.group();
    mainScene.events.on('updateHUDCartas', this.atualizarHUDCartas, this); // Otimizado

    // Barra de vida do boss (inicialmente escondida)
    bossHealthBarBg = this.add.graphics().setScrollFactor(0).setDepth(2);
    bossHealthBarFill = this.add.graphics().setScrollFactor(0).setDepth(2);
    bossNameText = this.add.text(this.game.config.width / 2, 70, '', { fontSize: '20px', fill: '#fff', align: 'center' }).setOrigin(0.5).setScrollFactor(0).setDepth(2);
    this.hideBossHealthBar(); // Esconde no início

    // Barra de vida do inimigo normal
    this.enemyHealthBarBg = this.add.graphics().setScrollFactor(0).setDepth(1);
    this.enemyHealthBarFill = this.add.graphics().setScrollFactor(0).setDepth(1);
    this.enemyHealthBarBg.setVisible(false);
    this.enemyHealthBarFill.setVisible(false);
  }

  updateHearts() {
    this.heartsGroup.clear(true, true); // Limpa corações existentes
    const startX = 10;
    const startY = this.game.config.height - 40; // Perto do canto inferior esquerdo

    for (let i = 0; i < playerStats.maxLife; i++) {
      const x = startX + i * (this.heartSize + 5); // 5px de espaçamento
      const heart = this.add.image(x + this.heartSize / 2, startY + this.heartSize / 2, 'heart_full').setScale(0.8).setScrollFactor(0).setOrigin(0.5);
      this.heartsGroup.add(heart);
    }
    // Atualiza o estado visual dos corações
    for (let i = 0; i < this.heartsGroup.getLength(); i++) {
      const heart = this.heartsGroup.getChildren()[i];
      if (i < playerStats.life) {
        heart.setAlpha(1);
      } else {
        heart.setAlpha(0.3); // Coração "vazio"
      }
    }
  }

  update() {
    // Atualiza corações conforme vida do player
    for (let i = 0; i < this.heartsGroup.getLength(); i++) {
      const heart = this.heartsGroup.getChildren()[i];
      if (i < playerStats.life) {
        heart.setAlpha(1);
      } else {
        heart.setAlpha(0.3);
      }
    }

    // Atualiza barra de vida do inimigo (se tiver algum inimigo ativo na mira)
    if (this.enemy && this.enemy.active && !this.enemy.isBoss) { // Don't show for boss
      // Posição da barra de vida acima do inimigo
      const barX = this.enemy.x - 25 + this.cameras.main.scrollX;
      const barY = this.enemy.y - this.enemy.displayHeight / 2 - 10 + this.cameras.main.scrollY;
      const barWidth = 50;
      const barHeight = 5;

      this.enemyHealthBarBg.clear();
      this.enemyHealthBarBg.fillStyle(0x000000, 0.5);
      this.enemyHealthBarBg.fillRect(barX, barY, barWidth, barHeight);

      this.enemyHealthBarFill.clear();
      this.enemyHealthBarFill.fillStyle(0xff0000, 1);
      this.enemyHealthBarFill.fillRect(barX, barY, barWidth * (this.enemy.health / this.enemy.maxHealth), barHeight);

      this.enemyHealthBarBg.setVisible(true);
      this.enemyHealthBarFill.setVisible(true);
    } else {
      this.enemyHealthBarBg.setVisible(false);
      this.enemyHealthBarFill.setVisible(false);
    }
  }

  // Define o inimigo para mostrar a barra de vida
  setEnemy(enemy) {
    this.enemy = enemy;
  }

  // Esconde a barra de vida do inimigo
  hideEnemyHealthBar() {
    this.enemy = null;
    this.enemyHealthBarBg.setVisible(false);
    this.enemyHealthBarFill.setVisible(false);
  }

  updateScore(newScore) {
    scoreText.setText('Pontos: ' + newScore);
  }

  updateWave(newWave) {
    waveText.setText('Onda: ' + newWave);
  }

  updateWeaponHUD(weaponName, ammo) {
    armaNomeText.setText(weaponName);
    armaImagem.setTexture(weapons[playerStats.currentWeapon].icon); // Update weapon icon

    if (ammo !== Infinity) {
      this.ammoText.setText(`Munição: ${ammo}`);
    } else {
      this.ammoText.setText('');
    }
  }

  showBossHealthBar(boss) {
    const barWidth = this.game.config.width * 0.6; // 60% da largura da tela
    const barHeight = 20;
    const barX = (this.game.config.width - barWidth) / 2;
    const barY = 100; // Posição abaixo do topo

    bossHealthBarBg.clear();
    bossHealthBarBg.fillStyle(0x000000, 0.7);
    bossHealthBarBg.fillRect(barX, barY, barWidth, barHeight);
    bossHealthBarBg.setVisible(true);

    bossHealthBarFill.clear();
    bossHealthBarFill.fillStyle(0xFF0000, 1);
    bossHealthBarFill.fillRect(barX, barY, barWidth * (boss.health / boss.maxHealth), barHeight);
    bossHealthBarFill.setVisible(true);

    bossNameText.setText(boss.name);
    bossNameText.setVisible(true);
  }

  hideBossHealthBar() {
    bossHealthBarBg.setVisible(false);
    bossHealthBarFill.setVisible(false);
    bossNameText.setVisible(false);
  }

  atualizarHUDCartas(activeCardCounts) {
    cardsHUDGroup.clear(true, true); // Limpa antes de redesenhar

    let currentX = this.game.config.width / 2 - (Object.keys(activeCardCounts).length * 60) / 2;
    const startY = this.game.config.height - 90; // Posição inferior para as cartas ativas

    for (const cardName in activeCardCounts) {
      const card = cards[cardName];
      if (!card) continue; // Garante que a carta existe

      // Draw card background using 'cardBg' image
      const bgImage = this.add.image(currentX, startY, 'cardBg').setScale(0.8).setScrollFactor(0);
      cardsHUDGroup.add(bgImage);

      // Add icon to the card
      if (card.sprite) {
        const icon = this.add.image(currentX, startY - 20, card.sprite).setScale(0.5).setScrollFactor(0); // Adjust scale as needed
        cardsHUDGroup.add(icon);
      }

      const countText = this.add.text(currentX, startY + 15, activeCardCounts[cardName], {
        fontSize: '18px',
        color: '#fff',
        fixedWidth: 50,
        align: 'center'
      }).setOrigin(0.5).setScrollFactor(0);
      cardsHUDGroup.add(countText);

      currentX += 60; // Espaçamento entre as cartas
    }
  }
}

let game = new Phaser.Game(config);

function preload() {
  this.load.image('player', 'assets/player.png');
  this.load.image('bullet', 'assets/bullet.png');
  this.load.image('enemy1', 'assets/enemy_robot.png'); // Inimigo normal
  this.load.image('enemy2', 'assets/enemy_fast.png'); // Inimigo rápido
  this.load.image('enemy3', 'assets/enemy_tank.png'); // Inimigo tanque
  this.load.image('boss1', 'assets/boss_robot.png'); // Boss
  this.load.image('health_pickup', 'assets/health_pickup.png');
  this.load.image('ammo_pickup', 'assets/ammo.png');
  this.load.image('weapon_pickup', 'assets/weapon_pickup.png');
  this.load.image('laser_bullet', 'assets/laser_bullet.png'); // Para projéteis de laser
  this.load.image('rocket', 'assets/rocket.png'); // Para foguetes
  this.load.image('explosion', 'assets/explosion.png'); // Para explosões (pode ser usado como fallback se spritesheet não carregar)
  this.load.image('tile', 'assets/fundogame.png'); // Tile para o fundo

  // Sprites de armas (se tiver ícones específicos)
  this.load.image('pistol_icon', 'assets/pistol_icon.png');
  this.load.image('machinegun_icon', 'assets/metralha.png'); // Alterado para 'metralha.png'
  this.load.image('shotgun_icon', 'assets/shotgun_icon.png'); // Certifique-se que o .png está correto
  this.load.image('laser_icon', 'assets/laser_icon.png');
  this.load.image('rocketlauncher_icon', 'assets/lancarrio.png'); // Alterado para 'lancarrio.png'

  // Sprites de power-ups para as cartas
  this.load.image('heart_powerup', 'assets/heart_powerup.png');
  this.load.image('speed_powerup', 'assets/speed_powerup.png');
  this.load.image('firerate_powerup', 'assets/firerate_powerup.png');
  this.load.image('damage_powerup', 'assets/damage_powerup.png');
  this.load.image('multishot_powerup', 'assets/multishot_powerup.png');
  this.load.image('grenade_powerup', 'assets/grenade_powerup.png');

  this.load.image('heart_full', 'assets/cora.png'); // Coração cheio
  this.load.image('cardBg', 'assets/cardBg.png'); // Fundo para as cartas no pop-up e HUD

  // Carrega spritesheets para animações (se houver)
  this.load.spritesheet('explosion_ss', 'assets/explosion_spritesheet.png', { frameWidth: 64, frameHeight: 64 });
}

function create() {
  this.scene.launch('HUD'); // Inicia a cena HUD
  this.hud = this.scene.get('HUD'); // Pega a referência para a cena HUD

  // Cria um background de tiles
  const worldWidth = 2000; // Largura do mundo
  const worldHeight = 2000; // Altura do mundo
  this.add.tileSprite(0, 0, worldWidth, worldHeight, 'tile').setOrigin(0, 0);
  this.physics.world.setBounds(0, 0, worldWidth, worldHeight);

  // Player
  player = this.physics.add.sprite(config.width / 2, config.height / 2, 'player').setCollideWorldBounds(true).setOrigin(0.5, 0.5);
  player.setDamping(true).setDrag(0.99); // Adiciona inércia ao movimento
  player.body.setSize(player.width * 0.7, player.height * 0.7); // Ajusta o corpo de física para ser menor que a imagem
  player.body.setOffset(player.width * 0.15, player.height * 0.15); // Centraliza o corpo ajustado

  cursors = this.input.keyboard.createCursorKeys();
  this.input.keyboard.on('keydown-SPACE', fireBullet, this);
  this.input.keyboard.on('keydown-ONE', () => switchWeapon('pistol'), this);
  this.input.keyboard.on('keydown-TWO', () => switchWeapon('machinegun'), this);
  this.input.keyboard.on('keydown-THREE', () => switchWeapon('shotgun'), this);
  this.input.keyboard.on('keydown-FOUR', () => switchWeapon('laser'), this);
  this.input.keyboard.on('keydown-FIVE', () => switchWeapon('rocketlauncher'), this);
  this.input.keyboard.on('keydown-E', showLevelUpChoices, this); // Key for Level Up/Card choice

  // Bullets group
  bullets = this.physics.add.group({
    defaultKey: 'bullet', // Default sprite key for bullets
    maxSize: 50, // Max bullets in pool
    runChildUpdate: true
  });

  enemyBullets = this.physics.add.group({
    defaultKey: 'bullet', // Assuming enemies use the same bullet sprite for now
    maxSize: 50,
    runChildUpdate: true
  });

  enemies = this.physics.add.group({
    runChildUpdate: true // Allows individual enemy updates (e.g., movement)
  });

  powerUpGroup = this.physics.add.group({
    runChildUpdate: true
  });

  this.physics.add.collider(player, enemies, hitPlayer, null, this);
  this.physics.add.overlap(bullets, enemies, hitEnemy, null, this); // Changed to overlap for more accurate hits
  this.physics.add.overlap(player, powerUpGroup, collectPowerUp, null, this); // Changed to overlap for pickups
  this.physics.add.overlap(enemyBullets, player, hitPlayerByEnemyBullet, null, this); // Changed to overlap

  // Câmera segue o jogador
  this.cameras.main.setBounds(0, 0, worldWidth, worldHeight);
  this.cameras.main.startFollow(player, true, 0.05, 0.05);

  spawnTimer = this.time.addEvent({
    delay: 2000, // Spawn a cada 2 segundos
    callback: spawnEnemy,
    callbackScope: this,
    loop: true
  });

  this.time.addEvent({
    delay: 1000, // A cada 1 segundo
    callback: () => {
      // Atualiza o HUD das cartas ativas
      this.hud.atualizarHUDCartas(activeCardCount);
    },
    callbackScope: this,
    loop: true
  });

  // Cria as animações de explosão
  this.anims.create({
    key: 'explode',
    frames: this.anims.generateFrameNumbers('explosion_ss', { start: 0, end: 15 }),
    frameRate: 24,
    repeat: 0,
    hideOnComplete: true
  });

  startWave();
}

function update() {
  // Movimento do jogador
  player.setVelocity(0);

  if (cursors.left.isDown) {
    player.setVelocityX(-playerStats.speed);
  } else if (cursors.right.isDown) {
    player.setVelocityX(playerStats.speed);
  }

  if (cursors.up.isDown) {
    player.setVelocityY(-playerStats.speed);
  } else if (cursors.down.isDown) {
    player.setVelocityY(playerStats.speed);
  }

  // Rotação do jogador para olhar para o ponteiro do mouse
  let angle = Phaser.Math.Angle.Between(player.x, player.y, this.input.activePointer.x + this.cameras.main.scrollX, this.input.activePointer.y + this.cameras.main.scrollY);
  player.setRotation(angle + Math.PI / 2); // Ajuste de 90 graus

  // Atirar com o mouse
  if (this.input.activePointer.isDown) {
    fireBullet.call(this);
  }

  // Atualiza barra de vida do inimigo seguindo o inimigo visado
  let closestEnemy = null;
  let minDistance = Infinity;

  enemies.children.each(function (enemy) {
    if (enemy.active && !enemy.isBoss && enemy.health > 0) { // Only show for active, non-boss, alive enemies
      const distance = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
      if (distance < minDistance) {
        minDistance = distance;
        closestEnemy = enemy;
      }
    }
  }, this);

  if (closestEnemy) {
    this.hud.setEnemy(closestEnemy);
  } else {
    this.hud.hideEnemyHealthBar();
  }

  // Lógica para inimigos
  enemies.children.each(function (enemy) {
    if (enemy.active && enemy.health > 0) {
      this.physics.moveToObject(enemy, player, enemy.speed); // Inimigos se movem em direção ao jogador

      // Inimigos atirando (exemplo básico)
      if (enemy.canShoot && enemy.lastShot + enemy.fireRate < this.time.now) {
        let enemyBullet = enemyBullets.get(enemy.x, enemy.y, 'bullet'); // Get a bullet from the pool
        if (enemyBullet) {
          enemyBullet.setActive(true).setVisible(true);
          enemyBullet.setTint(0xFFFF00); // Yellow tint for enemy bullets
          this.physics.moveToObject(enemyBullet, player, enemy.bulletSpeed);
          enemy.lastShot = this.time.now;
        }
      }
    }
  }, this);

  // Limpa balas fora da tela
  bullets.children.each(function (bullet) {
    if (bullet.active && !this.physics.world.bounds.contains(bullet.x, bullet.y)) {
      bullets.killAndHide(bullet);
    }
  }, this);

  enemyBullets.children.each(function (bullet) {
    if (bullet.active && !this.physics.world.bounds.contains(bullet.x, bullet.y)) {
      enemyBullets.killAndHide(bullet);
    }
  }, this);
}

function fireBullet() {
  if (!playerStats.canShoot) return;

  const weapon = weapons[playerStats.currentWeapon];
  if (weapon.ammo <= 0 && weapon.ammo !== Infinity) return;

  const bulletOffset = 30; // Distância do player
  const dx = Math.cos(player.rotation - Math.PI / 2);
  const dy = Math.sin(player.rotation - Math.PI / 2);

  const startX = player.x + dx * bulletOffset;
  const startY = player.y + dy * bulletOffset;

  if (activePowerUps.multiShot && !weapon.pellets && !weapon.isLaser && !weapon.isExplosive) {
    // Tiro múltiplo (power-up)
    for (let i = -1; i <= 1; i++) {
      let bullet = bullets.get(startX, startY, weapon.bulletSprite);
      if (bullet) {
        let angle = player.rotation + i * 0.2; // Pequeno arco
        bullet.setActive(true).setVisible(true);
        bullet.setRotation(angle); // Rotate bullet to match direction
        this.physics.velocityFromRotation(angle - Math.PI / 2, weapon.bulletSpeed, bullet.body.velocity);
      }
    }
  } else if (weapon.pellets) {
    // Escopeta (múltiplos projéteis)
    for (let i = 0; i < weapon.pellets; i++) {
      let bullet = bullets.get(startX, startY, weapon.bulletSprite);
      if (bullet) {
        let angleOffset = Phaser.Math.Between(-15, 15) * Phaser.Math.DEG_TO_RAD; // Espalhamento
        let angle = player.rotation + angleOffset;
        bullet.setActive(true).setVisible(true);
        bullet.setRotation(angle); // Rotate bullet to match direction
        this.physics.velocityFromRotation(angle - Math.PI / 2, weapon.bulletSpeed, bullet.body.velocity);
      }
    }
  } else if (weapon.isLaser) {
    // Laser
    let bullet = bullets.get(startX, startY, weapon.bulletSprite);
    if (bullet) {
      bullet.setActive(true).setVisible(true);
      bullet.setRotation(player.rotation); // Rotate laser to match player direction
      this.physics.velocityFromRotation(player.rotation - Math.PI / 2, weapon.bulletSpeed, bullet.body.velocity);
      // Efeito de laser
      this.add.tween({
        targets: bullet,
        alpha: { from: 1, to: 0.5 },
        duration: weapon.fireRate / 2,
        yoyo: true,
        repeat: 0
      });
    }
  } else if (weapon.isExplosive) {
    // Foguete
    let rocket = bullets.get(startX, startY, weapon.bulletSprite);
    if (rocket) {
      rocket.setActive(true).setVisible(true);
      this.physics.velocityFromRotation(player.rotation - Math.PI / 2, weapon.bulletSpeed, rocket.body.velocity);
      rocket.damage = weapon.damage; // Transfere o dano para a bala para uso na explosão
      rocket.setRotation(player.rotation); // Rotação do foguete
    }
  } else {
    // Tiro normal (pistol/machinegun)
    let bullet = bullets.get(startX, startY, weapon.bulletSprite);
    if (bullet) {
      bullet.setActive(true).setVisible(true);
      bullet.setRotation(player.rotation); // Rotate bullet to match direction
      this.physics.velocityFromRotation(player.rotation - Math.PI / 2, weapon.bulletSpeed, bullet.body.velocity);
    }
  }

  // Atualiza munição (se não for infinita)
  if (weapon.ammo !== Infinity) {
    weapon.ammo--;
    this.hud.updateWeaponHUD(weapon.name, weapon.ammo);
  }

  playerStats.canShoot = false;
  this.time.delayedCall(playerStats.fireRate, () => {
    playerStats.canShoot = true;
  });
}

function hitPlayer(player, enemy) {
  if (player.invincible) return;

  playerStats.life--;
  this.hud.updateHearts();

  if (playerStats.life <= 0) {
    this.physics.pause();
    player.setTint(0xff0000);
    this.add.text(this.cameras.main.scrollX + config.width / 2, this.cameras.main.scrollY + config.height / 2, 'GAME OVER', { fontSize: '64px', fill: '#ff0000' }).setOrigin(0.5);
    this.time.addEvent({
      delay: 2000,
      callback: () => {
        this.scene.restart();
        this.scene.launch('HUD');
        playerStats = {
          life: 5,
          maxLife: 5,
          speed: 200,
          fireRate: 300,
          bulletSpeed: 500,
          bulletDamage: 1,
          currentWeapon: 'pistol',
          canShoot: true
        };
        score = 0;
        currentWave = 1;
        enemiesPerWave = 5;
        enemiesAlive = 0;
        enemiesToSpawn = 0;
        playerWeapons = {
          pistol: true,
          machinegun: false,
          shotgun: false,
          laser: false,
          rocketlauncher: false
        };
        activePowerUps = {};
        activeCardCount = {};
      },
      callbackScope: this
    });
  } else {
    player.setTint(0xff0000);
    player.invincible = true;
    this.time.delayedCall(1000, () => {
      player.clearTint();
      player.invincible = false;
    });
  }
}

function hitPlayerByEnemyBullet(player, bullet) {
  enemyBullets.killAndHide(bullet);
  if (player.invincible) return;

  playerStats.life -= 1;
  this.hud.updateHearts();

  if (playerStats.life <= 0) {
    this.physics.pause();
    player.setTint(0xff0000);
    this.add.text(this.cameras.main.scrollX + config.width / 2, this.cameras.main.scrollY + config.height / 2, 'GAME OVER', { fontSize: '64px', fill: '#ff0000' }).setOrigin(0.5);
    this.time.addEvent({
      delay: 2000,
      callback: () => {
        this.scene.restart();
        this.scene.launch('HUD');
        playerStats = {
          life: 5,
          maxLife: 5,
          speed: 200,
          fireRate: 300,
          bulletSpeed: 500,
          bulletDamage: 1,
          currentWeapon: 'pistol',
          canShoot: true
        };
        score = 0;
        currentWave = 1;
        enemiesPerWave = 5;
        enemiesAlive = 0;
        enemiesToSpawn = 0;
        playerWeapons = {
          pistol: true,
          machinegun: false,
          shotgun: false,
          laser: false,
          rocketlauncher: false
        };
        activePowerUps = {};
        activeCardCount = {};
      },
      callbackScope: this
    });
  } else {
    player.setTint(0xff0000);
    player.invincible = true;
    this.time.delayedCall(1000, () => {
      player.clearTint();
      player.invincible = false;
    });
  }
}

function hitEnemy(bullet, enemy) {
  if (weapons[playerStats.currentWeapon].isExplosive && bullet.texture.key === 'rocket') {
    createExplosion.call(this, bullet.x, bullet.y);
    bullets.killAndHide(bullet); // Deactivate and hide rocket
    enemies.children.each(function (e) {
      const distance = Phaser.Math.Distance.Between(bullet.x, bullet.y, e.x, e.y);
      if (distance < 100 && e.active && e.health > 0) { // Check active and not destroyed, and alive
        e.health -= bullet.damage;
        if (e.health <= 0) {
          e.destroy();
          score += 10;
          this.hud.updateScore(score);
          enemiesAlive--;
          if (e.isBoss) {
            this.hud.hideBossHealthBar();
            this.time.delayedCall(1000, showLevelUpChoices, [], this);
          } else {
            if (Phaser.Math.RND.between(1, 100) <= 20) {
              spawnPowerUp.call(this, e.x, e.y);
            }
          }
        }
      }
    }, this);
  } else {
    bullets.killAndHide(bullet); // For other bullets, simply kill and hide the bullet
    enemy.health -= playerStats.bulletDamage * weapons[playerStats.currentWeapon].damage;
  }


  if (enemy.health <= 0 && enemy.active) { // Ensure enemy is active (not already destroyed in same frame)
    enemy.destroy(); // Destroy the enemy sprite
    score += 10;
    this.hud.updateScore(score);
    enemiesAlive--;

    if (enemy.isBoss) {
      this.hud.hideBossHealthBar();
      this.time.delayedCall(1000, showLevelUpChoices, [], this);
    } else {
      if (Phaser.Math.RND.between(1, 100) <= 20) {
        spawnPowerUp.call(this, enemy.x, enemy.y);
      }
    }
  }
}

function spawnEnemy() {
  if (enemiesToSpawn > 0) {
    let x, y;
    let spawnEdge = Phaser.Math.RND.between(0, 3);

    if (spawnEdge === 0) { // Top
      x = Phaser.Math.RND.between(0, this.physics.world.bounds.width);
      y = 0;
    } else if (spawnEdge === 1) { // Right
      x = this.physics.world.bounds.width;
      y = Phaser.Math.RND.between(0, this.physics.world.bounds.height);
    } else if (spawnEdge === 2) { // Bottom
      x = Phaser.Math.RND.between(0, this.physics.world.bounds.width);
      y = this.physics.world.bounds.height;
    } else { // Left
      x = 0;
      y = Phaser.Math.RND.between(0, this.physics.world.bounds.height);
    }

    let enemyType = Phaser.Math.RND.between(1, 3);
    let enemy;
    let enemySpriteKey;
    let enemyWidth, enemyHeight; // To store original image dimensions

    if (enemyType === 1) {
      enemySpriteKey = 'enemy1'; // Normal enemy
      enemyWidth = 32; enemyHeight = 32; // Assuming original image size
    } else if (enemyType === 2) {
      enemySpriteKey = 'enemy2'; // Fast enemy
      enemyWidth = 32; enemyHeight = 32;
    } else {
      enemySpriteKey = 'enemy3'; // Tank enemy
      enemyWidth = 48; enemyHeight = 48;
    }

    enemy = enemies.get(x, y, enemySpriteKey);
    if (!enemy) { // If pool is empty for this key, create new
      enemy = this.physics.add.sprite(x, y, enemySpriteKey);
      enemies.add(enemy);
    }
    enemy.setActive(true).setVisible(true);
    enemy.setCollideWorldBounds(true);
    enemy.setOrigin(0.5, 0.5); // Ensure origin is centered

    if (enemyType === 1) {
      enemy.health = 5;
      enemy.maxHealth = 5;
      enemy.speed = 100;
      enemy.canShoot = false;
      enemy.body.setSize(enemyWidth * 0.8, enemyHeight * 0.8);
    } else if (enemyType === 2) {
      enemy.health = 8;
      enemy.maxHealth = 8;
      enemy.speed = 80;
      enemy.canShoot = true;
      enemy.fireRate = 1500;
      enemy.lastShot = 0;
      enemy.bulletSpeed = 300;
      enemy.body.setSize(enemyWidth * 0.8, enemyHeight * 0.8);
    } else {
      enemy.health = 12;
      enemy.maxHealth = 12;
      enemy.speed = 60;
      enemy.canShoot = false;
      enemy.body.setSize(enemyWidth * 0.8, enemyHeight * 0.8);
    }
    enemy.body.setOffset((enemyWidth - enemy.body.width) / 2, (enemyHeight - enemy.body.height) / 2); // Center adjusted body

    enemiesToSpawn--;
    enemiesAlive++;
  } else if (enemiesAlive === 0 && enemiesToSpawn === 0) {
    endWave.call(this);
  }
}

function startWave() {
  this.hud.updateWave(currentWave);
  enemiesToSpawn = enemiesPerWave;
  enemiesAlive = 0;
  if (currentWave % 5 === 0) {
    spawnBoss.call(this);
  }
  enemiesPerWave += 2;
}

function endWave() {
  currentWave++;
  this.time.delayedCall(2000, startWave, [], this);
}

function spawnBoss() {
  const boss = this.physics.add.sprite(this.physics.world.bounds.width / 2, 100, 'boss1');
  boss.setCollideWorldBounds(true);
  boss.setOrigin(0.5, 0.5); // Center the boss sprite
  enemies.add(boss); // Add to the enemies group

  boss.body.setSize(boss.width * 0.8, boss.height * 0.8); // Adjust body size
  boss.body.setOffset(boss.width * 0.1, boss.height * 0.1); // Center adjusted body

  boss.isBoss = true;
  boss.health = 50 * currentWave;
  boss.maxHealth = boss.health;
  boss.speed = 50;
  boss.name = `Mega-Autômato [Onda ${currentWave}]`;
  this.hud.showBossHealthBar(boss);
  enemiesAlive++;
}

function switchWeapon(newWeapon) {
  if (playerWeapons[newWeapon]) {
    playerStats.currentWeapon = newWeapon;
    playerStats.fireRate = weapons[newWeapon].fireRate;
    playerStats.bulletDamage = weapons[newWeapon].damage;
    playerStats.bulletSpeed = weapons[newWeapon].bulletSpeed;
    this.hud.updateWeaponHUD(weapons[newWeapon].name, weapons[newWeapon].ammo);
  } else {
    console.log(`Arma ${weapons[newWeapon].name} não desbloqueada!`);
  }
}

function spawnPowerUp(x, y) {
  const powerUpTypes = [
    { key: 'health_pickup', type: 'health' },
    { key: 'ammo_pickup', type: 'ammo' },
    { key: 'weapon_pickup', type: 'weapon' }
  ];
  const chosenPowerUp = Phaser.Math.RND.pick(powerUpTypes);

  let powerUp = powerUpGroup.get(x, y, chosenPowerUp.key);
  if (!powerUp) {
    powerUp = this.physics.add.sprite(x, y, chosenPowerUp.key);
    powerUpGroup.add(powerUp);
  } else {
    powerUp.setActive(true).setVisible(true).setPosition(x, y);
  }

  powerUp.type = chosenPowerUp.type; // Assign type for easy lookup
  powerUp.setCollideWorldBounds(true);
  powerUp.setBounce(0.6);
  powerUp.setOrigin(0.5, 0.5); // Center the sprite

  this.tweens.add({
    targets: powerUp,
    y: powerUp.y - 10,
    duration: 800,
    ease: 'Sine.easeInOut',
    yoyo: true,
    repeat: -1
  });
}

function collectPowerUp(player, powerUp) {
  if (powerUp.type === 'health') {
    playerStats.life = Math.min(playerStats.life + 1, playerStats.maxLife);
    this.hud.updateHearts();
  } else if (powerUp.type === 'ammo') {
    const currentWeaponObj = weapons[playerStats.currentWeapon];
    if (currentWeaponObj.ammo !== Infinity) {
      currentWeaponObj.ammo += 50;
      this.hud.updateWeaponHUD(currentWeaponObj.name, currentWeaponObj.ammo);
    } else {
      const availableWeapons = Object.keys(weapons).filter(key => weapons[key].ammo !== Infinity && playerWeapons[key]);
      if (availableWeapons.length > 0) {
        const randomWeaponKey = Phaser.Math.RND.pick(availableWeapons);
        weapons[randomWeaponKey].ammo += 50;
        if (randomWeaponKey === playerStats.currentWeapon) {
          this.hud.updateWeaponHUD(weapons[randomWeaponKey].name, weapons[randomWeaponKey].ammo);
        }
      }
    }
  } else if (powerUp.type === 'weapon') {
    const unownedWeapons = Object.keys(playerWeapons).filter(key => !playerWeapons[key]);
    if (unownedWeapons.length > 0) {
      const newWeaponKey = Phaser.Math.RND.pick(unownedWeapons);
      playerWeapons[newWeaponKey] = true;
      if (weapons[newWeaponKey].ammo !== Infinity) {
        weapons[newWeaponKey].ammo = 50;
      }
      this.hud.updateWeaponHUD(weapons[playerStats.currentWeapon].name, weapons[playerStats.currentWeapon].ammo);
      this.add.text(player.x, player.y - 50, `Arma ${weapons[newWeaponKey].name} desbloqueada!`, { fontSize: '20px', fill: '#00ff00' })
        .setOrigin(0.5)
        .setDepth(1)
        .setAlpha(0)
        .addTween({
          targets: this,
          alpha: 1,
          duration: 500,
          yoyo: true,
          onComplete: function (tween, targets) {
            targets[0].destroy();
          }
        });
    } else {
      playerStats.life = Math.min(playerStats.life + 1, playerStats.maxLife);
      this.hud.updateHearts();
    }
  }
  powerUpGroup.killAndHide(powerUp);
}

function createExplosion(x, y) {
  const explosion = this.add.sprite(x, y, 'explosion_ss');
  explosion.play('explode');
  explosion.setOrigin(0.5, 0.5);
  // Optional: Make explosion not interactive
  explosion.setDepth(5); // Ensure explosion is on top
  explosion.on('animationcomplete', () => {
    explosion.destroy();
  });
}

function showLevelUpChoices() {
  this.physics.pause();
  playerStats.canShoot = false;

  const choicesPanel = this.add.container(this.cameras.main.scrollX + config.width / 2, this.cameras.main.scrollY + config.height / 2);
  choicesPanel.setDepth(100);

  const panelBg = this.add.graphics();
  panelBg.fillStyle(0x000000, 0.8);
  panelBg.fillRect(-350, -150, 700, 300);
  choicesPanel.add(panelBg);

  this.add.text(0, -120, 'Escolha uma Melhoria!', { fontSize: '32px', fill: '#fff' }).setOrigin(0.5).setDepth(1).setContainer(choicesPanel);

  const availableCards = Object.keys(cards);
  currentCardChoices = [];

  while (currentCardChoices.length < 3 && availableCards.length > 0) {
    const randomIndex = Phaser.Math.RND.between(0, availableCards.length - 1);
    const chosenCardName = availableCards[randomIndex];
    currentCardChoices.push(chosenCardName);
    availableCards.splice(randomIndex, 1);
  }

  const cardSpacing = 200;
  let startX = -cardSpacing;

  currentCardChoices.forEach((cardName, index) => {
    const card = cards[cardName];
    const xPos = startX + index * cardSpacing;

    // Draw card background using 'cardBg' image
    const bgImage = this.add.image(xPos, 0, 'cardBg').setScale(0.8);
    bgImage.setInteractive({ useHandCursor: true })
      .on('pointerover', function () { this.setTint(0xAAAAAA); }) // Efeito hover
      .on('pointerout', function () { this.setTint(0xFFFFFF); }) // Volta à cor original da imagem
      .on('pointerdown', () => selecionarCarta.call(this, cardName, choicesPanel)); // Chama a função ao clicar


    const title = this.add.text(xPos, -90, card.nome, { fontSize: '22px', fill: '#fff', align: 'center', wordWrap: { width: 140 } })
      .setOrigin(0.5);
    const description = this.add.text(xPos, -40, card.descricao, { fontSize: '14px', fill: '#ddd', align: 'center', wordWrap: { width: 140 } })
      .setOrigin(0.5);

    // Adiciona o ícone da carta
    if (card.sprite) {
      const icon = this.add.image(xPos, -110, card.sprite).setScale(0.8).setOrigin(0.5);
      choicesPanel.add(icon);
    }


    choicesPanel.add(bgImage);
    choicesPanel.add(title);
    choicesPanel.add(description);
  });
}

function selecionarCarta(cardName, choicesPanel) {
  choicesPanel.destroy(); // Remove o painel de escolhas

  // Aplica o efeito da carta
  const card = cards[cardName];
  card.efeito(this);

  activeCardCount[cardName] = (activeCardCount[cardName] || 0) + 1;
  this.hud.atualizarHUDCartas(activeCardCount);

  this.physics.resume();
  playerStats.canShoot = true;
}
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons V1.3 - A Cruzada da Rainha</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0a0000ce;
    }
    canvas {
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
<script>
// --- VARIÁVEIS GLOBAIS (MOVÍVEL PARA O TOPO) ---
let player, cursors;
let bullets, enemies, enemyBullets, armas, itemsGroup;
let lastShoot = 0;
let xp = 0;
let level = 1;
let score = 0;
let playerHealthText;
let playerXPText;
let playerLevelText;
let weaponNameText;
let weaponImage;
let hudGroup; // <--- CORREÇÃO: Declarado aqui no topo!

let playerStats = {
    health: 100,
    maxHealth: 100,
    speed: 250,
    bulletDamage: 10,
    fireRate: 500,
    bulletSpeedBoost: 1,
    bulletCountMultiplier: 1,
    bulletPiercing: false,
    healthRegen: 0,
    lootMagnet: false,
    critChance: 0,
    critDamage: 1.5,
    xpBonus: 0,
    coins: 0
};
let weaponStats = {
    nome: "Pistola Automática",
    danoBase: 10,
    cadenciaBase: 500
};
let killStreak = 0;
let killStreakTimer;
let temporaryEffectText = null;
let temporaryEffectTimer = null;
let currentWave = 0;
let waveEnemiesRemaining = 0;
let waveTimer;
let waveInterval = 20000;
let waveConfig = [
    { type: 'normal', count: 5, health: 20, speed: 100, scale: 0.6, xp: 5 },
    { type: 'normal', count: 8, health: 25, speed: 110, scale: 0.6, xp: 6 },
    { type: 'fast', count: 3, health: 15, speed: 180, scale: 0.5, xp: 7 },
    { type: 'normal', count: 10, health: 30, speed: 120, scale: 0.6, xp: 8 },
    { type: 'fast', count: 5, health: 20, speed: 190, scale: 0.5, xp: 9 },
    { type: 'tank', count: 2, health: 80, speed: 80, scale: 0.8, xp: 15 },
    { type: 'normal', count: 12, health: 35, speed: 130, scale: 0.6, xp: 10 },
    { type: 'fast', count: 7, health: 25, speed: 200, scale: 0.5, xp: 11 },
    { type: 'tank', count: 3, health: 90, speed: 90, scale: 0.8, xp: 18 },
    { type: 'boss', count: 1, health: 300, speed: 70, scale: 1.2, xp: 50 }
];

let enemyTypes = {
    normal: { texture: 'enemy_robot.png', baseHealth: 20, speed: 100, scale: 0.6, xpReward: 5 },
    fast: { texture: 'enemy_fast.png', baseHealth: 15, speed: 180, scale: 0.5, xpReward: 7 },
    tank: { texture: 'enemy_tank.png', baseHealth: 80, speed: 80, scale: 0.8, xpReward: 15 },
    boss: { texture: 'boss_robot.png', baseHealth: 300, speed: 70, scale: 1.2, xpReward: 50 }
};

// --- NOVA CENA DA LOJA ---
class ShopScene extends Phaser.Scene {
    constructor() {
        super({ key: 'ShopScene' });
    }

    preload() {
        this.load.image('shop_background', 'https://via.placeholder.com/1380x580/333333/FFFFFF?text=Fundo+da+Loja');
    }

    create() {
        const bg = this.add.image(this.cameras.main.width / 2, this.cameras.main.height / 2, 'shop_background');
        bg.setDisplaySize(this.cameras.main.width, this.cameras.main.height);

        this.add.text(this.cameras.main.width / 2, 50, 'Loja de Upgrades', {
            fontSize: '48px',
            fill: '#FFF',
            align: 'center'
        }).setOrigin(0.5);

        this.coinText = this.add.text(this.cameras.main.width / 2, 100, `Moedas: ${playerStats.coins}`, {
            fontSize: '32px',
            fill: '#FFD700',
            align: 'center'
        }).setOrigin(0.5);

        this.add.text(this.cameras.main.width / 2, 200, 'Velocidade Extra', {
            fontSize: '30px',
            fill: '#FFF'
        }).setOrigin(0.5);
        this.add.text(this.cameras.main.width / 2, 240, 'Custo: 100 Moedas', {
            fontSize: '24px',
            fill: '#FFD700'
        }).setOrigin(0.5);

        const buySpeedButton = this.add.text(this.cameras.main.width / 2, 280, 'Comprar', {
            fontSize: '24px',
            fill: '#FFF',
            backgroundColor: '#007BFF',
            padding: { x: 15, y: 8 }
        }).setOrigin(0.5).setInteractive();

        buySpeedButton.on('pointerdown', () => {
            if (playerStats.coins >= 100) {
                playerStats.coins -= 100;
                playerStats.speed += 50;
                this.coinText.setText(`Moedas: ${playerStats.coins}`);
                createFloatingText(this, this.cameras.main.width / 2, 280, 'Comprado!', '#0F0');
            } else {
                createFloatingText(this, this.cameras.main.width / 2, 280, 'Moedas insuficientes!', '#F00');
            }
        });

        this.add.text(this.cameras.main.width / 2, 350, 'Vida Máxima', {
            fontSize: '30px',
            fill: '#FFF'
        }).setOrigin(0.5);
        this.add.text(this.cameras.main.width / 2, 390, 'Custo: 150 Moedas', {
            fontSize: '24px',
            fill: '#FFD700'
        }).setOrigin(0.5);

        const buyHealthButton = this.add.text(this.cameras.main.width / 2, 430, 'Comprar', {
            fontSize: '24px',
            fill: '#FFF',
            backgroundColor: '#007BFF',
            padding: { x: 15, y: 8 }
        }).setOrigin(0.5).setInteractive();

        buyHealthButton.on('pointerdown', () => {
            if (playerStats.coins >= 150) {
                playerStats.coins -= 150;
                playerStats.maxHealth += 25;
                playerStats.health = Math.min(playerStats.health + 25, playerStats.maxHealth);
                this.coinText.setText(`Moedas: ${playerStats.coins}`);
                createFloatingText(this, this.cameras.main.width / 2, 430, 'Comprado!', '#0F0');
            } else {
                createFloatingText(this, this.cameras.main.width / 2, 430, 'Moedas insuficientes!', '#F00');
            }
        });


        const backButton = this.add.text(this.cameras.main.width / 2, this.cameras.main.height - 50, 'Voltar ao Jogo', {
            fontSize: '36px',
            fill: '#0F0',
            backgroundColor: '#333',
            padding: { x: 20, y: 10 }
        }).setOrigin(0.5).setInteractive();

        backButton.on('pointerdown', () => {
            this.scene.stop('ShopScene');
            this.scene.resume('GameScene');
            this.scene.get('GameScene').updateHud();
        });
    }

    update() {
    }
}

// --- CLASSE DA CENA DO JOGO PRINCIPAL ---
class GameScene extends Phaser.Scene {
    constructor() {
        super({ key: 'GameScene' });
    }

    preload() {
        this.load.image('player', 'assets/player.png');
        this.load.image('bullet', 'assets/bullet.png');
        this.load.image('enemy_robot.png', 'assets/enemy_robot.png');
        this.load.image('enemy_fast.png', 'assets/enemy_fast.png');
        this.load.image('enemy_tank.png', 'assets/enemy_tank.png');
        this.load.image('boss_robot.png', 'assets/boss_robot.png');
        this.load.image('pickup_xp', 'assets/pickup_xp.png');
        this.load.image('pickup_health', 'assets/pickup_health.png');
        this.load.image('pickup_coin', 'assets/pickup_coin.png');
        this.load.image('arma1', 'assets/arma1.png');
        this.load.image('arma2', 'assets/arma2.png');
    }

    create() {
        cursors = this.input.keyboard.createCursorKeys();

        bullets = this.physics.add.group();
        enemies = this.physics.add.group();
        enemyBullets = this.physics.add.group();
        itemsGroup = this.physics.add.group();

        player = this.physics.add.sprite(this.physics.world.bounds.width / 2, this.physics.world.bounds.height / 2, 'player');
        player.setCollideWorldBounds(true);
        player.setDepth(1);
        player.health = playerStats.health;
        player.maxHealth = playerStats.maxHealth;
        player.currentWeapon = 0;

        this.createHud();

        this.physics.add.overlap(bullets, enemies, this.hitEnemy, null, this);
        this.physics.add.overlap(player, enemyBullets, this.takeDamage, null, this);
        this.physics.add.overlap(player, itemsGroup, this.collectItem, null, this);
        this.physics.add.overlap(player, enemies, this.playerHitByEnemy, null, this);

        this.input.keyboard.on('keydown-SPACE', () => {
            if (!player.active) {
                this.time.delayedCall(1000, () => {
                    xp = 0;
                    level = 1;
                    score = 0;
                    currentWave = 0;
                    playerStats = {
                        health: 100,
                        maxHealth: 100,
                        speed: 250,
                        bulletDamage: 10,
                        fireRate: 500,
                        bulletSpeedBoost: 1,
                        bulletCountMultiplier: 1,
                        bulletPiercing: false,
                        healthRegen: 0,
                        lootMagnet: false,
                        critChance: 0,
                        critDamage: 1.5,
                        xpBonus: 0,
                        coins: 0
                    };
                    weaponStats = {
                        nome: "Pistola Automática",
                        danoBase: 10,
                        cadenciaBase: 500
                    };
                    killStreak = 0;
                    this.scene.restart();
                });
            }
        });

        this.startWave();

        this.time.addEvent({
            delay: 1000,
            callback: () => {
                if (playerStats.healthRegen > 0 && player.health < player.maxHealth) {
                    player.health = Math.min(player.health + playerStats.healthRegen, player.maxHealth);
                    this.updateHud();
                }
            },
            loop: true
        });

        const shopButton = this.add.text(this.game.config.width - 150, 50, 'Loja', {
            fontSize: '28px',
            fill: '#FF0',
            backgroundColor: '#6A0DAD',
            padding: { x: 15, y: 8 }
        }).setOrigin(0.5).setInteractive();

        shopButton.on('pointerdown', () => {
            this.scene.pause('GameScene');
            this.scene.start('ShopScene');
        });
    }

    updateHud() {
        playerHealthText.setText(`Vida: ${player.health}/${player.maxHealth}`);
        playerXPText.setText(`XP: ${xp}/${level * 100}`);
        playerLevelText.setText(`Nível: ${level}`);
        hudGroup.getByName('coinText').setText(`Moedas: ${playerStats.coins}`);
    }

    createHud() {
        hudGroup = this.add.group(); // Inicialização de hudGroup

        playerHealthText = this.add.text(10, 10, `Vida: ${playerStats.health}/${playerStats.maxHealth}`, { fontSize: '24px', fill: '#FFF' });
        playerXPText = this.add.text(10, 40, `XP: ${xp}/${level * 100}`, { fontSize: '24px', fill: '#FFF' });
        playerLevelText = this.add.text(10, 70, `Nível: ${level}`, { fontSize: '24px', fill: '#FFF' });
        weaponNameText = this.add.text(this.game.config.width - 250, 10, `Arma: ${weaponStats.nome}`, { fontSize: '24px', fill: '#FFF' }).setOrigin(1, 0);
        const coinText = this.add.text(10, 100, `Moedas: ${playerStats.coins}`, { fontSize: '24px', fill: '#FFD700' }).setName('coinText');


        hudGroup.add(playerHealthText);
        hudGroup.add(playerXPText);
        hudGroup.add(playerLevelText);
        hudGroup.add(weaponNameText);
        hudGroup.add(coinText);

        let xpBarBackground = this.add.graphics();
        xpBarBackground.fillStyle(0x555555, 1);
        xpBarBackground.fillRect(10, 130, 200, 10);
        this.xpBar = this.add.graphics();
        this.xpBar.fillStyle(0x00FF00, 1);
        this.xpBar.fillRect(10, 130, (xp / (level * 100)) * 200, 10);

        hudGroup.add(xpBarBackground);
        hudGroup.add(this.xpBar);
    }

    update(time, delta) {
        if (!player.active) {
            return;
        }

        player.setVelocity(0);
        if (cursors.left.isDown) {
            player.setVelocityX(-playerStats.speed);
        } else if (cursors.right.isDown) {
            player.setVelocityX(playerStats.speed);
        }
        if (cursors.up.isDown) {
            player.setVelocityY(-playerStats.speed);
        } else if (cursors.down.isDown) {
            player.setVelocityY(playerStats.speed);
        }

        player.body.velocity.normalize().scale(playerStats.speed);

        if (time > lastShoot + playerStats.fireRate) {
            this.shootRadial();
            lastShoot = time;
        }

        enemies.children.each(function(enemy) {
            if (enemy.active) {
                this.physics.moveToObject(enemy, player, enemy.speed);

                if (enemy.lastShot === undefined) {
                    enemy.lastShot = time;
                }
                if (time > enemy.lastShot + 9000) {
                    this.enemyShoot(enemy);
                    enemy.lastShot = time;
                }
            }
        }, this);

        this.xpBar.clear();
        this.xpBar.fillStyle(0x00FF00, 1);
        this.xpBar.fillRect(10, 130, (xp / (level * 100)) * 200, 10);
    }

    shootRadial() {
        const bulletCount = playerStats.bulletCountMultiplier;
        const angleOffset = (bulletCount > 1) ? -(bulletCount - 1) * 10 / 2 : 0;
        const bulletSpeed = 500 * playerStats.bulletSpeedBoost;

        for (let i = 0; i < bulletCount; i++) {
            let angle = Phaser.Math.DegToRad(Phaser.Math.RadToDeg(player.rotation) + angleOffset + (i * 10));
            let bullet = bullets.get(player.x, player.y, 'bullet');

            if (bullet) {
                bullet.setActive(true).setVisible(true);
                bullet.setRotation(angle);
                this.physics.velocityFromRotation(angle, bulletSpeed, bullet.body.velocity);
                bullet.damage = playerStats.bulletDamage;
                bullet.piercing = playerStats.bulletPiercing;
                bullet.critChance = playerStats.critChance;
                bullet.critDamage = playerStats.critDamage;

                this.time.delayedCall(2000, () => {
                    if (bullet.active) {
                        bullet.destroy();
                    }
                });
            }
        }
    }

    hitEnemy(bullet, enemy) {
        if (!enemy.active || !bullet.active) return;

        let finalDamage = bullet.damage;
        let isCrit = false;
        if (Math.random() * 100 < bullet.critChance) {
            finalDamage *= bullet.critDamage;
            isCrit = true;
        }

        enemy.health -= finalDamage;
        createFloatingText(this, enemy.x, enemy.y - 20, Math.round(finalDamage).toString(), isCrit ? '#FF0000' : '#FFFFFF');

        if (!bullet.piercing) {
            bullet.destroy();
        }

        if (enemy.health <= 0) {
            this.killEnemy(enemy);
        }
    }

    takeDamage(player, bullet) {
        if (!player.active) return;
        bullet.destroy();
        player.health -= 10;
        this.updateHud();
        createFloatingText(this, player.x, player.y, '-10', '#FF0000');

        if (player.health <= 0) {
            this.gameOver();
        }
    }

    playerHitByEnemy(player, enemy) {
        if (!player.active || !enemy.active) return;
        player.health -= 1;
        this.updateHud();

        if (player.health <= 0) {
            this.gameOver();
        }
    }

    killEnemy(enemy) {
        createFloatingText(this, enemy.x, enemy.y, `+${enemy.xpReward} XP`, '#00FF00');
        xp += enemy.xpReward + (enemy.xpReward * playerStats.xpBonus);
        score += 10;
        enemy.destroy();
        waveEnemiesRemaining--;

        this.dropItem(enemy.x, enemy.y);

        if (xp >= level * 100) {
            this.levelUp();
        }

        this.updateHud();
        this.checkWaveCompletion();
        this.increaseKillStreak();
    }

    enemyShoot(enemy) {
        if (!player.active) return;
        let enemyBullet = enemyBullets.get(enemy.x, enemy.y, 'bullet');
        if (enemyBullet) {
            enemyBullet.setActive(true).setVisible(true);
            this.physics.moveToObject(enemyBullet, player, 200);
            this.time.delayedCall(3000, () => {
                if (enemyBullet.active) {
                    enemyBullet.destroy();
                }
            });
        }
    }

    levelUp() {
        level++;
        xp = 0;
        playerStats.maxHealth += 10;
        player.health = playerStats.maxHealth;
        playerStats.bulletDamage += 2;
        playerStats.fireRate = Math.max(100, playerStats.fireRate - 20);
        playerStats.speed += 5;
        playerStats.bulletSpeedBoost += 0.05;

        displayTemporaryEffect(this, `Nível ${level}!`, '#00FFFF');
        this.updateHud();
    }

    gameOver() {
        player.setActive(false).setVisible(false);
        this.physics.pause();
        this.add.text(this.game.config.width / 2, this.game.config.height / 2, 'GAME OVER', {
            fontSize: '64px',
            fill: '#F00'
        }).setOrigin(0.5);
        this.add.text(this.game.config.width / 2, this.game.config.height / 2 + 60, 'Pressione ESPAÇO para reiniciar', {
            fontSize: '24px',
            fill: '#FFF'
        }).setOrigin(0.5);
    }

    startWave() {
        currentWave++;
        if (currentWave > waveConfig.length) {
            displayTemporaryEffect(this, 'Todas as ondas completas!', '#FFD700');
            this.physics.pause();
            return;
        }

        let waveInfo = waveConfig[currentWave - 1];
        waveEnemiesRemaining = waveInfo.count;

        displayTemporaryEffect(this, `Onda ${currentWave} - ${waveInfo.type.toUpperCase()}!`, '#00FF00');

        for (let i = 0; i < waveInfo.count; i++) {
            this.time.delayedCall(i * 500, () => {
                let x = Phaser.Math.Between(50, this.game.config.width - 50);
                let y = Phaser.Math.Between(50, this.game.config.height - 50);

                let attempts = 0;
                while (Phaser.Math.Distance.Between(x, y, player.x, player.y) < 200 && attempts < 10) {
                    x = Phaser.Math.Between(50, this.game.config.width - 50);
                    y = Phaser.Math.Between(50, this.game.config.height - 50);
                    attempts++;
                }

                this.spawnEnemy(x, y, waveInfo);
            }, [], this);
        }

        if (waveTimer) waveTimer.remove();
        waveTimer = this.time.delayedCall(waveInterval, this.startWave, [], this);
    }

    spawnEnemy(x, y, waveInfo) {
        let enemyTypeData = enemyTypes[waveInfo.type];
        if (!enemyTypeData) {
            console.warn(`Tipo de inimigo desconhecido: ${waveInfo.type}`);
            return;
        }

        let enemy = enemies.get(x, y, enemyTypeData.texture);
        if (enemy) {
            enemy.setActive(true).setVisible(true);
            enemy.setTint(0xff0000);
            enemy.setScale(enemyTypeData.scale);
            enemy.health = waveInfo.health || enemyTypeData.baseHealth;
            enemy.maxHealth = waveInfo.health || enemyTypeData.baseHealth;
            enemy.speed = waveInfo.speed || enemyTypeData.speed;
            enemy.xpReward = waveInfo.xp || enemyTypeData.xpReward;
            enemy.setCollideWorldBounds(true);
        }
    }

    checkWaveCompletion() {
        if (waveEnemiesRemaining <= 0) {
            displayTemporaryEffect(this, `Onda ${currentWave} Concluída!`, '#00FF00');
            if (waveTimer) waveTimer.remove();
            this.time.delayedCall(5000, this.startWave, [], this);
        }
    }

    dropItem(x, y) {
        let rand = Math.random();
        if (rand < 0.20) {
            let xpAmount = Math.floor(Phaser.Math.Between(5, 15) * (1 + level * 0.1));
            this.spawnPickup(x, y, 'pickup_xp', 'xp', xpAmount);
        } else if (rand < 0.30) {
            let healthAmount = Math.floor(Phaser.Math.Between(10, 20) * (1 + level * 0.05));
            this.spawnPickup(x, y, 'pickup_health', 'health', healthAmount);
        } else if (rand < 0.45) {
            let coinAmount = Phaser.Math.Between(1, 5);
            this.spawnPickup(x, y, 'pickup_coin', 'coin', coinAmount);
        }
    }

    spawnPickup(x, y, texture, type, value) {
        let item = itemsGroup.get(x, y, texture);
        if (item) {
            item.setActive(true).setVisible(true);
            item.type = type;
            item.value = value;
            item.setCircle(item.width / 2);

            this.physics.moveTo(item, player, 50);
            this.time.delayedCall(200, () => {
                if (item.active) {
                    item.setVelocity(0);
                }
            });

            this.time.delayedCall(10000, () => {
                if (item.active) {
                    item.destroy();
                }
            });
        }
    }

    collectItem(player, item) {
        if (!item.active) return;

        switch (item.type) {
            case 'xp':
                xp += item.value + (item.value * playerStats.xpBonus);
                createFloatingText(this, item.x, item.y, `+${item.value} XP`, '#00FFFF');
                if (xp >= level * 100) {
                    this.levelUp();
                }
                break;
            case 'health':
                player.health = Math.min(player.health + item.value, player.maxHealth);
                createFloatingText(this, item.x, item.y, `+${item.value} Vida`, '#00FF00');
                break;
            case 'coin':
                playerStats.coins += item.value;
                createFloatingText(this, item.x, item.y, `+${item.value} Moedas`, '#FFD700');
                break;
        }
        item.destroy();
        this.updateHud();
    }

    increaseKillStreak() {
        killStreak++;
        if (killStreakTimer) {
            killStreakTimer.remove(false);
        }
        killStreakTimer = this.time.delayedCall(5000, this.endKillStreak, [], this);

        if (killStreak % 5 === 0) {
            displayTemporaryEffect(this, `${killStreak} Kills!`, '#FF8C00');

            if (killStreak % 10 === 0) {
                this.startFrenzy();
            }
        }
    }

    startFrenzy() {
        displayTemporaryEffect(this, 'FRENESI ATIVADO!', '#FF00FF');
        player.setTint(0xFF00FF);
        playerStats.fireRate /= 2;
        playerStats.bulletDamage *= 1.2;
        playerStats.speed *= 1.1;
        this.time.delayedCall(5000, this.endFrenzy, [], this);
    }

    endFrenzy() {
        player.setTint(0xFFFFFF); // Volta à cor original (branco)
        playerStats.fireRate *= 2;
        playerStats.bulletDamage /= 1.2;
        playerStats.speed /= 1.1;
        displayTemporaryEffect(this, 'Frenesi Encerrado.', '#FFFFFF');
    }

    endKillStreak() {
        killStreak = 0;
    }
}

// Funções auxiliares (fora da classe GameScene para serem globais ou passadas)
function displayTemporaryEffect(scene, text, color = '#FFFFFF') {
    if (temporaryEffectText) {
        temporaryEffectText.destroy();
    }
    if (temporaryEffectTimer) {
        temporaryEffectTimer.remove(false);
    }

    temporaryEffectText = scene.add.text(scene.cameras.main.width / 2, scene.cameras.main.height / 2 - 50, text, {
        fontSize: '36px',
        fill: color,
        align: 'center'
    }).setOrigin(0.5);
    temporaryEffectText.setDepth(2);

    temporaryEffectTimer = scene.time.delayedCall(2000, () => {
        if (temporaryEffectText) {
            temporaryEffectText.destroy();
            temporaryEffectText = null;
        }
    });
}

function createFloatingText(scene, x, y, text, color = '#FFFFFF') {
    const floatText = scene.add.text(x, y, text, {
        fontSize: '18px',
        fill: color,
        align: 'center'
    }).setOrigin(0.5);
    floatText.setDepth(2);

    scene.tweens.add({
        targets: floatText,
        y: y - 50,
        alpha: 0,
        duration: 1000,
        ease: 'Power1',
        onComplete: () => {
            floatText.destroy();
        }
    });
}


const config = {
  type: Phaser.AUTO,
  width: 1380,
  height: 580,
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: { debug: false }
  },
  scene: [GameScene, ShopScene]
};

const game = new Phaser.Game(config);

</script>

</body>
</html>

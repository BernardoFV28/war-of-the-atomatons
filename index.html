<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Space RPG: Boss Update</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; color: white; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* UI GERAL */
        #ui-layer { position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 5; }
        .stat-box { 
            background: rgba(0,0,0,0.6); padding: 8px 15px; border-radius: 4px; 
            margin-bottom: 5px; border-left: 4px solid #00d2ff; 
            font-weight: bold; text-shadow: 1px 1px 0 #000;
        }

        /* BOSS UI */
        #boss-hud {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            width: 60%; display: none; z-index: 5; flex-direction: column; align-items: center;
        }
        #boss-name { font-size: 1.5rem; color: #ff0055; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 10px #ff0055; margin-bottom: 5px; }
        #boss-health-bar-bg { width: 100%; height: 20px; background: #333; border: 2px solid white; border-radius: 10px; overflow: hidden; }
        #boss-health-bar-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #ff0055, #ff5500); transition: width 0.2s; }

        /* MENUS & LOJA */
        #menu-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column; 
            align-items: center; justify-content: center; z-index: 10;
        }
        .hidden { display: none !important; }
        
        h1 { font-size: 4rem; margin: 0; color: #00d2ff; text-shadow: 0 0 20px #00d2ff; letter-spacing: 5px; }
        
        /* CARDS DA LOJA */
        #shop-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; margin-top: 20px; }
        .upgrade-card {
            /* Usando o cardBg do usu√°rio */
            background-image: url('assets/card.png'); 
            background-size: cover; background-position: center;
            background-color: #222; /* Fallback */
            border: 2px solid #444; padding: 25px; width: 170px; height: 250px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; cursor: pointer; border-radius: 15px; transition: 0.3s;
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }
        .upgrade-card:hover { transform: translateY(-10px); border-color: #00d2ff; box-shadow: 0 0 25px rgba(0, 210, 255, 0.4); }
        .upgrade-card h3 { margin: 0 0 10px 0; color: #fff; font-size: 1.5rem; text-shadow: 0 2px 4px black; }
        .upgrade-card p { color: #ccc; font-size: 0.9rem; text-shadow: 0 1px 2px black; }
        .cost { color: #ffd700 !important; font-weight: bold; font-size: 1.2rem !important; margin-top: auto !important; }

        .btn { 
            background: linear-gradient(45deg, #00d2ff, #0077ff); border: none; padding: 15px 50px; 
            color: white; font-size: 1.5rem; font-weight: bold; cursor: pointer; 
            margin: 20px; border-radius: 50px; box-shadow: 0 0 20px rgba(0, 210, 255, 0.5);
            transition: transform 0.2s;
        }
        .btn:hover { transform: scale(1.1); filter: brightness(1.2); }

        /* NOTIFICA√á√ïES */
        #achievement-container { position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 10px; z-index: 6; }
        .ach-toast {
            background: rgba(0, 40, 80, 0.9); color: white; padding: 15px 20px;
            border-radius: 5px; border-left: 5px solid #ffd700; animation: slideIn 0.5s forwards;
        }
        @keyframes slideIn { from { transform: translateX(120%); } to { transform: translateX(0); } }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-box">üõ°Ô∏è N√≠vel: <span id="hud-level">1</span></div>
        <div class="stat-box">‚ú® XP: <span id="hud-xp">0</span> / <span id="hud-next-xp">100</span></div>
        <div class="stat-box" style="border-color: #ff0055">‚ù§Ô∏è HP: <span id="hud-hp">100</span>/<span id="hud-max-hp">100</span></div>
        <div class="stat-box" style="border-color: gold">üèÜ Score: <span id="hud-score">0</span></div>
    </div>

    <div id="boss-hud">
        <div id="boss-name"> YNVINIR (BOSS)</div>
        <div id="boss-health-bar-bg">
            <div id="boss-health-bar-fill"></div>
        </div>
    </div>

    <div id="achievement-container"></div>

    <div id="menu-overlay">
        <h1 id="menu-title">War of  the Automatons</h1>
        <p style="color: #aaa; margin-bottom: 30px;">Destrua os rob√¥s de ferrumia e liberte a cidade</p>
        
        <div id="start-screen">
            <button class="btn" onclick="game.start('normal')">INICIAR MISS√ÉO</button>
        </div>

        <div id="shop-screen" class="hidden">
            <h2 style="color:white; text-shadow: 0 0 10px white;">SISTEMA DE UPGRADE</h2>
            <div style="color: gold; font-size: 1.2rem; margin-bottom: 10px;">Pontos de Skill: <span id="shop-points">0</span></div>
            <div id="shop-container">
                <div class="upgrade-card" onclick="game.player.upgrade('damage')">
                    <h3>Dano Brutal</h3>
                    <p>Seus tiros causam mais destrui√ß√£o.</p>
                    <p class="cost">1 SP</p>
                </div>
                <div class="upgrade-card" onclick="game.player.upgrade('speed')">
                    <h3>Propulsores</h3>
                    <p>Aumenta velocidade de movimento.</p>
                    <p class="cost">1 SP</p>
                </div>
                <div class="upgrade-card" onclick="game.player.upgrade('firerate')">
                    <h3>Recarga R√°pida</h3>
                    <p>Atire muito mais r√°pido.</p>
                    <p class="cost">2 SP</p>
                </div>
                <div class="upgrade-card" onclick="game.player.upgrade('multishot')">
                    <h3>Canh√£o Duplo</h3>
                    <p>Adiciona proj√©teis extras.</p>
                    <p class="cost">5 SP</p>
                </div>
                <div class="upgrade-card" onclick="game.player.heal()">
                    <h3>Reparo (HP)</h3>
                    <p>Recupera 50% da vida.</p>
                    <p class="cost">1 SP</p>
                </div>
            </div>
            <button class="btn" style="margin-top: 30px;" onclick="game.toggleShop()">VOLTAR √Ä LUTA</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * =================================================================
 * CARREGAMENTO DE ASSETS
 * Mapeando os nomes que voc√™ forneceu para objetos de Imagem
 * =================================================================
 */
const assets = {
    bgTile: loadImage('assets/dungeon_floor.png'),
    cardBg: loadImage('assets/card.png'),
    player: loadImage('assets/player.png'),
    bullet: loadImage('assets/bullet.png'),
    enemyBasic: loadImage('assets/enemy_robot.png'),
    enemyFast: loadImage('assets/enemy_fast.png'),
    enemyTank: loadImage('assets/enemy_tank.png'),
    boss: loadImage('assets/boss_robot.png'),
    ammo: loadImage('assets/ammo.png') // Ser√° usado como Drop de Cura
};

function loadImage(src) {
    const img = new Image();
    img.src = src;
    return img;
}

// Configura√ß√£o do Canvas
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- SISTEMA DE PART√çCULAS ---
class Particle {
    constructor(x, y, color, speed) {
        this.x = x; this.y = y;
        this.color = color;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = Math.random() * speed;
        this.vx = Math.cos(this.angle) * this.speed;
        this.vy = Math.sin(this.angle) * this.speed;
        this.life = 1.0;
        this.decay = 0.02 + Math.random() * 0.03;
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        this.life -= this.decay;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

// --- CLASSE JOGADOR ---
class Player {
    constructor() {
        this.reset();
    }
    reset() {
        this.x = canvas.width/2; this.y = canvas.height/2;
        this.size = 32; // Ajustado para sprites comuns
        this.speed = 5;
        this.hp = 100; this.maxHp = 100;
        
        // RPG
        this.level = 1; this.xp = 0; this.xpToNext = 100; this.skillPoints = 0;
        
        // Combate
        this.damage = 15;
        this.fireRate = 15;
        this.multiShot = 1;
        this.cooldown = 0;
    }

    upgrade(type) {
        if (this.skillPoints <= 0) return;
        let cost = (type === 'multishot') ? 5 : (type === 'firerate' ? 2 : 1);
        
        if (this.skillPoints >= cost) {
            this.skillPoints -= cost;
            if(type === 'damage') this.damage += 5;
            if(type === 'speed') this.speed += 0.5;
            if(type === 'firerate') this.fireRate = Math.max(5, this.fireRate - 2);
            if(type === 'multishot') this.multiShot++;
            updateUI();
        }
    }

    heal() {
        if (this.skillPoints >= 1 && this.hp < this.maxHp) {
            this.skillPoints--;
            this.hp = Math.min(this.maxHp, this.hp + (this.maxHp * 0.5));
            updateUI();
        }
    }

    update(input) {
        if (input.keys['w'] || input.keys['ArrowUp']) this.y -= this.speed;
        if (input.keys['s'] || input.keys['ArrowDown']) this.y += this.speed;
        if (input.keys['a'] || input.keys['ArrowLeft']) this.x -= this.speed;
        if (input.keys['d'] || input.keys['ArrowRight']) this.x += this.speed;

        this.x = Math.max(this.size, Math.min(canvas.width-this.size, this.x));
        this.y = Math.max(this.size, Math.min(canvas.height-this.size, this.y));

        if (this.cooldown > 0) this.cooldown--;
        if (input.mouseDown && this.cooldown <= 0) {
            this.shoot(input);
            this.cooldown = this.fireRate;
        }
    }

    shoot(input) {
        for (let i = 0; i < this.multiShot; i++) {
            let offsetAngle = (i - (this.multiShot-1)/2) * 0.1;
            let angle = Math.atan2(input.mouseY - this.y, input.mouseX - this.x) + offsetAngle;
            
            game.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle) * 12, vy: Math.sin(angle) * 12,
                damage: this.damage, type: 'player', life: 80
            });
        }
    }

    draw(ctx) {
        if (assets.player.complete && assets.player.naturalWidth !== 0) {
            // Desenha a imagem centralizada
            ctx.drawImage(assets.player, this.x - this.size, this.y - this.size, this.size*2, this.size*2);
        } else {
            // Fallback se a imagem n√£o carregar
            ctx.fillStyle = '#00d2ff';
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size/2, 0, Math.PI*2); ctx.fill();
        }
    }
}

// --- CLASSE BOSS ---
class Boss {
    constructor(level) {
        this.x = canvas.width / 2;
        this.y = -100; // Come√ßa fora da tela
        this.targetY = 150;
        this.hp = 1000 + (level * 200);
        this.maxHp = this.hp;
        this.size = 80;
        this.angle = 0;
        this.state = 'enter'; // enter, idle, attack
        this.attackTimer = 0;
    }

    update() {
        // Entrada dram√°tica
        if (this.state === 'enter') {
            this.y += 2;
            if (this.y >= this.targetY) this.state = 'fight';
            return;
        }

        // Movimento flutuante
        this.x += Math.sin(Date.now() / 1000) * 2;
        
        // Ataques
        this.attackTimer++;
        if (this.attackTimer > 100) {
            this.attack();
            this.attackTimer = 0;
        }
    }

    attack() {
        const type = Math.floor(Math.random() * 3);
        
        if (type === 0) { // Spread Shot (tiro espalhado)
            for(let i=0; i<10; i++) {
                let angle = (Math.PI / 10) * i + Math.PI/2; // Arco para baixo
                game.bullets.push({
                    x: this.x, y: this.y + 50,
                    vx: Math.cos(angle) * 5, vy: Math.sin(angle) * 5,
                    damage: 20, type: 'enemy', life: 200, isBoss: true
                });
            }
        } else if (type === 1) { // Sniper Shot (no jogador)
            let angle = Math.atan2(game.player.y - this.y, game.player.x - this.x);
            game.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle) * 8, vy: Math.sin(angle) * 8,
                damage: 30, type: 'enemy', life: 200, isBoss: true
            });
        } else { // Summon Minions
             game.spawnEnemy('fast', this.x, this.y);
             game.spawnEnemy('fast', this.x, this.y);
        }
    }

    draw(ctx) {
        if (assets.boss.complete && assets.boss.naturalWidth !== 0) {
            ctx.drawImage(assets.boss, this.x - this.size, this.y - this.size, this.size*2, this.size*2);
        } else {
            ctx.fillStyle = '#ff0055';
            ctx.fillRect(this.x - this.size, this.y - this.size, this.size*2, this.size*2);
        }
    }
}

// --- GERENCIADOR PRINCIPAL ---
class Game {
    constructor() {
        this.player = new Player();
        this.bullets = [];
        this.enemies = [];
        this.drops = []; // Drops de Ammo/Cura
        this.particles = [];
        this.boss = null;
        this.score = 0;
        
        this.bgPattern = null;
        
        this.input = { keys: {}, mouseX: 0, mouseY: 0, mouseDown: false };
        this.setupInput();
        this.loop = this.loop.bind(this);
    }

    setupInput() {
        window.addEventListener('keydown', e => {
            this.input.keys[e.key] = true;
            if (e.key.toLowerCase() === 'p') this.toggleShop();
        });
        window.addEventListener('keyup', e => this.input.keys[e.key] = false);
        window.addEventListener('mousemove', e => { this.input.mouseX = e.clientX; this.input.mouseY = e.clientY; });
        window.addEventListener('mousedown', () => this.input.mouseDown = true);
        window.addEventListener('mouseup', () => this.input.mouseDown = false);
    }

    start() {
        this.player.reset();
        this.bullets = []; this.enemies = []; this.drops = []; this.particles = [];
        this.boss = null; this.score = 0;
        this.isRunning = true; this.isPaused = false;
        
        document.getElementById('menu-overlay').classList.add('hidden');
        document.getElementById('boss-hud').style.display = 'none';
        
        // Criar pattern do background
        if (assets.bgTile.complete) {
            this.bgPattern = ctx.createPattern(assets.bgTile, 'repeat');
        } else {
            assets.bgTile.onload = () => this.bgPattern = ctx.createPattern(assets.bgTile, 'repeat');
        }

        updateUI();
        requestAnimationFrame(this.loop);
    }

    toggleShop(forceOpen = false) {
        if (!this.isRunning && !forceOpen) return;
        this.isPaused = !this.isPaused;
        const el = document.getElementById('menu-overlay');
        const shop = document.getElementById('shop-screen');
        const start = document.getElementById('start-screen');
        
        if (this.isPaused || forceOpen) {
            el.classList.remove('hidden');
            shop.classList.remove('hidden');
            start.classList.add('hidden');
            document.getElementById('shop-points').innerText = this.player.skillPoints;
        } else {
            el.classList.add('hidden');
            requestAnimationFrame(this.loop);
        }
    }

    spawnEnemy(specificType, originX, originY) {
        let x, y;
        if (originX !== undefined) {
            x = originX; y = originY;
        } else {
            // Spawn nas bordas
            if (Math.random() < 0.5) { x = Math.random()*canvas.width; y = Math.random() < 0.5 ? -30 : canvas.height+30; } 
            else { x = Math.random() < 0.5 ? -30 : canvas.width+30; y = Math.random()*canvas.height; }
        }

        // L√≥gica de tipo baseada no n√≠vel
        let type = specificType || 'basic';
        if (!specificType) {
            let r = Math.random();
            if (this.player.level >= 3 && r < 0.2) type = 'tank';
            if (this.player.level >= 2 && r > 0.8) type = 'fast';
        }

        let enemy = { x, y, type, hp: 20, maxHp: 20, speed: 2, size: 24, img: assets.enemyBasic };
        
        if (type === 'tank') { enemy.hp = 60; enemy.speed = 1; enemy.size = 32; enemy.img = assets.enemyTank; }
        if (type === 'fast') { enemy.hp = 10; enemy.speed = 4; enemy.size = 20; enemy.img = assets.enemyFast; }
        
        // Escalar vida com n√≠vel
        enemy.hp += this.player.level * 5;
        enemy.maxHp = enemy.hp;
        
        this.enemies.push(enemy);
    }

    // --- LOOP PRINCIPAL ---
    loop() {
        if (!this.isRunning || this.isPaused) return;

        // Desenhar Fundo
        if (this.bgPattern) {
            ctx.fillStyle = this.bgPattern;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // M√°scara escura para dar clima de dungeon
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        } else {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // LOGICA DE SPAWN (S√≥ spawna se n√£o tiver boss)
        if (!this.boss) {
            if (this.player.level % 5 === 0 && this.player.level > 1 && this.enemies.length === 0) {
                // HORA DO BOSS
                this.boss = new Boss(this.player.level);
                document.getElementById('boss-hud').style.display = 'flex';
                this.showToast("‚ö†Ô∏è ALERTA: CHEF√ÉO APROXIMANDO!");
            } else if (Math.random() < 0.02 + (this.player.level * 0.002)) {
                this.spawnEnemy();
            }
        }

        // ATUALIZAR ENTIDADES
        this.player.update(this.input);
        
        // Boss
        if (this.boss) {
            this.boss.update();
            this.boss.draw(ctx);
            // Atualizar barra de vida do boss
            let pct = (this.boss.hp / this.boss.maxHp) * 100;
            document.getElementById('boss-health-bar-fill').style.width = pct + '%';
            
            // Colis√£o Boss-Player (dano por toque)
            let dx = this.player.x - this.boss.x;
            let dy = this.player.y - this.boss.y;
            if (Math.sqrt(dx*dx + dy*dy) < this.boss.size + this.player.size) {
                this.player.hp -= 1; // Dano cont√≠nuo
            }
        }

        // Balas
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            let b = this.bullets[i];
            b.x += b.vx; b.y += b.vy; b.life--;
            
            // Desenho
            if (b.isBoss) {
                ctx.fillStyle = '#ff0055'; ctx.beginPath(); ctx.arc(b.x, b.y, 8, 0, Math.PI*2); ctx.fill();
            } else if (assets.bullet.complete) {
                ctx.drawImage(assets.bullet, b.x-6, b.y-6, 12, 12);
            } else {
                ctx.fillStyle = 'yellow'; ctx.fillRect(b.x-2, b.y-2, 4, 4);
            }

            if (b.life <= 0) { this.bullets.splice(i,1); continue; }

            // Colis√µes
            if (b.type === 'player') {
                // Player atirando em Inimigos
                let hit = false;
                // Checar Boss
                if (this.boss) {
                    let dx = b.x - this.boss.x; let dy = b.y - this.boss.y;
                    if (Math.sqrt(dx*dx + dy*dy) < this.boss.size) {
                        this.boss.hp -= b.damage;
                        this.createParticles(b.x, b.y, '#ff0055', 3);
                        hit = true;
                        if (this.boss.hp <= 0) {
                            // Boss Morreu
                            this.boss = null;
                            document.getElementById('boss-hud').style.display = 'none';
                            this.player.gainXp(500);
                            this.showToast("üíÄ BOSS ELIMINADO!");
                            // Drop de Ammo garantido
                            this.drops.push({x: canvas.width/2, y: canvas.height/2});
                        }
                    }
                }
                
                // Checar Inimigos comuns
                if(!hit) {
                    for (let eIdx = this.enemies.length - 1; eIdx >= 0; eIdx--) {
                        let e = this.enemies[eIdx];
                        let dx = b.x - e.x; let dy = b.y - e.y;
                        if (Math.sqrt(dx*dx + dy*dy) < e.size) {
                            e.hp -= b.damage;
                            this.createParticles(e.x, e.y, 'white', 2);
                            hit = true;
                            if (e.hp <= 0) {
                                this.enemies.splice(eIdx, 1);
                                this.player.xp += 10;
                                if (this.player.xp >= this.player.xpToNext) this.levelUp();
                                this.score += 10;
                                // Chance de Drop de Ammo (Cura)
                                if (Math.random() < 0.05) this.drops.push({x: e.x, y: e.y});
                            }
                            break;
                        }
                    }
                }
                if(hit) this.bullets.splice(i, 1);
            } 
            else if (b.type === 'enemy') {
                // Inimigo atirando no Player
                let dx = b.x - this.player.x; let dy = b.y - this.player.y;
                if (Math.sqrt(dx*dx + dy*dy) < this.player.size) {
                    this.player.hp -= b.damage;
                    this.createParticles(this.player.x, this.player.y, 'red', 5);
                    this.bullets.splice(i, 1);
                    if (this.player.hp <= 0) this.gameOver();
                }
            }
        }

        // Inimigos
        for (let i = this.enemies.length - 1; i >= 0; i--) {
            let e = this.enemies[i];
            let angle = Math.atan2(this.player.y - e.y, this.player.x - e.x);
            e.x += Math.cos(angle) * e.speed; e.y += Math.sin(angle) * e.speed;
            
            // Desenho
            if (e.img && e.img.complete) {
                ctx.drawImage(e.img, e.x - e.size, e.y - e.size, e.size*2, e.size*2);
            } else {
                ctx.fillStyle = 'red'; ctx.fillRect(e.x-e.size, e.y-e.size, e.size*2, e.size*2);
            }

            // Dano no player
            let dist = Math.sqrt(Math.pow(this.player.x - e.x, 2) + Math.pow(this.player.y - e.y, 2));
            if (dist < this.player.size + e.size) {
                this.player.hp -= 10;
                this.enemies.splice(i, 1);
                this.createParticles(this.player.x, this.player.y, 'red', 5);
                if (this.player.hp <= 0) this.gameOver();
            }
        }

        // Drops (Ammo/Cura)
        for (let i = this.drops.length - 1; i >= 0; i--) {
            let d = this.drops[i];
            if (assets.ammo.complete) {
                ctx.drawImage(assets.ammo, d.x-10, d.y-10, 20, 20);
            } else {
                ctx.fillStyle = '#0f0'; ctx.fillRect(d.x-5,d.y-5,10,10);
            }
            
            // Coleta
            let dist = Math.sqrt(Math.pow(this.player.x - d.x, 2) + Math.pow(this.player.y - d.y, 2));
            if (dist < 30) {
                this.player.hp = Math.min(this.player.maxHp, this.player.hp + 20);
                this.drops.splice(i, 1);
                this.showToast("‚ù§Ô∏è +20 HP");
            }
        }

        // Part√≠culas
        this.particles.forEach((p, i) => {
            p.update(); p.draw(ctx);
            if(p.life <= 0) this.particles.splice(i,1);
        });

        this.player.draw(ctx);
        updateUI();
        requestAnimationFrame(this.loop);
    }

    createParticles(x, y, color, count) {
        for(let i=0; i<count; i++) this.particles.push(new Particle(x, y, color, 5));
    }
    
    levelUp() {
        this.player.level++;
        this.player.xp = 0;
        this.player.xpToNext = Math.floor(this.player.xpToNext * 1.5);
        this.player.skillPoints++;
        this.player.maxHp += 20; this.player.hp = this.player.maxHp;
        this.showToast("LEVEL UP! Loja Aberta!");
        this.toggleShop(true);
    }
    
    showToast(msg) {
        const c = document.getElementById('achievement-container');
        const d = document.createElement('div'); d.className = 'ach-toast'; d.innerText = msg;
        c.appendChild(d); setTimeout(() => d.remove(), 3000);
    }

    gameOver() {
        this.isRunning = false;
        alert("GAME OVER! Score: " + this.score);
        document.getElementById('menu-overlay').classList.remove('hidden');
        document.getElementById('start-screen').classList.remove('hidden');
        document.getElementById('shop-screen').classList.add('hidden');
    }
}

const game = new Game();
function updateUI() {
    document.getElementById('hud-level').innerText = game.player.level;
    document.getElementById('hud-xp').innerText = Math.floor(game.player.xp);
    document.getElementById('hud-next-xp').innerText = game.player.xpToNext;
    document.getElementById('hud-hp').innerText = Math.floor(game.player.hp);
    document.getElementById('hud-max-hp').innerText = game.player.maxHp;
    document.getElementById('hud-score').innerText = game.score;
}

</script>
</body>
</html>


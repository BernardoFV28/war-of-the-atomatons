<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons - Survivor Mode</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000008c7; }
    canvas { display: block; margin: auto; }
    .menu-overlay, .shop-overlay, .pause-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; color: #FFF; }
    .menu-container, .shop-container, .pause-container { background-color: #333; border: 2px solid #555; padding: 20px; border-radius: 8px; text-align: center; width: 80%; max-width: 900px; }
    .menu-title, .shop-title, .pause-title { font-size: 36px; margin-bottom: 20px; color: #00FFFF; }
    .cards-container, .shop-items-container { display: flex; justify-content: space-around; gap: 20px; flex-wrap: wrap; }
    .card, .shop-item { background-color: #222; border: 1px solid #444; border-radius: 8px; padding: 15px; width: 250px; display: flex; flex-direction: column; align-items: center; text-align: left; min-height: 220px; }
    .card:hover { transform: translateY(-5px); box-shadow: 0 5px 20px rgba(0, 255, 255, 0.5); }
    .card-title, .shop-item-name { font-size: 22px; color: #FFD700; }
    .card-button, .shop-item-button, .shop-close-button, .pause-close-button, .pause-tab-button { padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; margin-top: 15px; }
    .card-button { background-color: #008CBA; color: white; }
    .shop-item-button { background-color: #28a745; color: white; }
    .shop-close-button, .pause-close-button { background-color: #dc3545; color: white; }
    .card-rarity { font-size: 12px; font-style: italic; margin: 5px 0 10px 0; }
  </style>
</head>
<body>
<script>
// --- Game Configuration ---
const config = {
  type: Phaser.AUTO,
  width: 1320,
  height: 590,
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: { debug: false, gravity: { y: 0 } }
  },
  scene: { preload, create, update }
};

// --- Centralized Game Balance & Config ---
const GAME_CONFIG = {
    PLAYER: {
        INITIAL_SCALE: 0.08, // MANTIDO A ESCALA ORIGINAL
        DEFAULT_TINT: 0xFFFFFF,
        DASH_DURATION: 150, DASH_DISTANCE: 300, DASH_COOLDOWN_BASE: 3000,
        ACCELERATION: 2000, DRAG: 0.6,
        BASE_MAGNET_RANGE: 100, // NOVO: Alcance base de coleta
        BASE_PIERCING: 1 // NOVO: Quantos inimigos uma bala atravessa
    },
    BULLET: { INITIAL_SPEED: 1000, INITIAL_SCALE: 0.01 }, // MANTIDO ESCALA ORIGINAL
    WEAPONS: {
        1: { fireRate: 500, damage: 1, speed: 1000, range: 400 },     
        2: { fireRate: 100, damage: 0.5, speed: 1100, range: 350 },   
        3: { fireRate: 1500, damage: 5, speed: 900, range: 600 }     
    },
    WAVE: {
        // Aumentei a intensidade para ficar mais parecido com Vampire Survivors
        INITIAL_ENEMY_COUNT: 15, 
        ENEMY_INCREMENT_PER_WAVE: 5,
        INITIAL_SPAWN_RATE: 1000,
        SPAWN_RATE_DECREASE_PER_WAVE: 80,
        MAX_ENEMIES_ON_SCREEN: 200
    },
    CAMERA_SHAKE: { PLAYER_HIT: { DURATION: 100, INTENSITY: 0.01 } }
};

// --- Global Variables ---
let player, cursors, bullets, enemies, enemyBullets, itemsGroup, xpGemsGroup; // xpGemsGroup NOVO
let lastShoot = 0;
let waveNumber = 1;
let enemiesInWave = GAME_CONFIG.WAVE.INITIAL_ENEMY_COUNT;
let enemiesSpawnedThisWave = 0;
let enemySpawnRate = GAME_CONFIG.WAVE.INITIAL_SPAWN_RATE;
let temporaryEffectText, temporaryEffectTimer;
let currentWeapon = 1;
let gamePaused = false, levelUpMenuOpen = false, shopMenuOpen = false;
let playerDashCooldownTimer = null;
let closestEnemy = null; // NOVO: Para o auto-attack

// --- Player Stats ---
let playerStats = {
  life: 3, maxLife: 6,
  bulletDamage: 1, fireRate: 300, playerSpeed: 300,
  xp: 0, level: 1, xpToNextLevel: 50, // XP inicial reduzido para o primeiro nível ser rápido
  currency: 0,
  magnetRange: GAME_CONFIG.PLAYER.BASE_MAGNET_RANGE, // NOVO STAT
  piercingCount: GAME_CONFIG.PLAYER.BASE_PIERCING, // NOVO STAT
  
  // Flags e Multiplicadores
  dashAvailable: false, // Começa sem dash (estilo VS, você ganha depois)
  dashCooldown: false,
  doubleBullets: false, tripleBullets: false,
  evasionChance: 0,
  incomingDamageMultiplier: 1,
  weaponBulletSpeed: GAME_CONFIG.BULLET.INITIAL_SPEED,
  
  inventory: [] // Para rastrear itens passivos pegos
};

// --- Enemy Definitions (MANTIDAS AS ESCALAS ORIGINAIS) ---
const enemyTypes = {
  normal: { texture: 'enemy_robot', baseHealth: 4, speed: 100, scale: 0.06, xpValue: 5 }, // Velocidade reduzida ligeiramente para compensar a quantidade
  fast: { texture: 'enemy_fast', baseHealth: 3, speed: 200, scale: 0.06, xpValue: 8 },
  tank: { texture: 'enemy_tank', baseHealth: 15, speed: 50, scale: 0.08, xpValue: 15 },
  boss_robot: { texture: 'boss_robot', baseHealth: 500, speed: 200, scale: 0.2, xpValue: 200, boss: true }
};

// --- Item Rarity ---
const itemRarities = {
    common: { color: '#FFFFFF' }, rare: { color: '#00BFFF' }, epic: { color: '#9932CC' }, legendary: { color: '#FFD700' }
};

// --- Card Options (Adaptados para VS) ---
const itemOptions = [
  { nome: "Balas de Titânio", descricao: "+20% Dano", rarity: 'common', efeito: () => playerStats.bulletDamage *= 1.2 },
  { nome: "Gatilho Rápido", descricao: "+15% Velocidade de Ataque", rarity: 'common', efeito: () => playerStats.fireRate *= 0.85 },
  { nome: "Motor V8", descricao: "+10% Velocidade de Movimento", rarity: 'common', efeito: () => playerStats.playerSpeed *= 1.1 },
  { nome: "Imã de Sucata", descricao: "+50% Alcance de Coleta", rarity: 'common', efeito: () => playerStats.magnetRange *= 1.5 }, // NOVO
  { nome: "Projétil Perfurante", descricao: "Balas atravessam +1 inimigo", rarity: 'rare', efeito: () => playerStats.piercingCount += 1 }, // NOVO
  { nome: "Pele Reforçada", descricao: "+1 Vida Máxima", rarity: 'rare', efeito: () => { playerStats.maxLife++; playerStats.life++; hud.updateHealthBar(); } },
  { nome: "Tiro Duplo", descricao: "Dispara um segundo projétil", rarity: 'epic', efeito: () => playerStats.doubleBullets = true },
  { nome: "Módulo de Dash", descricao: "Habilita a habilidade de Dash (Espaço)", rarity: 'epic', efeito: () => playerStats.dashAvailable = true },
];

// --- HUD Class ---
class HUD extends Phaser.GameObjects.Container {
  constructor(scene, x, y) {
    super(scene, x, y);
    scene.add.existing(this);
    this.lifeText = scene.add.text(10, 10, '', { fontSize: '20px', fill: '#FF0000' });
    this.levelText = scene.add.text(10, 40, '', { fontSize: '20px', fill: '#FFFF00' });
    this.currencyText = scene.add.text(10, 70, '', { fontSize: '20px', fill: '#FFD700' });
    this.xpBarBg = scene.add.rectangle(10, 100, 200, 15, 0x555555).setOrigin(0);
    this.xpBar = scene.add.rectangle(10, 100, 0, 15, 0x00FF00).setOrigin(0);
    this.waveText = scene.add.text(config.width / 2, 10, '', { fontSize: '24px', fill: '#FFFFFF' }).setOrigin(0.5);
    this.add([this.lifeText, this.levelText, this.currencyText, this.xpBarBg, this.xpBar, this.waveText]);
    this.updateAll();
  }
  updateAll() {
      this.lifeText.setText(`Vida: ${Math.ceil(playerStats.life)}/${playerStats.maxLife}`);
      this.levelText.setText(`Nível: ${playerStats.level}`);
      this.currencyText.setText(`Sucata: ${playerStats.currency}`);
      this.waveText.setText(`Onda: ${waveNumber}`);
      const xpRatio = playerStats.xp / playerStats.xpToNextLevel;
      this.xpBar.width = 200 * xpRatio;
  }
  updateHealthBar() { this.updateAll(); }
  updateXpBar() { this.updateAll(); }
  updateCurrencyDisplay() { this.updateAll(); }
  displayTemporaryEffect(text, color, duration) { /* Simplificado para economizar espaço */ }
}

// --- Phaser Scene Functions ---
function preload() {
    // MANTIDOS OS CAMINHOS ORIGINAIS
  this.load.image('cardBg', 'assets/card.png');
  this.load.image('player', 'assets/player.png');
  this.load.image('bullet', 'assets/bullet.png');
  this.load.image('enemy_robot', 'assets/enemy_robot.png');
  this.load.image('enemy_fast', 'assets/enemy_fast.png');
  this.load.image('enemy_tank', 'assets/enemy_tank.png');
  this.load.image('boss_robot', 'assets/boss_robot.png');
  this.load.image('ammo', 'assets/ammo.png'); // Usado para XP Gem
  if(!this.textures.exists('player')) this.load.image('player', 'https://labs.phaser.io/assets/sprites/phaser-dude.png');
  if(!this.textures.exists('bullet')) this.load.image('bullet', 'https://labs.phaser.io/assets/sprites/bullets/bullet7.png');
  if(!this.textures.exists('enemy_robot')) this.load.image('enemy_robot', 'https://labs.phaser.io/assets/sprites/space-baddie.png');
  if(!this.textures.exists('ammo')) this.load.image('ammo', 'https://labs.phaser.io/assets/sprites/orb-green.png');
}

function create() {
  player = this.physics.add.sprite(config.width / 2, config.height / 2, 'player').setScale(GAME_CONFIG.PLAYER.INITIAL_SCALE);
  player.setCollideWorldBounds(true);
  player.setDrag(GAME_CONFIG.PLAYER.DRAG); player.setMaxVelocity(playerStats.playerSpeed);

  cursors = this.input.keyboard.createCursorKeys();
  this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

  // Usando grupos com pooling para performance
  bullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 100 });
  enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true, maxSize: GAME_CONFIG.WAVE.MAX_ENEMIES_ON_SCREEN });
  xpGemsGroup = this.physics.add.group({ classType: XPGem, runChildUpdate: true, maxSize: 300 }); // NOVO

  this.physics.add.overlap(bullets, enemies, bulletHitEnemy, null, this);
  this.physics.add.collider(player, enemies, playerHitEnemy, null, this);
  // Coleta de XP
  this.physics.add.overlap(player, xpGemsGroup, collectXPGem, null, this);

  hud = new HUD(this, 0, 0);
  switchWeapon.call(this, 1); // Inicia com a arma 1

  // Spawner loop
  this.time.addEvent({ delay: enemySpawnRate, callback: spawnEnemy, callbackScope: this, loop: true, id: 'spawner' });
}

function update(time, delta) {
  if (gamePaused || levelUpMenuOpen) return;

  // Movimentação (Estilo VS - Joystick Virtual ou Teclado)
  player.setAcceleration(0);
  if (cursors.left.isDown) player.setAccelerationX(-GAME_CONFIG.PLAYER.ACCELERATION);
  else if (cursors.right.isDown) player.setAccelerationX(GAME_CONFIG.PLAYER.ACCELERATION);
  if (cursors.up.isDown) player.setAccelerationY(-GAME_CONFIG.PLAYER.ACCELERATION);
  else if (cursors.down.isDown) player.setAccelerationY(GAME_CONFIG.PLAYER.ACCELERATION);

  // Dash (se habilitado)
  if (Phaser.Input.Keyboard.JustDown(this.keySpace) && playerStats.dashAvailable && !playerStats.dashCooldown) {
    performDash(this);
  }

  // --- LÓGICA DE AUTO-ATTACK (Vampire Survivors Style) ---
  // Encontra o inimigo mais próximo
  closestEnemy = null;
  let minDistance = Infinity;
  const weaponRange = GAME_CONFIG.WEAPONS[currentWeapon].range;

  enemies.children.each(enemy => {
      if (enemy.active) {
          const dist = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
          if (dist < minDistance && dist <= weaponRange) {
              minDistance = dist;
              closestEnemy = enemy;
          }
      }
  });

  // Atira automaticamente se houver inimigo e o cooldown permitir
  if (time > lastShoot && closestEnemy) {
    shootBullet.call(this, closestEnemy);
    lastShoot = time + playerStats.fireRate;
  }
  // -------------------------------------------------------
}

// --- Game Logic Functions ---

function shootBullet(targetEnemy) {
  let baseBulletCount = 1;
  if (playerStats.doubleBullets) baseBulletCount = 2;

  const angleRad = Phaser.Math.Angle.Between(player.x, player.y, targetEnemy.x, targetEnemy.y);

  for (let i = 0; i < baseBulletCount; i++) {
    let offsetAngle = 0;
    // Pequeno espalhamento se tiver tiro duplo
    if (baseBulletCount > 1) offsetAngle = Phaser.Math.DEG_TO_RAD * ((i === 0 ? -5 : 5));

    const bullet = bullets.get(player.x, player.y);
    if (bullet) {
      bullet.fire(angleRad + offsetAngle, playerStats.weaponBulletSpeed, playerStats.bulletDamage, playerStats.piercingCount);
    }
  }
}

function switchWeapon(weaponNum) {
  currentWeapon = weaponNum;
  const weaponConfig = GAME_CONFIG.WEAPONS[currentWeapon];
  playerStats.fireRate = weaponConfig.fireRate;
  playerStats.bulletDamage = weaponConfig.damage;
  playerStats.weaponBulletSpeed = weaponConfig.speed;
}

function bulletHitEnemy(bullet, enemy) {
  if (!bullet.active || !enemy.active) return;
  
  enemy.takeDamage(bullet.damage);
  
  // Lógica de Penetração
  bullet.piercingHealth--;
  if (bullet.piercingHealth <= 0) {
      bullet.kill();
  }

  if (enemy.health <= 0) {
    handleEnemyDeath.call(this, enemy);
  }
}

function playerHitEnemy(player, enemy) {
    if (!player.active || !enemy.active) return;
    
    // Simples iFrame check (pode ser melhorado)
    if(player.isInvulnerable) return;

    this.cameras.main.shake(GAME_CONFIG.CAMERA_SHAKE.PLAYER_HIT.DURATION, GAME_CONFIG.CAMERA_SHAKE.PLAYER_HIT.INTENSITY);
    playerStats.life -= 1;
    hud.updateHealthBar();
    
    player.setTint(0xFF0000);
    player.isInvulnerable = true;
    this.time.delayedCall(500, () => { 
        player.clearTint(); 
        player.isInvulnerable = false;
    });

    if (playerStats.life <= 0) gameOver.call(this);
}

function handleEnemyDeath(enemy) {
    if (!enemy.active) return;
    // Dropa Gema de XP em vez de dar XP direto
    dropXPGem(this, enemy.x, enemy.y, enemy.enemyType.xpValue);
    enemy.kill();
}

// NOVO: Sistema de Gemas de XP
function dropXPGem(scene, x, y, xpValue) {
    const gem = xpGemsGroup.get(x, y);
    if (gem) {
        gem.spawn(xpValue);
    }
}

function collectXPGem(player, gem) {
    if(gem.isBeingCollected) return;
    gem.isBeingCollected = true; // Evita coleta dupla
    gainXp.call(this, gem.xpValue);
    gem.kill();
}

function gainXp(amount) {
  playerStats.xp += amount;
  hud.updateXpBar();
  if (playerStats.xp >= playerStats.xpToNextLevel) {
    playerStats.level++;
    playerStats.xp -= playerStats.xpToNextLevel;
    playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.2); // Curva de XP
    hud.updateAll();
    showLevelUpMenu.call(this);
  }
}

function performDash(scene) {
    playerStats.dashCooldown = true;
    const dashVelocity = scene.physics.velocityFromRotation(player.rotation, GAME_CONFIG.PLAYER.DASH_DISTANCE * 4);
    player.body.setVelocity(dashVelocity.x, dashVelocity.y);
    player.setTint(0x00FF00);
    scene.time.delayedCall(GAME_CONFIG.PLAYER.DASH_DURATION, () => player.clearTint());
    scene.time.delayedCall(GAME_CONFIG.PLAYER.DASH_COOLDOWN_BASE, () => playerStats.dashCooldown = false);
}

function spawnEnemy() {
  if (enemies.countActive() >= GAME_CONFIG.WAVE.MAX_ENEMIES_ON_SCREEN) return;

  if (enemiesSpawnedThisWave >= enemiesInWave) {
      startNextWave.call(this);
      return;
  }
  
  // Spawn fora da tela (lógica VS)
  let x, y;
  const padding = 50;
  if (Math.random() < 0.5) {
      x = Phaser.Math.Between(-padding, config.width + padding);
      y = Math.random() < 0.5 ? -padding : config.height + padding;
  } else {
      x = Math.random() < 0.5 ? -padding : config.width + padding;
      y = Phaser.Math.Between(-padding, config.height + padding);
  }

  // Seleção de tipo simples por enquanto
  let enemyTypeKey = 'normal';
  if(waveNumber > 3 && Math.random() > 0.7) enemyTypeKey = 'fast';
  if(waveNumber > 5 && Math.random() > 0.8) enemyTypeKey = 'tank';

  const enemy = enemies.get(x, y);
  if (enemy) {
    enemy.spawn(enemyTypes[enemyTypeKey]);
    enemiesSpawnedThisWave++;
  }
}

function startNextWave() {
  waveNumber++;
  enemiesInWave += GAME_CONFIG.WAVE.ENEMY_INCREMENT_PER_WAVE;
  // Aumenta a frequência de spawn
  let newRate = enemySpawnRate - GAME_CONFIG.WAVE.SPAWN_RATE_DECREASE_PER_WAVE;
  enemySpawnRate = Math.max(200, newRate); // Limite mínimo de 200ms
  
  // Atualiza o timer do spawner
  const spawner = this.time.getEvent('spawner');
  if(spawner) spawner.delay = enemySpawnRate;

  enemiesSpawnedThisWave = 0;
  hud.updateAll();
}

// --- Custom Classes (Pooling Enabled) ---
class Bullet extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y) { super(scene, x, y, 'bullet'); }
  fire(angle, speed, damage, piercing) {
      this.setActive(true).setVisible(true);
      this.setScale(GAME_CONFIG.BULLET.INITIAL_SCALE); // MANTIDA ESCALA
      this.damage = damage;
      this.piercingHealth = piercing; // Quantos hits aguenta
      this.scene.physics.velocityFromRotation(angle, speed, this.body.velocity);
      this.setRotation(angle);
      this.lifeSpan = 2000; // Tempo de vida em ms
  }
  kill() { this.setActive(false).setVisible(false); this.body.stop(); }
  preUpdate(time, delta) {
      super.preUpdate(time, delta);
      this.lifeSpan -= delta;
      if (this.lifeSpan <= 0 || !this.scene.physics.world.bounds.contains(this.x, this.y)) this.kill();
  }
}

class Enemy extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y) { super(scene, x, y, 'enemy_robot'); }
  spawn(enemyData) {
      this.setActive(true).setVisible(true);
      this.setTexture(enemyData.texture);
      this.setScale(enemyData.scale); // MANTIDA ESCALA
      this.health = enemyData.baseHealth * (1 + (waveNumber * 0.1)); // HP escala com ondas
      this.speed = enemyData.speed;
      this.enemyType = enemyData;
      this.setTint(0xffffff);
  }
  takeDamage(amount) { this.health -= amount; this.setTint(0xff0000); this.scene.time.delayedCall(100, ()=> { if(this.active) this.clearTint() }); }
  kill() { this.setActive(false).setVisible(false); this.body.stop(); }
  update(time, delta) {
    if (!this.active || !player.active) return;
    this.scene.physics.moveToObject(this, player, this.speed);
  }
}

// NOVO: Classe para Gema de XP
class XPGem extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { 
        super(scene, x, y, 'ammo'); 
        this.setScale(0.04); // Escala pequena para a gema
        this.setTint(0x00ff00); // Verde brilhante
    }
    spawn(xpValue) {
        this.setActive(true).setVisible(true);
        this.xpValue = xpValue;
        this.isBeingCollected = false;
        this.body.setVelocity(0);
    }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if(!this.active) return;
        
        // Lógica de Magnetismo
        const dist = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y);
        if (dist < playerStats.magnetRange) {
            // Voa em direção ao jogador
            this.scene.physics.moveToObject(this, player, 600); // Velocidade do imã
        }
    }
}

// --- Menus HTML (Simplificados para o exemplo, mas funcionais) ---
function showLevelUpMenu() {
    if (levelUpMenuOpen) return;
    gamePaused = true; levelUpMenuOpen = true; this.physics.pause();
    
    const overlay = document.createElement('div'); overlay.className = 'menu-overlay';
    const container = document.createElement('div'); container.className = 'menu-container';
    container.innerHTML = '<h2 class="menu-title">Subiu de Nível!</h2>';
    const cardsDiv = document.createElement('div'); cardsDiv.className = 'cards-container';
    
    // Pega 3 itens aleatórios
    const choices = Phaser.Utils.Array.Shuffle(itemOptions).slice(0, 3);
    
    choices.forEach(item => {
        const card = document.createElement('div'); card.className = 'card';
        card.innerHTML = `<h3 class="card-title">${item.nome}</h3><p class="card-rarity" style="color:${itemRarities[item.rarity].color}">${item.rarity}</p><p>${item.descricao}</p><button class="card-button">Selecionar</button>`;
        card.querySelector('button').onclick = () => {
            item.efeito(this);
            document.body.removeChild(overlay);
            levelUpMenuOpen = false; gamePaused = false; this.physics.resume();
        };
        cardsDiv.appendChild(card);
    });
    container.appendChild(cardsDiv); overlay.appendChild(container); document.body.appendChild(overlay);
}

function gameOver() {
  this.physics.pause(); gamePaused = true;
  const overlay = document.createElement('div'); overlay.className = 'menu-overlay';
  overlay.innerHTML = '<div class="menu-container"><h2 class="menu-title" style="color:red">VOCÊ MORREU</h2><button class="card-button" onclick="location.reload()">Tentar Novamente</button></div>';
  document.body.appendChild(overlay);
}

new Phaser.Game(config);
</script>
</body>
</html>





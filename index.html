<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons V.1.2.8 - Multi-Enemy Update + Classes + Weapon Levels</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0a0000ce;
    }
    canvas {
      display: block;
      margin: auto;
    }
  </style>

</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 1300,
  height: 580,
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: { debug: false }
  },
  scene: {
    preload,
    create,
    update
  }
};

let waveText;
let hudGroup;
let armaNomeText;
let armaImagem;
let player, cursors;
let bullets, enemies, enemyBullets, armas;
let lastShoot = 0;
let showingCards = false;
let wave = 1; //onda
let cardsGroup; //grupo de cartas
let spiritAlly = null; //aliado
let playerCards = []; // Cartas que o jogador pegou
let cardsHUDGroup; // Grupo visual do HUD de cartas
let playerStatsPanel; // Novo grupo para o painel de stats do jogador
let waveXpGoalText; // Novo texto para a meta de XP da onda

let playerStats = {
  life: 3,
  maxLife: 3,
  bulletDamage: 1,
  fireRate: 3000,
  hasShield: false,
  spiritAllyActive: false,
  spreadUpgrade: false,
  doubleBullets: false,
  dashAvailable: false,
  dashCooldown: false,
  slowEnemies: false,
  reviveOnce: false,
  increasedDropRate: false,
  tripleBullets: false,
  playerSpeed: 400,
  healOnKill: false,
  damageAura: false,
  speedBoost: false,
  bulletPiercing: false,
  thorns: false,
  bulletSpeedBoost: false,
  xp: 0,
  level: 1,
  xpToNextLevel: 100,
  waveXpGoal: 20,
  currentWeapon: 'arma1', // Adicionado para rastrear a arma atual
  currentWeaponLevel: 1, // Nível da arma atual
  playerClass: null // Classe do jogador
};

const tiposDeArmas = {
  arma1: { nome: 'Pistolinha', baseDano: 1, baseFireRate: 3000 },
  arma2: { nome: 'Fúria de Eryon', baseDano: 2, baseFireRate: 1000 },
  arma3: { nome: 'Lança-Raio', baseDano: 3, baseFireRate: 2000 }
};

const enemyTypes = {
  normal: {
    name: 'Robô Comum',
    texture: 'enemy',
    baseHealth: 4,
    speed: 100,
    scale: 0.06,
    xpReward: 10
  },
  fast: {
    name: 'Robô Ágil',
    texture: 'enemy_fast',
    baseHealth: 4,
    speed: 180,
    scale: 0.06,
    xpReward: 15
  },
  tank: {
    name: 'Robô Tanque',
    texture: 'enemy_tank',
    baseHealth: 9,
    speed: 70,
    scale: 0.08,
    xpReward: 25
  }
};

const playerClasses = {
  bioWarrior: {
    name: 'Bio-Guerreiro',
    description: 'Um combatente resistente. +1 Vida Máxima. Recupera 0.1 de vida a cada 5s.',
    initialStats: {
      maxLife: 4,
      life: 4,
    },
    passiveAbility: (scene) => {
      scene.time.addEvent({
        delay: 5000,
        loop: true,
        callback: () => {
          playerStats.life = Math.min(playerStats.life + 0.1, playerStats.maxLife);
          scene.hud.update();
        }
      });
    }
  },
  techSniper: {
    name: 'Tecno-Atirador',
    description: 'Especialista em dano. +1 Dano, +10% Velocidade de Bala.',
    initialStats: {
      bulletDamage: 2,
      bulletSpeedBoost: true
    },
    passiveAbility: (scene) => {
      // Implementação da passiva, se houver
    }
  },
  mechanic: {
    name: 'Mecânico',
    description: 'Aumenta a chance de encontrar armas. +10% Chance de drop de arma.',
    initialStats: {
      increasedDropRate: true
    },
    passiveAbility: (scene) => {
      // Implementação da passiva, se houver
    }
  }
};

const game = new Phaser.Game(config);

function preload() {
  this.load.image('cardBg', 'assets/card.png');
  this.load.image('player', 'assets/player.png');
  this.load.image('bullet', 'assets/bullet.png');
  this.load.image('arma1', 'assets/pistolinha.png');
  this.load.image('arma2', 'assets/metralha.png');
  this.load.image('arma3', 'assets/lancarrio.png');
  this.load.image('fundogame', 'assets/fundogame.png');
  this.load.image('cora', 'assets/cora.png');

  this.load.image('enemy', 'assets/enemy_robot.png');
  this.load.image('enemy_fast', 'assets/enemy_fast.png');
  this.load.image('enemy_tank', 'assets/enemy_tank.png');
}

function create() {
  this.add.image(config.width / 2, config.height / 2, 'fundogame').setDepth(-1);

  player = this.physics.add.sprite(400, 300, 'player').setCollideWorldBounds(true).setScale(0.05);
  player.health = playerStats.life;
  player.maxHealth = playerStats.maxLife;

  this.hud = new HUD(this, player);

  bullets = this.physics.add.group();
  enemies = this.physics.add.group();
  enemyBullets = this.physics.add.group();
  armas = this.physics.add.group();

  cursors = this.input.keyboard.createCursorKeys();

  // Chamada da tela de seleção de classes antes de iniciar o jogo
  createClassSelection.call(this);

  this.physics.add.overlap(player, armas, (player, arma) => {
    pegarArma.call(this, arma);
  });

  this.input.keyboard.on('keydown-Z', () => {
    if (playerStats.dashAvailable && !playerStats.dashCooldown) {
      dashPlayer.call(this);
    }
  });

  this.input.keyboard.on('keydown-SPACE', () => {
    if (!player.active && !showingCards) { // Adicionado !showingCards para evitar restart durante seleção de carta
      this.time.delayedCall(500, () => {
        // Reset playerStats para o estado inicial para um novo jogo
        playerStats = {
            life: 3,
            maxLife: 3,
            bulletDamage: 1,
            fireRate: 3000,
            hasShield: false,
            spiritAllyActive: false,
            spreadUpgrade: false,
            doubleBullets: false,
            dashAvailable: false,
            dashCooldown: false,
            slowEnemies: false,
            reviveOnce: false,
            increasedDropRate: false,
            tripleBullets: false,
            playerSpeed: 400,
            healOnKill: false,
            damageAura: false,
            speedBoost: false,
            bulletPiercing: false,
            thorns: false,
            bulletSpeedBoost: false,
            xp: 0,
            level: 1,
            xpToNextLevel: 100,
            waveXpGoal: 20,
            currentWeapon: 'arma1',
            currentWeaponLevel: 1,
            playerClass: null
        };
        wave = 1;
        playerCards = [];
        this.scene.restart();
      });
    }
  });

  this.physics.add.overlap(bullets, enemies, (b, e) => {
    if (b.active && e.active) {
      e.health -= playerStats.bulletDamage;

      if (!playerStats.bulletPiercing) {
        b.destroy();
      } else {
        const particles = this.add.particles('bullet');
        particles.createEmitter({
          x: e.x,
          y: e.y,
          speed: { min: -50, max: 50 },
          scale: { start: 0.05, end: 0 },
          lifespan: 300,
          blendMode: 'ADD',
          quantity: 6
        });
      }

      if (e.health <= 0) {
        e.destroy();
        gainXp.call(this, e.xpReward);
        if (playerStats.healOnKill) {
          playerStats.life = Math.min(playerStats.life + 0.5, playerStats.maxLife);
          this.hud.update();
        }
      }
    }
  });

  this.physics.add.overlap(enemyBullets, player, (b, p) => {
    if (b.active && p.active) {
      b.destroy();
      if (!playerStats.hasShield) {
        playerStats.life--;
        this.hud.update();
        p.setTint(0xff0000);
        this.time.delayedCall(100, () => p.clearTint());

        if (playerStats.thorns) {
          enemies.getChildren().forEach(enemy => {
            const dist = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
            if (enemy.active && dist < 150) {
              enemy.health -= 1;
              if (enemy.health <= 0) {
                enemy.destroy();
                gainXp.call(this, enemy.xpReward);
              }
            }
          });
        }

        if (playerStats.life <= 0) {
          if (playerStats.reviveOnce) {
            playerStats.life = 1;
            playerStats.reviveOnce = false;
            this.hud.update();
            p.clearTint();
            const reviveText = this.add.text(config.width / 2, config.height / 2 - 50, 'REVIVED!', {
              fontFamily: 'Cinzel',
              fontSize: '36px',
              color: '#00FF00',
              stroke: '#000000',
              strokeThickness: 6,
              align: 'center'
            }).setOrigin(0.5);
            this.time.delayedCall(3000, () => reviveText.destroy());
          } else {
            p.setActive(false).setVisible(false);
            const gameOverText = this.add.text(config.width / 2, config.height / 2, 'GAME OVER\nPress SPACE to Restart', {
              fontFamily: 'Cinzel',
              fontSize: '48px',
              color: '#FF0000',
              stroke: '#000000',
              strokeThickness: 6,
              align: 'center'
            }).setOrigin(0.5);
          }
        }
      } else {
        playerStats.hasShield = false;
        p.clearTint();
      }
    }
  });

  // HUD elements
  hudGroup = this.add.group();
  cardsHUDGroup = this.add.group();
  playerStatsPanel = this.add.group(); // Inicializa o grupo para o painel de stats

  // Weapon HUD
  armaNomeText = this.add.text(config.width / 2, 20, 'Pistolinha LV1', {
    fontFamily: 'Cinzel',
    fontSize: '28px',
    color: '#A62E2E',
    stroke: '#000000',
    strokeThickness: 4,
    shadow: { offsetX: 2, offsetY: 2, color: '#000', blur: 4, stroke: true, fill: true }
  }).setOrigin(0.5, 0);

  const box = this.add.rectangle(config.width / 2, 40, 300, 70, 0x111111, 0.3).setOrigin(0.5, 0);
  box.setStrokeStyle(2, 0x00ffff, 0.1);
  hudGroup.add(box);

  armaImagem = this.add.image(config.width / 2, 70, 'arma1').setScale(0.1);
  hudGroup.addMultiple([armaNomeText, armaImagem]);

  // Wave Text
  waveText = this.add.text(config.width - 20, 20, `Fase ${wave}`, {
    fontFamily: 'Cinzel',
    fontSize: '24px',
    color: '#FFFFFF',
    stroke: '#000000',
    strokeThickness: 4
  }).setOrigin(1, 0);

  // Wave XP Goal Text
  waveXpGoalText = this.add.text(config.width / 2, config.height - 50, `Meta de XP para Onda: ${playerStats.waveXpGoal}`, {
      fontSize: '18px',
      color: '#FFD700',
      stroke: '#000',
      strokeThickness: 2
  }).setOrigin(0.5);

  this.time.addEvent({
    delay: 9000,
    loop: true,
    callback: () => {
      enemies.getChildren().forEach(enemy => {
        if (!enemy.active) return;
        const bullet = enemyBullets.create(enemy.x, enemy.y, 'bullet').setScale(0.03);
        const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
        this.physics.velocityFromRotation(angle, 150, bullet.body.velocity);
      });
    }
  });

  // Call initial HUD updates
  this.hud.updatePlayerStatsPanel();
  atualizarHUDarma(tiposDeArmas[playerStats.currentWeapon].nome, playerStats.currentWeapon);
}

function createClassSelection() {
    const classSelectionBg = this.add.rectangle(config.width / 2, config.height / 2, config.width, config.height, 0x000000, 0.9).setDepth(100);
    const titleText = this.add.text(config.width / 2, config.height / 2 - 200, 'Selecione sua Classe Bio-Punk', {
        fontFamily: 'Cinzel',
        fontSize: '48px',
        color: '#00FFFF',
        stroke: '#000000',
        strokeThickness: 8,
        align: 'center'
    }).setOrigin(0.5).setDepth(101);

    const classButtons = this.add.group();
    let xOffset = -250;

    Object.entries(playerClasses).forEach(([key, classData]) => {
        const button = this.add.container(config.width / 2 + xOffset, config.height / 2 + 50).setDepth(101);
        const bg = this.add.rectangle(0, 0, 200, 250, 0x333333, 0.8).setStrokeStyle(2, 0x00FFFF);
        const name = this.add.text(0, -90, classData.name, {
            fontFamily: 'Cinzel',
            fontSize: '28px',
            color: '#FFFFFF',
            stroke: '#000000',
            strokeThickness: 4,
            align: 'center',
            wordWrap: { width: 180 }
        }).setOrigin(0.5);
        const desc = this.add.text(0, 0, classData.description, {
            fontSize: '16px',
            color: '#E0E0E0',
            align: 'center',
            wordWrap: { width: 180 }
        }).setOrigin(0.5);

        button.add([bg, name, desc]);
        button.setSize(200, 250);
        button.setInteractive();

        button.on('pointerover', () => {
            bg.setFillStyle(0x555555, 0.9);
        });

        button.on('pointerout', () => {
            bg.setFillStyle(0x333333, 0.8);
        });

        button.on('pointerdown', () => {
            playerStats.playerClass = key;
            // Apply initial stats
            Object.assign(playerStats, playerClasses[key].initialStats);
            // Activate passive ability
            playerClasses[key].passiveAbility(this);

            classSelectionBg.destroy();
            titleText.destroy();
            classButtons.clear(true, true); // Destroi os botões

            // Start the game after class selection
            player.setActive(true).setVisible(true); // Garante que o jogador está visível
            spawnArmas.call(this);
            spawnWave.call(this);
            this.hud.update(); // Atualiza HUD com novos stats
            this.hud.updatePlayerStatsPanel();
        });

        classButtons.add(button);
        xOffset += 250;
    });

    player.setActive(false).setVisible(false); // Esconde o jogador até a seleção da classe
}


function spawnArmas() {
  const tipos = Object.keys(tiposDeArmas);

  let dropCount = 3;
  if (playerStats.increasedDropRate && Phaser.Math.Between(0,100) < 50) { // 50% extra chance
    dropCount++;
  }
  if (playerStats.playerClass === 'mechanic') { // Classe mecânico
    dropCount++; // +1 drop garantido para o mecânico
  }

  for (let i = 0; i < dropCount; i++) {
    const tipo = Phaser.Utils.Array.GetRandom(tipos);
    const x = Phaser.Math.Between(100, config.width - 100);
    const y = Phaser.Math.Between(100, config.height - 100);
    const arma = armas.create(x, y, tipo).setScale(0.02);
    arma.tipo = tipo;
  }
}

function pegarArma(arma) {
  playerStats.currentWeapon = arma.tipo; // Atualiza a arma atual
  updateWeaponStats(); // Recalcula os stats da arma
  arma.destroy();

  const nomeArmasMap = {
    arma1: 'Pistolinha',
    arma2: 'Fúria de Eryon',
    arma3: 'Lança-Raio'
  };

  atualizarHUDarma(nomeArmasMap[arma.tipo], arma.tipo);

  const pickupText = this.add.text(player.x, player.y - 30, `Pegou ${nomeArmasMap[arma.tipo]}!`, {
    fontSize: '18px',
    color: '#FFD700',
    fontStyle: 'bold',
    stroke: '#000',
    strokeThickness: 3
  }).setOrigin(0.5).setDepth(99).setScrollFactor(0).setAlpha(0.7);
    this.time.delayedCall(2000, () => pickupText.destroy());
}

function updateWeaponStats() {
    const currentWeaponProps = tiposDeArmas[playerStats.currentWeapon];
    // Dano base + (nível da arma - 1) * 0.5 (exemplo de escalonamento)
    playerStats.bulletDamage = currentWeaponProps.baseDano + (playerStats.currentWeaponLevel - 1) * 0.5;
    // Cadência base - (nível da arma - 1) * 50 (exemplo de escalonamento)
    playerStats.fireRate = currentWeaponProps.baseFireRate - (playerStats.currentWeaponLevel - 1) * 50;
    
    // Certifica-se de que a cadência de tiro não seja muito baixa
    if (playerStats.fireRate < 100) playerStats.fireRate = 100;

    // Aplicar bônus de classe se for Tecno-Atirador
    if (playerStats.playerClass === 'techSniper') {
        playerStats.bulletDamage += 1; // +1 de dano da classe
        // playerStats.bulletSpeedBoost já é definido em initialStats da classe
    }

    atualizarHUDarma(tiposDeArmas[playerStats.currentWeapon].nome, playerStats.currentWeapon);
    game.scene.scenes[0].hud.updatePlayerStatsPanel(); // Atualiza o painel de stats
}


function atualizarHUDarma(nomeArma, keyImagem) {
  armaNomeText.setText(`${nomeArma} LV${playerStats.currentWeaponLevel}`);
  armaImagem.setTexture(keyImagem);
}

function atualizarHUDCartas(scene) {
  cardsHUDGroup.clear(true, true);

  const startX = 50;
  const startY = 140;
  const gap = 60;

  playerCards.forEach((card, index) => {
    const bg = scene.add.rectangle(startX + index * gap, startY, 50, 70, card.cor || 0x999999, 0.8)
      .setStrokeStyle(2, 0xffffff);
    const title = scene.add.text(startX + index * gap, startY, card.nome[0], {
      fontSize: '24px',
      color: '#fff',
      fontStyle: 'bold'
    }).setOrigin(0.5);
    const nameTip = scene.add.text(startX + index * gap, startY + 40, card.nome, {
      fontSize: '12px',
      color: '#fff',
      align: 'center',
      wordWrap: { width: 50 }
    }).setOrigin(0.5);


    cardsHUDGroup.add(bg);
    cardsHUDGroup.add(title);
    cardsHUDGroup.add(nameTip);
  });
}

function update(time) {
  this.hud.update();
  this.hud.updatePlayerStatsPanel(); // Atualiza constantemente para refletir mudanças

  if (!player.active || showingCards) return; // Não move ou atira se o jogo estiver pausado para seleção de carta

  let vx = 0, vy = 0;
  if (cursors.left.isDown) vx = -1;
  else if (cursors.right.isDown) vx = 1;

  if (cursors.up.isDown) vy = -1;
  else if (cursors.down.isDown) vy = 1;

  const norm = Math.hypot(vx, vy) || 1;
  player.setVelocity((vx / norm) * playerStats.playerSpeed, (vy / norm) * playerStats.playerSpeed);

  if (time > lastShoot + playerStats.fireRate) {
    shootRadial.call(this);
    lastShoot = time;
  }

  enemies.getChildren().forEach(enemy => {
    if (!enemy.active) return;
    const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
    this.physics.velocityFromRotation(angle, enemy.speed, enemy.body.velocity);
  });

  let closestEnemy = null;
  let minDistance = Infinity;
  enemies.getChildren().forEach(enemy => {
    if (enemy.active) {
      const distance = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
      if (distance < minDistance) {
        minDistance = distance;
        closestEnemy = enemy;
      }
    }
  });
  this.hud.setEnemy(closestEnemy);

  if (playerStats.spiritAllyActive && spiritAlly) {
    spiritAlly.x = player.x + 50;
    spiritAlly.y = player.y - 50;
  }


  if (enemies.countActive() === 0 && !showingCards) {
    showingCards = true;
    showCardChoices.call(this);
  }
}

function shootRadial() {
  const count = playerStats.spreadUpgrade ? 24 : 12;
  let speed = playerStats.bulletSpeedBoost ? 900 : 700;

  // Bônus de velocidade de bala da classe Tecno-Atirador
  if (playerStats.playerClass === 'techSniper') {
      speed *= 1.1; // +10% de velocidade
  }

  for (let i = 0; i < count; i++) {
    const baseAngle = Phaser.Math.DegToRad((360 / count) * i);

    const criarBala = (angleOffset = 0) => {
      const angle = baseAngle + angleOffset;
      const bullet = bullets.create(player.x, player.y, 'bullet').setScale(0.02);

      this.time.delayedCall(500, () => {
        if (bullet && bullet.active) bullet.destroy();
      });

      this.physics.velocityFromRotation(angle, speed, bullet.body.velocity);
    };

    if (playerStats.tripleBullets) {
      criarBala(Phaser.Math.DegToRad(-5));
      criarBala(0);
      criarBala(Phaser.Math.DegToRad(5));

    } else if (playerStats.doubleBullets) {
      criarBala(Phaser.Math.DegToRad(-3));
      criarBala(Phaser.Math.DegToRad(3));

    } else {
      criarBala();
    }
  }
}

function showCardChoices() {
    if (playerStats.xp < playerStats.waveXpGoal) {
        player.setActive(false).setVisible(false);
        const failureText = this.add.text(config.width / 2, config.height / 2, 'FALHA NA ONDA!\nXP Insuficiente\nVoltando para Fase 1\n(Pressione ESPAÇO para reiniciar)', {
            fontFamily: 'Cinzel',
            fontSize: '36px',
            color: '#FF4500',
            stroke: '#000000',
            strokeThickness: 6,
            align: 'center'
        }).setOrigin(0.5).setDepth(100);

        // Reset playerStats para o estado inicial
        playerStats = {
            life: 3,
            maxLife: 3,
            bulletDamage: 1,
            fireRate: 3000,
            hasShield: false,
            spiritAllyActive: false,
            spreadUpgrade: false,
            doubleBullets: false,
            dashAvailable: false,
            dashCooldown: false,
            slowEnemies: false,
            reviveOnce: false,
            increasedDropRate: false,
            tripleBullets: false,
            playerSpeed: 400,
            healOnKill: false,
            damageAura: false,
            speedBoost: false,
            bulletPiercing: false,
            thorns: false,
            bulletSpeedBoost: false,
            xp: 0,
            level: 1,
            xpToNextLevel: 100,
            waveXpGoal: 20,
            currentWeapon: 'arma1',
            currentWeaponLevel: 1,
            playerClass: null
        };
        wave = 1;
        playerCards = [];
        this.hud.update(); // Atualiza HUD com novos stats
        this.hud.updatePlayerStatsPanel();
        this.hud.updateXpBar();
        showingCards = false; // Permite reiniciar
        return;
    }

    playerStats.waveXpGoal = Math.floor(playerStats.waveXpGoal * 1.5);
    waveXpGoalText.setText(`Meta de XP para Onda: ${playerStats.waveXpGoal}`);


  const cardOptions = [
    { nome: 'Escudo de Ivirik', desc: 'Proteção que te salva da morte uma vez', cor: 0xffc107, efeito: () => { playerStats.hasShield = true; } },
    { nome: 'Tiro Duplo', desc: 'Dispara duas vezes mais balas', cor: 0x4caf50, efeito: () => { playerStats.doubleBullets = true; } },
    { nome: 'Bênção do dr Anomoi', desc: 'Um automato te ajuda no ataque', cor: 0x00bcd4, efeito: ativarSpiritAlly },
    { nome: 'Upgrade do Spread', desc: 'Dispara balas em círculo maior', cor: 0x9c27b0, efeito: () => { playerStats.spreadUpgrade = true; } },
    { nome: 'Dash ', desc: 'Corrida rápida para escapar', cor: 0xf44336, efeito: () => { playerStats.dashAvailable = true; } },
    { nome: 'Projétil Perfurante', desc: 'Balas atravessam inimigos de forma avassaladora', cor: 0x03a9f4, efeito: () => { playerStats.bulletPiercing = true; } },
    { nome: 'Recuperação Instantânea', desc: 'Recupera 2 de vida', cor: 0x8bc34a, efeito: () => { playerStats.life = Math.min(playerStats.life + 2, playerStats.maxLife); this.hud.update(); } },
    { nome: 'Fúria de Metalion', desc: 'Aumenta o dano por 15s', cor: 0xff5722, efeito: () => { playerStats.bulletDamage += 1; this.time.delayedCall(15000, () => playerStats.bulletDamage -= 1); this.hud.updatePlayerStatsPanel();} },
    { nome: 'Vida Fantasma', desc: 'Sobrevive com 1 de vida ao morrer', cor: 0x673ab7, efeito: () => { playerStats.reviveOnce = true; } },
    { nome: 'Energético da Meia-Noite', desc: 'Velocidade de movimento aumentada em 50% por 10s', cor: 0xffeb3b, efeito: () => {
        const originalSpeed = playerStats.playerSpeed;
        playerStats.playerSpeed *= 1.5;
        this.time.delayedCall(10000, () => playerStats.playerSpeed = originalSpeed);
        this.hud.updatePlayerStatsPanel();
      }
    },
    { nome: 'Aura Letal', desc: 'Causa dano contínuo nos inimigos próximos', cor: 0xcd201f, efeito: () => {
        playerStats.damageAura = true;
        this.time.addEvent({
          delay: 1000,
          loop: true,
          callback: () => {
            enemies.getChildren().forEach(e => {
              const dist = Phaser.Math.Distance.Between(player.x, player.y, e.x, e.y);
              if (e.active && dist < 100) {
                e.health -= 1;
                if (e.health <= 0) {
                  e.destroy();
                  gainXp.call(this, e.xpReward);}
                }
            });
          }
        });
      }
    },
    { nome: 'Velocidade Neuronal', desc: 'Recarga de tiro 2x mais rápida por 10s', cor: 0x03a9f4, efeito: () => {
        const originalRate = playerStats.fireRate;
        playerStats.fireRate /= 2;
        this.time.delayedCall(10000, () => playerStats.fireRate = originalRate);
        this.hud.updatePlayerStatsPanel();
      }
    },
    { nome: 'Hack dos Fragmentos', desc: 'Chance dobrada de aparecer armas nas próximas ondas', cor: 0x607d8b, efeito: () => {
        playerStats.increasedDropRate = true;
      }
    },
    { nome: 'Respiro do Caos', desc: 'Recupera toda sua vida', cor: 0x009688, efeito: () => {
        playerStats.life = playerStats.maxLife;
        this.hud.update();
      }
    },
    { nome: 'Espelho de Plasma', desc: 'Reflete 30% do dano de volta ao inimigo por 10s', cor: 0x673ab7, efeito: () => {
        playerStats.hasShield = true;
        const reflectText = this.add.text(config.width / 2, config.height / 2 - 100, 'Reflect not fully implemented!', { fontSize: '20px', color: '#FFF' }).setOrigin(0.5).setDepth(100);
        this.time.delayedCall(3000, () => reflectText.destroy());
      }
    },
    { nome: 'Canhão Triplo', desc: 'Atira 3 balas em vez de 1', cor: 0xff9800, efeito: () => {
        playerStats.tripleBullets = true;
      }
    },
    { nome: 'Espinhos do Asfalto', desc: 'Dano nos inimigos ao ser atingido', cor: 0xe91e63, efeito: () => { playerStats.thorns = true; } },
    { nome: 'Visão de Águia', desc: 'Suas balas voam mais rápido', cor: 0x5cb85c, efeito: () => { playerStats.bulletSpeedBoost = true; } },
    { nome: 'Armadura Reforçada', desc: 'Aumenta sua vida máxima em 1', cor: 0x7e57c2, efeito: () => {
        playerStats.maxLife += 1;
        playerStats.life = playerStats.maxLife;
        this.hud.updateHealthBar();
        this.hud.update();
        this.hud.updatePlayerStatsPanel();
      }
    },
    { nome: 'Toque Vampírico', desc: 'Recupere vida ao derrotar inimigos', cor: 0x8b0000, efeito: () => { playerStats.healOnKill = true; } },
    { nome: 'Carga do Trovão', desc: 'Dash atordoa inimigos próximos', cor: 0x42a5f5, efeito: () => {
        playerStats.dashAvailable = true;
        playerStats.stunOnDash = true;
      }
    },
  ];


  Phaser.Utils.Array.Shuffle(cardOptions);
  const selectedCards = cardOptions.slice(0, 3);

  cardsGroup = this.add.group();

  const startX = this.cameras.main.centerX;
  const startY = this.cameras.main.centerY;
  const gap = 220;

  selectedCards.forEach((card, i) => {
    const x = startX + (i - 1) * gap;
    const y = startY;

    const container = this.add.container(x, y);
    container.setDepth(10); // Garante que as cartas apareçam acima de tudo

    const bgImage = this.add.image(0, 0, 'cardBg').setDisplaySize(160, 240);

    const title = this.add.text(0, -80, card.nome, { fontSize: '20px', color: '#fff', align: 'center', wordWrap: { width: 140 } }).setOrigin(0.5);
    const desc = this.add.text(0, 0, card.desc, { fontSize: '14px', color: '#eee', align: 'center', wordWrap: { width: 140 } }).setOrigin(0.5);

    container.add([bgImage, title, desc]);

    container.setSize(160, 240);
    container.setInteractive();

    this.tweens.add({
      targets: container,
      y: y - 20,
      yoyo: true,
      repeat: -1,
      duration: 1000,
      ease: 'Sine.easeInOut'
    });

    container.on('pointerover', () => {
      container.setScale(1.1);
    });

    container.on('pointerout', () => {
      container.setScale(1);
    });

    container.on('pointerdown', () => {
      this.tweens.add({
        targets: container,
        scale: 0.9,
        duration: 100,
        yoyo: true,
        ease: 'Power1',
        onComplete: () => {
          card.efeito.call(this);
          cardsGroup.clear(true, true);

          playerCards.push(card);
          atualizarHUDCartas(this);

          showingCards = false;
          wave++;
          waveText.setText(`Fase ${wave}`);

          // Lógica de nível da arma a cada 5 ondas
          if (wave % 5 === 0) {
              playerStats.currentWeaponLevel++;
              updateWeaponStats();
              const levelUpWeaponText = this.add.text(config.width / 2, config.height / 2 - 100, `ARMA LV UP! LV${playerStats.currentWeaponLevel}`, {
                  fontFamily: 'Cinzel',
                  fontSize: '36px',
                  color: '#FFD700',
                  stroke: '#000000',
                  strokeThickness: 6,
                  align: 'center'
              }).setOrigin(0.5).setDepth(100);
              this.time.delayedCall(3000, () => levelUpWeaponText.destroy());
          }

          spawnWave.call(this);
        }
      });
    });

    cardsGroup.add(container);
  });
}

function ativarSpiritAlly() {
  if (spiritAlly) spiritAlly.destroy();

  spiritAlly = this.physics.add.sprite(player.x, player.y, 'player').setScale(0.03).setAlpha(0.7);
  playerStats.spiritAllyActive = true;

  this.time.addEvent({
    delay: 1500,
    loop: true,
    callback: () => {
      if (!playerStats.spiritAllyActive || !spiritAlly || !spiritAlly.active) return;
      const closestEnemy = enemies.getChildren().reduce((closest, enemy) => {
        if (!enemy.active) return closest;
        const dist = Phaser.Math.Distance.Between(spiritAlly.x, spiritAlly.y, enemy.x, enemy.y);
        if (dist < closest.distance) {
          return { enemy: enemy, distance: dist };
        }
        return closest;
      }, { enemy: null, distance: Infinity });

      if (closestEnemy.enemy) {
        const bullet = bullets.create(spiritAlly.x, spiritAlly.y, 'bullet').setScale(0.02);
        const angle = Phaser.Math.Angle.Between(spiritAlly.x, spiritAlly.y, closestEnemy.enemy.x, closestEnemy.enemy.y);
        this.physics.velocityFromRotation(angle, 500, bullet.body.velocity);
      }
    }
  });

  this.time.delayedCall(15000, () => {
    if (spiritAlly) spiritAlly.destroy();
    playerStats.spiritAllyActive = false;
  }, [], this);
}

function spawnWave() {
  const totalEnemiesToSpawn = Math.floor(wave * 2.5);

  for (let i = 0; i < totalEnemiesToSpawn; i++) {
    const x = Phaser.Math.Between(100, config.width - 100);
    const y = Phaser.Math.Between(100, config.height - 100);

    let enemyTypeKey = 'normal';

    if (wave >= 3 && Phaser.Math.Between(0, 100) < 30 + wave * 3) {
      enemyTypeKey = 'fast';
    }
    if (wave >= 5 && Phaser.Math.Between(0, 100) < 20 + wave * 2) {
      enemyTypeKey = 'tank';
    }

    if (wave >= 7 && Phaser.Math.Between(0, 100) < 60) {
      enemyTypeKey = Phaser.Utils.Array.GetRandom(['fast', 'tank']);
    }

    const typeProps = enemyTypes[enemyTypeKey];
    const enemy = enemies.create(x, y, typeProps.texture).setScale(typeProps.scale);

    enemy.health = typeProps.baseHealth + Math.floor(wave / 2);
    enemy.maxHealth = enemy.health;
    enemy.speed = typeProps.speed + Math.floor(wave * 2);
    enemy.setCollideWorldBounds(true);
    enemy.enemyType = typeProps.name; // Armazena o nome do tipo de inimigo

    // LÓGICA PARA AUMENTAR O XP NAS PRIMEIRAS ONDAS (1 a 5)
    let bonusXP = 0;
    if (wave <= 5) {
        switch (wave) {
            case 1: bonusXP = 20; break;
            case 2: bonusXP = 15; break;
            case 3: bonusXP = 10; break;
            case 4: bonusXP = 5; break;
            case 5: bonusXP = 0; break;
        }
    }
    enemy.xpReward = typeProps.xpReward + bonusXP;
    // FIM DA LÓGICA DE XP

  }
  spawnArmas.call(this); // Spawna armas a cada nova onda
}

function dashPlayer() {
  if (playerStats.dashCooldown) return;

  playerStats.dashCooldown = true;

  let dx = 0, dy = 0;
  if (cursors.left.isDown) dx = -1;
  else if (cursors.right.isDown) dx = 1;
  if (cursors.up.isDown) dy = -1;
  else if (cursors.down.isDown) dy = 1;

  if (dx === 0 && dy === 0) {
    playerStats.dashCooldown = false;
    return;
  }

  const dashDistance = 150;

  this.tweens.add({
    targets: player,
    x: player.x + dx * dashDistance,
    y: player.y + dy * dashDistance,
    duration: 150,
    ease: 'Power2',
    onComplete: () => {
      playerStats.dashCooldown = false;
      if (playerStats.stunOnDash) {
        enemies.getChildren().forEach(enemy => {
          const dist = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
          if (enemy.active && dist < 100) {
            enemy.body.setVelocity(0,0);
            enemy.setTint(0x0000ff);
            this.time.delayedCall(1000, () => enemy.clearTint());
          }
        });
      }
    }
  });
}

function gainXp(amount) {
  playerStats.xp += amount;
  this.hud.updateXpBar();

  if (playerStats.xp >= playerStats.xpToNextLevel) {
    playerStats.level++;
    playerStats.xp -= playerStats.xpToNextLevel;
    playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.5);
    playerStats.bulletDamage *= 1.012; // Pequeno aumento de dano no level up
    this.hud.updateXpBar();
    this.hud.updatePlayerStatsPanel(); // Atualiza stats no level up
    const levelUpText = this.add.text(config.width / 2, config.height / 2 + 50, `LEVEL UP! Level ${playerStats.level}`, {
      fontFamily: 'Cinzel',
      fontSize: '40px',
      color: '#00FFFF',
      stroke: '#000000',
      strokeThickness: 6,
      align: 'center'
    }).setOrigin(0.5);
    this.time.delayedCall(3000, () => levelUpText.destroy());
  }
}

class HUD {
  constructor(scene, player) {
    this.scene = scene;
    this.player = player;

    // Player Health Bar
    this.playerHealthBarBg = this.scene.add.graphics();
    this.playerHealthBarFill = this.scene.add.graphics();
    this.playerHealthBarX = 20;
    this.playerHealthBarY = 20;
    this.playerHealthBarWidth = 150;
    this.playerHealthBarHeight = 20;
    this.updateHealthBar();

    // Enemy Health Bar
    this.enemyHealthBarBg = this.scene.add.graphics();
    this.enemyHealthBarFill = this.scene.add.graphics();
    this.enemyNameText = this.scene.add.text(0, 0, '', { fontSize: '16px', color: '#FFF' }).setOrigin(0.5);
    this.enemyHealthBarX = 20;
    this.enemyHealthBarY = 60;
    this.enemyHealthBarWidth = 150;
    this.enemyHealthBarHeight = 20;
    this.enemy = null;

    // XP Bar
    this.xpBarBg = this.scene.add.graphics();
    this.xpBarFill = this.scene.add.graphics();
    this.xpText = this.scene.add.text(config.width / 2, config.height - 30, `LV ${playerStats.level} XP: ${playerStats.xp}/${playerStats.xpToNextLevel}`, {
      fontSize: '18px',
      color: '#FFFFFF'
    }).setOrigin(0.5);
    this.xpBarX = config.width / 2 - 150;
    this.xpBarY = config.height - 20;
    this.xpBarWidth = 300;
    this.xpBarHeight = 10;
    this.updateXpBar();

    // Player Stats Panel
    this.playerStatsPanelBg = this.scene.add.graphics();
    this.playerStatsText = this.scene.add.text(20, 100, '', {
        fontSize: '16px',
        color: '#FFFFFF',
        lineSpacing: 5
    });
    this.updatePlayerStatsPanel();
  }

  update() {
    this.updateHealthBar();

    if (this.enemy && this.enemy.active) {
      this.enemyHealthBarBg.clear();
      this.enemyHealthBarFill.clear();
      this.enemyNameText.setVisible(true);

      this.enemyHealthBarBg.fillStyle(0x000000, 0.6);
      this.enemyHealthBarBg.fillRect(this.enemyHealthBarX, this.enemyHealthBarY, this.enemyHealthBarWidth, this.enemyHealthBarHeight);

      const healthPercent = Phaser.Math.Clamp(this.enemy.health / this.enemy.maxHealth, 0, 1);
      this.enemyHealthBarFill.fillStyle(0xff0000, 1);
      this.enemyHealthBarFill.fillRect(this.enemyHealthBarX, this.enemyHealthBarY, this.enemyHealthBarWidth * healthPercent, this.enemyHealthBarHeight);

      this.enemyNameText.setText(this.enemy.enemyType);
      this.enemyNameText.setPosition(this.enemyHealthBarX + this.enemyHealthBarWidth / 2, this.enemyHealthBarY - 15);
    } else {
      this.enemyHealthBarBg.clear();
      this.enemyHealthBarFill.clear();
      this.enemyNameText.setVisible(false);
    }
  }

  setEnemy(enemy) {
    this.enemy = enemy;
  }

  updateXpBar() {
    this.xpBarBg.clear();
    this.xpBarFill.clear();

    this.xpBarBg.fillStyle(0x000000, 0.6);
    this.xpBarBg.fillRect(this.xpBarX, this.xpBarY, this.xpBarWidth, this.xpBarHeight);

    const xpPercent = Phaser.Math.Clamp(playerStats.xp / playerStats.xpToNextLevel, 0, 1);
    this.xpBarFill.fillStyle(0x00FF00, 1);
    this.xpBarFill.fillRect(this.xpBarX, this.xpBarY, this.xpBarWidth * xpPercent, this.xpBarHeight);

    this.xpText.setText(`LV ${playerStats.level} XP: ${playerStats.xp}/${playerStats.xpToNextLevel}`);
  }

  updateHealthBar() {
    this.playerHealthBarBg.clear();
    this.playerHealthBarFill.clear();

    this.playerHealthBarBg.fillStyle(0x000000, 0.6);
    this.playerHealthBarBg.fillRect(this.playerHealthBarX, this.playerHealthBarY, this.playerHealthBarWidth, this.playerHealthBarHeight);

    const healthPercent = Phaser.Math.Clamp(playerStats.life / playerStats.maxLife, 0, 1);
    this.playerHealthBarFill.fillStyle(0x8A2BE2, 1);
    this.playerHealthBarFill.fillRect(this.playerHealthBarX, this.playerHealthBarY, this.playerHealthBarWidth * healthPercent, this.playerHealthBarHeight);
  }

  updatePlayerStatsPanel() {
    this.playerStatsPanelBg.clear();
    this.playerStatsPanelBg.fillStyle(0x111111, 0.5);
    this.playerStatsPanelBg.fillRect(10, 90, 200, 120); // Posição e tamanho do painel

    const fireRateMs = playerStats.fireRate / 1000;
    const statsText = `
      Classe: ${playerStats.playerClass ? playerClasses[playerStats.playerClass].name : 'Nenhuma'}
      Vida: ${playerStats.life.toFixed(1)} / ${playerStats.maxLife}
      Dano: ${playerStats.bulletDamage.toFixed(1)}
      Cadência: ${fireRateMs.toFixed(2)}s
      Velocidade: ${playerStats.playerSpeed}
    `;
    this.playerStatsText.setText(statsText);
    this.playerStatsText.setPosition(20, 100);
  }
}

</script>

</body>
</html>

<!DOCTYPE html> 
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the automatons V.1.2.1</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #0a0000ce }
    canvas { display: block; margin: auto; }
  </style>
</head>
<body>
  
<script>
const config = {
  type: Phaser.AUTO,
  width: 1300,
  height: 590,
  backgroundimage: 'fundogame.png',
  physics: {
    default: 'arcade',
    arcade: { debug: false }
  },
  scene: {
    preload,
    create,
    update
  }
};
let waveText;
let hudGroup;
let armaNomeText;
let armaImagem;
let player, cursors;
let bullets, enemies, enemyBullets;
let lastShoot = 0;
let showingCards = false;
let wave = 1;
let cardsGroup;
let playerSpeed = 200;
let spiritAlly = null;

let playerStats = {
  life: 3,
  bulletDamage: 1,
  fireRate: 1000,
  hasShield: false,
  spiritAllyActive: false,
  spreadUpgrade: false,
  doubleBullets: false,
  dashAvailable: false
};

const game = new Phaser.Game(config);

function preload() {
  this.load.image('player', 'assets/player.png');
  this.load.image('enemy', 'assets/enemy.png');
  this.load.image('bullet', 'assets/bullet.png');
  this.load.image('arma1', 'assets/pistola.png');
  this.load.image('arma2', 'assets/metralha.png');
  this.load.image('arma3', 'assets/lancarrio.png');
  this.load.image('fundogame', 'assets/fundogame.png');
}

function create() {
  waveText = this.add.text(config.width - 20, 20, `Fase ${wave}`, {
    fontFamily: 'cinzel',
    fontSize: '24px',
    color: '#FFFFFF',
    stroke: '#000000',
    strokeThickness: 4
  }).setOrigin(1, 0);

  this.add.image(config.width / 2, config.height / 2, 'fundogame').setDepth(-1);

  player = this.physics.add.sprite(400, 300, 'player')
    .setCollideWorldBounds(true)
    .setScale(0.05);

  bullets = this.physics.add.group();
  enemies = this.physics.add.group();
  enemyBullets = this.physics.add.group();
  armas = this.physics.add.group();  // Grupo das armas, mano!
  
  cursors = this.input.keyboard.createCursorKeys();

  // Spawn das armas no mapa
  spawnArmas.call(this);

  // Colis√£o pra pegar arma, atualiza stats e HUD
  this.physics.add.overlap(player, armas, (player, arma) => {
    pegarArma.call(this, arma);
  });

  this.input.keyboard.on('keydown-Z', () => {
    if (playerStats.dashAvailable && !playerStats.dashCooldown) {
      dashPlayer.call(this);
    }
  });

  // Restart com Espa√ßo
  this.input.keyboard.on('keydown-SPACE', () => {
    if (!player.active) {
      this.cameras.main.fadeOut(500, 0, 0, 0);
      this.time.delayedCall(500, () => {
        this.scene.restart();
      });
    }
  });

  spawnWave.call(this);

  this.physics.add.overlap(bullets, enemies, (b, e) => {
    if (b.active && e.active) {
      b.destroy();
      e.health = (e.health || 1) - playerStats.bulletDamage;
      if (e.health <= 0) e.destroy();
    }
  });

  this.physics.add.overlap(enemyBullets, player, (b, p) => {
    if (b.active && p.active) {
      b.destroy();
      if (!playerStats.hasShield) {
        p.setTint(0xff0000);
        this.time.delayedCall(100, () => p.clearTint());
      } else {
        playerStats.hasShield = false;
        this.cameras.main.setZoom(1);
        p.clearTint();
      }
    }
  });

  hudGroup = this.add.group();

  // Texto do nome da arma (com borda e glitch RGB estilo cyberpunk)
  armaNomeText = this.add.text(config.width / 2, 20, 'pistolinha', {
    fontFamily: 'Arial Black',
    fontSize: '28px',
    color: '#FFD700',
    stroke: '#000000',
    strokeThickness: 4,
    shadow: { offsetX: 2, offsetY: 2, color: '#000', blur: 4, stroke: true, fill: true }
  }).setOrigin(0.5, 0);

  // Caixa transl√∫cida atr√°s do texto da arma (glitch RGB)
  const box = this.add.rectangle(config.width / 2, 40, 300, 70, 0x111111, 0.3).setOrigin(0.5, 0);
  box.setStrokeStyle(2, 0x00ffff, 0.7);
  hudGroup.add(box);

  // Imagem da arma logo abaixo do texto, centralizada
  armaImagem = this.add.image(config.width / 2, 70, 'arma3').setScale(0.3);

  hudGroup.addMultiple([armaNomeText, armaImagem]);

  this.time.addEvent({
    delay: 9000,
    loop: true,
    callback: () => {
      enemies.getChildren().forEach(enemy => {
        if (!enemy.active) return;
        const bullet = enemyBullets.create(enemy.x, enemy.y, 'bullet').setScale(0.01);
        const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
        this.physics.velocityFromRotation(angle, 150, bullet.body.velocity);
      });
    }
  });
}
function spawnArmas() {
  const tipos = Object.keys(tiposDeArmas);

  for (let i = 0; i < 3; i++) {
    const tipo = Phaser.Utils.Array.GetRandom(tipos);
    const x = Phaser.Math.Between(100, 1200);
    const y = Phaser.Math.Between(100, 500);
    const arma = armas.create(x, y, tipo).setScale(0.2);
    arma.tipo = tipo;
  }
}

function pegarArma(arma) {
  const props = tiposDeArmas[arma.tipo];

  playerStats.bulletDamage = props.dano;
  playerStats.fireRate = props.fireRate;

  arma.destroy();

  // Atualiza a HUD com nome e imagem da arma
  const nomeArmasMap = {
    arma1: 'Pistolinha',
    arma2: 'F√∫ria de Eryon',
    arma3: 'Lan√ßa-Raio'
  };

  atualizarHUDarma(nomeArmasMap[arma.tipo], arma.tipo);

  // Feedback visual style favela-glitch
  this.add.text(player.x, player.y - 30, `Pegou ${nomeArmasMap[arma.tipo]}!`, {
    fontSize: '18px',
    color: '#FFD700',
    fontStyle: 'bold',
    stroke: '#000',
    strokeThickness: 3
  }).setOrigin(0.5).setDepth(99).setScrollFactor(0).setAlpha(0.9).setDepth(99)
  .setInteractive()
  .on('pointerdown', txt => txt.destroy())
  .setDuration?.(2000); // Se quiser, some depois de um tempo (pode precisar de tween)
}

function atualizarHUDarma(nomeArma, keyImagem) {
  armaNomeText.setText(nomeArma);
  armaImagem.setTexture(keyImagem);
}


function update(time) {
  if (!player.active) return;

  let vx = 0, vy = 0;
  if (cursors.left.isDown) vx = -1;
  else if (cursors.right.isDown) vx = 1;

  if (cursors.up.isDown) vy = -1;
  else if (cursors.down.isDown) vy = 1;

  const norm = Math.hypot(vx, vy) || 1;
  player.setVelocity((vx / norm) * playerSpeed, (vy / norm) * playerSpeed);

  if (time > lastShoot + playerStats.fireRate) {
    shootRadial.call(this);
    lastShoot = time;
  }

  enemies.getChildren().forEach(enemy => {
    if (!enemy.active) return;
    const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
    this.physics.velocityFromRotation(angle, 100, enemy.body.velocity);
  });

  if (enemies.countActive() === 0 && !showingCards) {
    showingCards = true;
    showCardChoices.call(this);
  }
}

function shootRadial() {
  const count = playerStats.spreadUpgrade ? 24 : 12;
  const speed = 700;

  for (let i = 0; i < count; i++) {
    const angle = Phaser.Math.DegToRad((360 / count) * i);
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;

    if (!player.active) return;

    const bullet1 = bullets.create(player.x, player.y, 'bullet').setScale(0.02);
    bullet1.body.velocity.set(vx, vy);

    if (playerStats.doubleBullets) {
      const offset = 10;
      const bullet2 = bullets.create(player.x + offset, player.y + offset, 'bullet').setScale(0.03);
      bullet2.body.velocity.set(vx, vy);
    }
  }
}

function spawnWave() {
  const count = 5 + wave * 2;
  for (let i = 0; i < count; i++) {
    const x = Phaser.Math.Between(100, 1200);
    const y = Phaser.Math.Between(50, 540);
    const enemy = this.physics.add.sprite(x, y, 'enemy').setScale(0.05);
    enemy.health = 3 + wave;
    enemies.add(enemy);
  }
}

function showCardChoices() {
  const choices = [
    { title: "‚ö° Bala Braba", desc: "Dano +50%, cad√™ncia -50%", color: 0xff5e5b, effect: () => {
      playerStats.bulletDamage *= 1.5;
      playerStats.fireRate *= 1.5;
    }},
    { title: "üõ°Ô∏è Escudo de prata", desc: "Ganha escudo que absorve um tiro", color: 0x00bbf9, effect: () => {
      playerStats.hasShield = true;
      this.cameras.main.setZoom(0.7);
    }},
    { title: "üëª Esp√≠rito Pit", desc: "Aliado que destr√≥i inimigos por 10s", color: 0x9b5de5, effect: () => {
      if (!playerStats.spiritAllyActive) {
        summonSpiritAlly.call(this);
        playerStats.spiritAllyActive = true;
      }
    }},
    { title: "üéØ Tiros Duplos", desc: "Cada disparo gera 2 balas paralelas", color: 0xf15bb5, effect: () => {
      playerStats.doubleBullets = true;
    }},
    { title: "üå™Ô∏è Dispers√£o", desc: "Aumenta tiros para 24 balas por disparo", color: 0x00f5d4, effect: () => {
      playerStats.spreadUpgrade = true;
    }},
    { title: "‚ö° Dash R√°pido", desc: "Ative dash com tecla Z, cooldown 3s", color: 0xffc300, effect: () => {
      playerStats.dashAvailable = true;
    }}
  ];

  const shuffled = Phaser.Utils.Array.Shuffle(choices);
  const deck = shuffled.slice(0, 3);

  cardsGroup = this.add.group();
  const overlay = this.add.rectangle(650, 295, 1300, 590, 0x000000, 0.7).setDepth(10);

  deck.forEach((choice, i) => {
    const x = 350 + i * 300;

    const card = this.add.rectangle(x, 250, 180, 220, choice.color)
      .setStrokeStyle(3, 0xffffff)
      .setDepth(11)
      .setInteractive()
      .setAlpha(0);

    this.tweens.add({
      targets: card,
      alpha: 1,
      scale: { from: 1, to: 1.05 },
      yoyo: true,
      repeat: -1,
      duration: 800,
      ease: 'Sine.easeInOut'
    });

    const title = this.add.text(x, 190, choice.title, {
      fontSize: '22px',
      color: '#000',
      fontFamily: 'Arial Black'
    }).setOrigin(0.5).setDepth(11);

    const desc = this.add.text(x, 250, choice.desc, {
      fontSize: '16px',
      color: '#111',
      wordWrap: { width: 160 }
    }).setOrigin(0.5).setDepth(11);

    card.on('pointerover', () => card.setStrokeStyle(4, 0xffff00));
    card.on('pointerout', () => card.setStrokeStyle(3, 0xffffff));
    card.on('pointerdown', () => {
      cardsGroup.clear(true, true);
      overlay.destroy();
      choice.effect.call(this);
      showingCards = false;
      wave++;
      spawnWave.call(this);
    });

    cardsGroup.addMultiple([card, title, desc]);
  });
}

function summonSpiritAlly() {
  if (spiritAlly && spiritAlly.active) return;

  spiritAlly = this.physics.add.sprite(player.x + 40, player.y, 'player').setTint(0x00ffff).setScale(0.15);
  spiritAlly.setDepth(5);

  this.time.addEvent({
    delay: 100,
    loop: true,
    callback: () => {
      if (!spiritAlly.active) return;
      const closestEnemy = enemies.getChildren()
        .filter(e => e.active)
        .sort((a, b) => Phaser.Math.Distance.Between(spiritAlly.x, spiritAlly.y, a.x, a.y) - Phaser.Math.Distance.Between(spiritAlly.x, spiritAlly.y, b.x, b.y))[0];

      if (closestEnemy) {
        this.physics.moveToObject(spiritAlly, closestEnemy, 300);
      }
    }
  });

  this.physics.add.overlap(spiritAlly, enemies, (s, e) => {
    if (e.active && s.active) e.destroy();
  });

  this.time.delayedCall(10000, () => {
    if (spiritAlly) spiritAlly.destroy();
    playerStats.spiritAllyActive = false;
  });
}

function dashPlayer() {
  if (playerStats.dashCooldown) return;

  const dashDistance = 150;
  let vx = 0, vy = 0;

  if (cursors.left.isDown) vx = -dashDistance;
  else if (cursors.right.isDown) vx = dashDistance;
  if (cursors.up.isDown) vy = -dashDistance;
  else if (cursors.down.isDown) vy = dashDistance;

  if (vx === 0 && vy === 0) return;

  player.setVelocity(vx * 5, vy * 5);
  this.time.delayedCall(100, () => player.setVelocity(0));
  playerStats.dashCooldown = true;

  this.time.delayedCall(3000, () => {
    playerStats.dashCooldown = false;
  });
}
const tiposDeArmas = {
  arma1: { dano: 1, fireRate: 1000 }, // Pistola r√°pida
  arma2: { dano: 2, fireRate: 900 }, // Metralhadora m√©dia
  arma3: { dano: 3, fireRate: 2000 } // Lan√ßa-raio brabo
};
function spawnArmas() {
  const tipos = Object.keys(tiposDeArmas);

  for (let i = 0; i < 3; i++) {
    const tipo = Phaser.Utils.Array.GetRandom(tipos);
    const x = Phaser.Math.Between(100, 1200);
    const y = Phaser.Math.Between(100, 500);
    const arma = armas.create(x, y, tipo).setScale(0.2);
    arma.tipo = tipo;
  }
}
function pegarArma(arma) {
  const props = tiposDeArmas[arma.tipo];

  playerStats.bulletDamage = props.dano;
  playerStats.fireRate = props.fireRate;

  arma.destroy();

  // Feedback visual se quiser
  this.add.text(player.x, player.y - 30, `Pegou ${arma.tipo.toUpperCase()}!`, {
    fontSize: '18px',
    color: '#FFD700',
    fontStyle: 'bold'
  }).setOrigin(0.5).setDepth(99).setScrollFactor(0);
}
function atualizarHUDarma(nomeArma, keyImagem) {
  armaNomeText.setText(nomeArma);
  armaImagem.setTexture(keyImagem);
}
function pegarArma(arma) {
  const props = tiposDeArmas[arma.tipo];

  playerStats.bulletDamage = props.dano;
  playerStats.fireRate = props.fireRate;

  arma.destroy();

  // Atualiza a HUD com o nome e imagem da arma atual
  const nomeArmasMap = {
    arma1: 'Pistolinha',
    arma2: 'F√∫ria de eryon',
    arma3: 'Lan√ßa-Raio '
  };

  atualizarHUDarma(nomeArmasMap[arma.tipo], arma.tipo);

  // Feedback visual se quiser
  this.add.text(player.x, player.y - 30, `Pegou ${nomeArmasMap[arma.tipo]}!`, {
    fontSize: '18px',
    color: '#FFD700',
    fontStyle: 'bold'
  }).setOrigin(0.5).setDepth(99).setScrollFactor(0);
}
//reinciar
this.input.keyboard.on('keydown-SPACE', () => {
  if (!player.active) {
    this.cameras.main.fadeOut(500, 0, 0, 0);
    this.time.delayedCall(500, () => {
      this.scene.restart();
    });
  }
});
//texto para weve onda ou fase do jogo
card.on('pointerdown', () => {
  cardsGroup.clear(true, true);
  overlay.destroy();
  choice.effect.call(this);
  showingCards = false;
  wave++;
  waveText.setText(`Fase ${wave}`);
  spawnWave.call(this);
});

</script>
</body>
</html>

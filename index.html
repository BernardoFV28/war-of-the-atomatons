<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons - Skill Tree Edition (CORRIGIDO)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000008c7; font-family: 'Arial', sans-serif; }
    canvas { display: block; margin: auto; }
    
    /* Estilos de UI e Menus */
    .menu-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: flex; justify-content: center; align-items: center; z-index: 1000; color: #FFF; }
    .menu-container { background-color: #222; border: 2px solid #555; padding: 20px; border-radius: 12px; text-align: center; width: 90%; max-width: 900px; box-shadow: 0 0 25px #00FFFF; }
    .menu-title { font-size: 40px; margin-bottom: 20px; color: #00FFFF; text-transform: uppercase; }
    
    /* Botões */
    .btn { background-color: #008CBA; color: white; padding: 12px 25px; border: none; border-radius: 6px; cursor: pointer; font-size: 18px; font-weight: bold; margin: 10px; transition: background-color 0.2s, transform 0.1s; }
    .btn:hover { background-color: #005f7f; transform: scale(1.05); }
    .btn-disabled { background-color: #555; cursor: not-allowed; }

    /* Skill Tree */
    .skill-tree { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-top: 20px; }
    .skill-card { background-color: #1a1a1a; border: 1px solid #444; border-radius: 8px; padding: 15px; text-align: center; }
    .skill-title { font-size: 18px; color: #FFD700; margin-bottom: 5px; }
    .skill-level { font-size: 14px; color: #aaa; margin-bottom: 10px; }
    .skill-cost { font-size: 16px; color: #FFF; font-weight: bold; }
  </style>
</head>
<body>
<script>

// ==================================================================================================
// --- 1. CONFIGURAÇÕES E DADOS GLOBAIS ---
// ==================================================================================================

const ORIGINAL_SCALES = {
    PLAYER: 0.08,
    BULLET: 0.01,
    GEM: 0.04
};

const GAME_CONFIG = {
    PLAYER: {
        SPEED: 300,
        MAX_HP: 3,
        MAGNET: 150,
        DASH: { DIST: 300, CD: 3000 }
    },
    LIMITS: {
        MAX_ENEMIES_ON_SCREEN: 50, 
        MAX_GEMS: 60
    },
    WAVE: {
        START_COUNT: 15,
        INC_PER_WAVE: 5,
        SPAWN_DELAY: 1000
    }
};

const enemyTypes = {
  normal: { texture: 'enemy_robot', baseHealth: 4, speed: 100, scale: 0.06, xpValue: 5, chance: 1.0 },
  fast: { texture: 'enemy_fast', baseHealth: 3, speed: 200, scale: 0.06, xpValue: 8, minWave: 3, chance: 0.3 },
  tank: { texture: 'enemy_tank', baseHealth: 15, speed: 50, scale: 0.08, xpValue: 15, minWave: 5, chance: 0.2 }
};

const SKILL_TREE = {
    DanoBase: {
        name: "Dano Base",
        desc: (level) => `Aumenta o dano inicial em ${level * 10}% (Atual: ${(level + 1) * 10}%).`,
        maxLevel: 5,
        cost: (level) => 100 + level * 75,
        effectKey: 'damageMult',
        defaultStat: 1,
        applier: (stat, level) => stat + (level * 0.1),
        dependsOn: null,
    },
    TaxaDeTiro: {
        name: "Taxa de Tiro",
        desc: (level) => `Reduz o tempo entre tiros em ${level * 5}ms (Atual: ${level * 5}ms).`,
        maxLevel: 4,
        cost: (level) => 150 + level * 100,
        effectKey: 'fireRateReduction',
        defaultStat: 0,
        applier: (stat, level) => stat + (level * 5),
        dependsOn: 'DanoBase',
    },
    VidaMaxima: {
        name: "Vida Máxima",
        desc: (level) => `Aumenta a vida máxima inicial em ${level} ponto(s).`,
        maxLevel: 3,
        cost: (level) => 150 + level * 100,
        effectKey: 'maxHpBonus',
        defaultStat: 0,
        applier: (stat, level) => stat + level,
        dependsOn: null,
    },
    VelocidadeMovimento: {
        name: "Velocidade de Movimento",
        desc: (level) => `Aumenta a velocidade inicial em ${level * 10}pts.`,
        maxLevel: 5,
        cost: (level) => 75 + level * 50,
        effectKey: 'speedBonus',
        defaultStat: 0,
        applier: (stat, level) => stat + (level * 10),
        dependsOn: 'VidaMaxima',
    },
    RaioIma: {
        name: "Raio do Imã",
        desc: (level) => `Aumenta o raio de coleta de XP em ${level * 10}pts.`,
        maxLevel: 5,
        cost: (level) => 75 + level * 50,
        effectKey: 'magnetBonus',
        defaultStat: 0,
        applier: (stat, level) => stat + (level * 10),
        dependsOn: null,
    },
};

// Globais
let player, cursors, bullets, enemies, xpGems, hud;
let isPaused = true; 
let currentScene; 

let playerStats = { 
    hp: 3, maxHp: 3, damage: 2, fireRate: 800, speed: GAME_CONFIG.PLAYER.SPEED, 
    xp: 0, level: 1, xpToNext: 50, currency: 0, magnet: GAME_CONFIG.PLAYER.MAGNET,
    piercing: 1, doubleShot: false, dashUnlocked: false, dashCool: false,
    skillLevels: {
        DanoBase: 0, TaxaDeTiro: 0, VidaMaxima: 0, VelocidadeMovimento: 0, RaioIma: 0
    },
    skillEffects: {} // Inicializado em applySkillTreeEffects
};

let gameState = {
    wave: 1,
    enemiesToSpawn: 0, 
    enemiesAlive: 0    
};

let lastShot = 0;


// ==================================================================================================
// --- 2. CLASSE DA CENA PRINCIPAL ---
// ==================================================================================================

class MainScene extends Phaser.Scene {
    constructor() { super({ key: 'MainScene' }); }

    preload() {
        // Assets originais (mantidos)
        this.load.image('player', 'assets/player.png');
        this.load.image('bullet', 'assets/bullet.png');
        this.load.image('enemy_robot', 'assets/enemy_robot.png');
        this.load.image('enemy_fast', 'assets/enemy_fast.png');
        this.load.image('enemy_tank', 'assets/enemy_tank.png');
        this.load.image('boss_robot', 'assets/boss_robot.png');
        this.load.image('gem', 'assets/ammo.png'); 
        this.load.image('bg', 'https://labs.phaser.io/assets/skies/deep-space.jpg');

        this.load.on('fileload', (file) => {
            // Lógica de Fallbacks (mantida)
        });
    }

    create() {
        currentScene = this; 

        loadProgress(); // 1. Carrega o progresso (inclui skills)
        applySkillTreeEffects(); // 2. Aplica os bônus da Skill Tree (altera playerStats iniciais)
        
        // --- SETUP DO JOGO ---
        this.add.tileSprite(0, 0, this.scale.width, this.scale.height, 'bg').setOrigin(0).setScrollFactor(0).setAlpha(0.5);

        player = this.physics.add.sprite(this.scale.width/2, this.scale.height/2, 'player').setScale(ORIGINAL_SCALES.PLAYER);
        player.setCollideWorldBounds(true);
        
        bullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 50 });
        enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true, maxSize: GAME_CONFIG.LIMITS.MAX_ENEMIES_ON_SCREEN });
        xpGems = this.physics.add.group({ classType: Gem, runChildUpdate: true, maxSize: GAME_CONFIG.LIMITS.MAX_GEMS });

        this.physics.add.overlap(bullets, enemies, this.hitEnemy, null, this);
        this.physics.add.collider(player, enemies, this.hitPlayer, null, this);
        this.physics.add.overlap(player, xpGems, this.collectGem, null, this);

        cursors = this.input.keyboard.createCursorKeys();
        this.input.keyboard.on('keydown-SPACE', () => this.dash());

        hud = new HUD(this);
        
        this.startWave(1);

        this.time.addEvent({ delay: GAME_CONFIG.WAVE.SPAWN_DELAY, callback: this.trySpawnEnemy, callbackScope: this, loop: true });

        // --- CORREÇÃO DE INICIALIZAÇÃO ---
        isPaused = true; // Mantém em pausa
        this.physics.pause(); // Pausa o motor de física
        showStartMenu(this); // Mostra o menu para o jogador começar
    }

    update(time, delta) {
        if (isPaused) return;
        // Lógica de movimento e tiro (inalterada)
        player.setVelocity(0);
        const spd = playerStats.speed;
        if (cursors.left.isDown) player.setVelocityX(-spd);
        else if (cursors.right.isDown) player.setVelocityX(spd);
        if (cursors.up.isDown) player.setVelocityY(-spd);
        else if (cursors.down.isDown) player.setVelocityY(spd);

        if (time > lastShot) {
            let closest = null;
            let minDist = 450;
            enemies.children.each(e => {
                if (e.active) {
                    const d = Phaser.Math.Distance.Between(player.x, player.y, e.x, e.y);
                    if (d < minDist) { minDist = d; closest = e; }
                }
            });

            if (closest) {
                this.shoot(closest);
                lastShot = time + playerStats.fireRate;
            }
        }
    }

    // --- MÉTODOS DA CENA (MANTIDOS) ---
    shoot(target) { /* ... */ }
    hitEnemy(bullet, enemy) {
        if (!bullet.active || !enemy.active) return;
        enemy.hp -= bullet.damage;
        enemy.setTint(0xff0000);
        this.time.delayedCall(50, () => { if(enemy.active) enemy.clearTint(); });

        bullet.pierce--;
        if (bullet.pierce <= 0) bullet.kill();

        if (enemy.hp <= 0) {
            playerStats.currency += 1;
            this.dropGem(enemy.x, enemy.y, enemy.xpValue);
            enemy.kill();
            this.checkWaveEnd();
            hud.updateStats();
        }
    }
    startWave(waveNum) { /* ... */ }
    trySpawnEnemy() { /* ... */ }
    spawnOneEnemy() { /* ... */ }
    checkWaveEnd() {
        if (gameState.enemiesToSpawn <= 0 && enemies.countActive() === 0) {
            hud.showMsg("ONDA CONCLUÍDA! Preparando próxima...", "#00FF00");
            this.time.delayedCall(2000, () => {
                this.startWave(gameState.wave + 1);
            });
        }
    }
    dropGem(x, y, val) { /* ... */ }
    collectGem(player, gem) { /* ... */ }
    hitPlayer(player, enemy) { /* ... */ }
    dash() { /* ... */ }
}


// ==================================================================================================
// --- 3. CLASES AUXILIARES (CLASSES MANTIDAS) ---
// ==================================================================================================

class Bullet extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { super(scene, x, y, 'bullet'); }
    fire(x, y, angle) {
        this.body.reset(x, y);
        this.setActive(true).setVisible(true).setScale(ORIGINAL_SCALES.BULLET).setRotation(angle);
        // Usa o bônus de dano da Skill Tree
        this.damage = playerStats.damage * (1 + playerStats.skillEffects.damageMult); 
        this.pierce = playerStats.piercing;
        this.lifespan = 1000;
    }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) { super.preUpdate(time, delta); if (this.lifespan <= 0) this.kill(); this.lifespan -= delta; }
}

class Enemy extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { super(scene, x, y, 'enemy_robot'); }
    spawn(x, y, typeData, waveDifficulty) {
        this.body.reset(x, y);
        this.setActive(true).setVisible(true).setTexture(typeData.texture).setScale(typeData.scale);
        this.hp = typeData.baseHealth * (1 + (waveDifficulty * 0.1));
        this.xpValue = typeData.xpValue;
        this.speed = typeData.speed;
        this.setTint(0xffffff);
    }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.active) this.scene.physics.moveToObject(this, player, this.speed);
    }
}

class Gem extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { super(scene, x, y, 'gem'); }
    spawn(x, y, val) {
        this.body.reset(x, y);
        this.setActive(true).setVisible(true).setScale(ORIGINAL_SCALES.GEM).setTint(0x00ff00);
        this.val = val;
        this.collected = false;
    }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if (this.active) {
            const dist = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y);
            // playerStats.magnet é modificado pela Skill Tree
            if (dist < playerStats.magnet) this.scene.physics.moveToObject(this, player, 400);
        }
    }
}

class HUD {
    constructor(scene) {
        this.scene = scene;
        this.statsText = scene.add.text(20, 20, "", { fontSize: '18px', color: '#fff', stroke: '#000', strokeThickness: 2 }).setScrollFactor(0).setDepth(100);
        this.waveInfo = scene.add.text(scene.scale.width/2, 30, "", { fontSize: '24px', fontStyle:'bold', color:'#FFD700', stroke: '#000', strokeThickness: 3 }).setOrigin(0.5).setScrollFactor(0).setDepth(100);
        this.msgText = scene.add.text(scene.scale.width/2, scene.scale.height/2 - 100, "", { fontSize: '40px', fontStyle:'bold', stroke:'#000', strokeThickness:6 }).setOrigin(0.5).setScrollFactor(0).setDepth(200).setAlpha(0);
        this.updateStats();
    }
    updateStats() {
        const remaining = gameState.enemiesToSpawn + enemies.countActive();
        this.waveInfo.setText(`ONDA ${gameState.wave} - RESTAM: ${remaining}`);
        this.statsText.setText(`HP: ${playerStats.hp}/${playerStats.maxHp}\nLVL: ${playerStats.level}\nXP: ${playerStats.xp}/${playerStats.xpToNext}\n$: ${playerStats.currency}`);
    }
    showMsg(text, color, duration = 2000) {
        this.msgText.setText(text).setColor(color).setAlpha(1);
        this.scene.tweens.add({ targets: this.msgText, alpha: 0, duration: duration, ease: 'Power2' });
    }
}


// ==================================================================================================
// --- 4. FUNÇÕES DE PERSISTÊNCIA E APLICAÇÃO DE SKILLS (MANTIDAS) ---
// ==================================================================================================

function saveProgress() {
    const data = { 
        totalCurrency: playerStats.currency,
        skillLevels: playerStats.skillLevels
    };
    localStorage.setItem('WarAutomatonsSave', JSON.stringify(data));
}

function loadProgress() {
    playerStats.hp = GAME_CONFIG.PLAYER.MAX_HP;
    playerStats.maxHp = GAME_CONFIG.PLAYER.MAX_HP;
    playerStats.speed = GAME_CONFIG.PLAYER.SPEED;
    playerStats.magnet = GAME_CONFIG.PLAYER.MAGNET;
    playerStats.fireRate = 800; 

    const data = localStorage.getItem('WarAutomatonsSave');
    if (data) {
        const parsed = JSON.parse(data);
        playerStats.currency = parsed.totalCurrency || 0;
        if (parsed.skillLevels) {
            Object.keys(playerStats.skillLevels).forEach(skill => {
                playerStats.skillLevels[skill] = parsed.skillLevels[skill] || 0;
            });
        }
    }
}

function applySkillTreeEffects() {
    playerStats.skillEffects = {
        damageMult: 0, 
        maxHpBonus: 0,
        speedBonus: 0,
        magnetBonus: 0,
        fireRateReduction: 0 
    };

    Object.keys(SKILL_TREE).forEach(skillKey => {
        const skill = SKILL_TREE[skillKey];
        const level = playerStats.skillLevels[skillKey];
        
        if (level > 0 && skill.applier) {
            playerStats.skillEffects[skill.effectKey] = skill.applier(playerStats.skillEffects[skill.effectKey], level);
        }
    });

    playerStats.maxHp += playerStats.skillEffects.maxHpBonus;
    playerStats.hp = playerStats.maxHp;
    playerStats.speed += playerStats.skillEffects.speedBonus;
    playerStats.magnet += playerStats.skillEffects.magnetBonus;
    playerStats.fireRate -= playerStats.skillEffects.fireRateReduction;
}


// ==================================================================================================
// --- 5. FUNÇÕES DE UI (MENUS CORRIGIDOS) ---
// ==================================================================================================

function showStartMenu(scene) {
    const overlay = document.createElement('div');
    overlay.className = 'menu-overlay';
    
    const box = document.createElement('div');
    box.className = 'menu-container';
    box.style.maxWidth = '500px';

    box.innerHTML = `<h2 class="menu-title">WAR OF THE AUTOMATONS</h2>
        <p style="font-size: 20px; color: #aaa;">Sucata: <span id="currency-display" style="color: #FFD700; font-weight: bold;">${playerStats.currency}</span></p>
        <button id="start-btn" class="btn">COMEÇAR JOGO</button>
        <button id="skill-tree-btn" class="btn">ÁRVORE DE HABILIDADES</button>
    `;

    // CORREÇÃO: Apenas remove o menu e retoma o jogo que já está carregado
    box.querySelector('#start-btn').onclick = () => {
        overlay.remove();
        scene.physics.resume();
        isPaused = false;
    };

    box.querySelector('#skill-tree-btn').onclick = () => {
        showSkillTreeMenu(scene, overlay);
    };

    overlay.appendChild(box);
    document.body.appendChild(overlay);
}

function showSkillTreeMenu(scene, previousOverlay) {
    if (previousOverlay) previousOverlay.remove();
    
    // ... (Lógica da Skill Tree mantida) ...
    const overlay = document.createElement('div');
    overlay.className = 'menu-overlay';
    
    const box = document.createElement('div');
    box.className = 'menu-container';
    box.innerHTML = `<h2 class="menu-title">ÁRVORE DE HABILIDADES</h2>
        <p style="font-size: 20px; color: #aaa;">Sucata Disponível: <span id="currency-display" style="color: #FFD700; font-weight: bold;">${playerStats.currency}</span></p>
        <div class="skill-tree" id="skill-tree-container"></div>
        <button id="back-btn" class="btn" style="margin-top: 20px;">VOLTAR</button>
    `;

    box.querySelector('#back-btn').onclick = () => {
        overlay.remove();
        showStartMenu(scene);
    };

    const container = box.querySelector('#skill-tree-container');

    const renderSkills = () => {
        container.innerHTML = '';
        const currencyDisplay = box.querySelector('#currency-display');
        currencyDisplay.textContent = playerStats.currency;

        Object.keys(SKILL_TREE).forEach(skillKey => {
            const skill = SKILL_TREE[skillKey];
            const currentLevel = playerStats.skillLevels[skillKey];
            const cost = skill.cost(currentLevel);
            const maxed = currentLevel >= skill.maxLevel;
            const dependencyMet = !skill.dependsOn || playerStats.skillLevels[skill.dependsOn] > 0;
            const canUpgrade = !maxed && playerStats.currency >= cost && dependencyMet;

            const card = document.createElement('div');
            card.className = 'skill-card';
            card.innerHTML = `
                <div class="skill-title">${skill.name}</div>
                <div class="skill-level">Nível: ${currentLevel}/${skill.maxLevel}</div>
                <div class="skill-desc" style="font-size: 13px; color: ${maxed ? '#00FF00' : '#ccc'}; height: 30px;">
                    ${maxed ? 'MAXIMIZADO' : (dependencyMet ? skill.desc(currentLevel) : 'Requer '+SKILL_TREE[skill.dependsOn].name+' Nível 1')}
                </div>
                <div class="skill-cost">${maxed ? '---' : `Custo: ${cost} Sucata`}</div>
                <button class="btn btn-upgrade ${canUpgrade ? '' : 'btn-disabled'}" data-skill="${skillKey}" 
                    ${!canUpgrade ? 'disabled' : ''}>
                    ${maxed ? 'MAX' : (dependencyMet ? 'COMPRAR' : 'BLOQUEADO')}
                </button>
            `;
            
            card.querySelector('.btn-upgrade').onclick = () => {
                if (canUpgrade) {
                    playerStats.currency -= cost;
                    playerStats.skillLevels[skillKey]++;
                    saveProgress();
                    renderSkills();
                }
            };

            container.appendChild(card);
        });
    };

    renderSkills();
    overlay.appendChild(box);
    document.body.appendChild(overlay);
}

function showLevelUp(scene) {
    isPaused = true; scene.physics.pause();
    // ... (Lógica do menu de Level Up mantida, apenas mostrando a pausa/resumo) ...
    const overlay = document.createElement('div'); overlay.className = 'menu-overlay';
    const box = document.createElement('div'); box.className = 'menu-container';
    box.innerHTML = '<h2 class="menu-title">SUBIU DE NÍVEL!</h2><div class="cards-container" style="display: flex; justify-content: center; gap: 15px;"></div>';
    
    const upgrades = [
        { n: "Dano +20%", f: () => playerStats.damage *= 1.2 },
        { n: "Tiro Rápido +15%", f: () => playerStats.fireRate *= 0.85 },
        { n: "Velocidade +10%", f: () => playerStats.speed += 30 },
        { n: "Imã +50%", f: () => playerStats.magnet += 50 },
        { n: "Tiro Duplo", f: () => playerStats.doubleShot = true },
        { n: "Dash", f: () => playerStats.dashUnlocked = true },
        { n: "Cura Total", f: () => { playerStats.hp = playerStats.maxHp; hud.updateStats(); } }
    ];
    
    const container = box.querySelector('.cards-container');
    Phaser.Utils.Array.Shuffle(upgrades).slice(0, 3).forEach(up => {
        const card = document.createElement('div'); card.className = 'card';
        card.style.width = '200px'; card.style.backgroundColor = '#1a1a1a'; card.style.border = '1px solid #444';
        card.style.padding = '15px'; card.style.borderRadius = '6px';
        card.innerHTML = `<div class="card-title" style="color: #FFD700;">${up.n}</div><button class="btn card-button">ESCOLHER</button>`;
        card.onclick = () => {
            up.f();
            document.body.removeChild(overlay);
            isPaused = false; scene.physics.resume();
        };
        container.appendChild(card);
    });
    overlay.appendChild(box); document.body.appendChild(overlay);
}

// ==================================================================================================
// --- 6. INICIALIZAÇÃO DO JOGO ---
// ==================================================================================================

const game = new Phaser.Game({
    type: Phaser.AUTO, width: window.innerWidth, height: window.innerHeight,
    backgroundColor: '#000', parent: document.body,
    physics: { default: 'arcade', arcade: { debug: false } },
    scene: [MainScene]
});

window.addEventListener('resize', () => game.scale.resize(window.innerWidth, window.innerHeight));
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Biopunk: Evolution RPG</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', monospace; }
        
        /* UI ESTILIZADA BIOPUNK */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        .hud-box { 
            position: absolute; background: rgba(0, 20, 10, 0.85); 
            border: 1px solid #00ff66; padding: 10px; border-radius: 5px;
            color: #00ff66; font-weight: bold; text-shadow: 0 0 5px #00ff66;
            pointer-events: auto;
        }

        #xp-container { 
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            width: 400px; height: 25px; background: #111; border: 2px solid #333; border-radius: 15px; overflow: hidden;
        }
        #xp-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #00ff66, #ccff00); transition: width 0.2s; }
        
        /* ALERTAS DE BOSS */
        #boss-alert {
            position: absolute; top: 25%; width: 100%; text-align: center;
            font-size: 3rem; color: #ff003c; font-weight: 900; text-shadow: 0 0 20px #ff003c;
            display: none; text-transform: uppercase; animation: shake 0.5s infinite;
        }

        /* MENU LEVEL UP */
        .overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; }
        .hidden { display: none !important; }
        
        .card-container { display: flex; gap: 15px; }
        .card { 
            width: 220px; background: #1a1a1a; border: 2px solid #444; padding: 15px;
            border-radius: 8px; cursor: pointer; transition: 0.3s; text-align: center; color: #eee;
        }
        .card:hover { border-color: #00ff66; transform: scale(1.05); background: #222; }
        .card h3 { color: #00ff66; margin: 0 0 10px 0; }
        .card small { color: #888; display: block; margin-bottom: 5px; }

        @keyframes shake { 0% { transform: translate(1px, 1px); } 50% { transform: translate(-1px, -1px); } 100% { transform: translate(1px, 1px); } }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="hud-box" style="top: 10px; left: 10px;">
        LVL: <span id="hud-lvl">1</span> | HP: <span id="hud-hp">100</span>
    </div>
    <div class="hud-box" style="top: 10px; right: 10px;">
        TEMPO: <span id="hud-time">00:00</span> | MORTES: <span id="hud-kills">0</span>
    </div>
    <div id="xp-container"><div id="xp-bar"></div></div>
    <div id="boss-alert">ALERTA: BIO-TITÃ DETECTADO</div>
</div>

<div id="start-screen" class="overlay">
    <h1 style="color:#00ff66; font-size: 4rem; text-shadow: 0 0 30px #00ff66;">BIOPUNK SURVIVOR</h1>
    <p style="color:#ccc">Mova com WASD. Ataque Automático. Sobreviva à carne.</p>
    <button onclick="game.scene.start('MainScene'); document.getElementById('start-screen').classList.add('hidden');" style="padding: 15px 40px; font-size: 1.5rem; background: #00ff66; border: none; font-weight: bold; cursor: pointer;">INICIAR</button>
</div>

<div id="levelup-screen" class="overlay hidden">
    <h2 style="color:#00ff66">MUTAÇÃO DISPONÍVEL</h2>
    <div class="card-container" id="upgrade-list"></div>
</div>

<script>
// ================= CONFIGURAÇÃO DE ASSETS =================
// AQUI VOCÊ PODE SUBSTITUIR AS STRINGS PELAS URLs DAS SUAS IMAGENS ORIGINAIS
// Se deixar como 'null', o jogo vai gerar gráficos automaticamente.
const ASSETS_URL = {
    player: null,       // Ex: 'assets/player_ship.png'
    enemy_basic: null,  // Ex: 'assets/robot_enemy.png'
    enemy_fast: null,
    boss: null,         // Ex: 'assets/boss_big.png'
    bg: null            // Ex: 'assets/space_bg.png'
};

// ================= DADOS DO JOGO (RPG) =================
const STATE = {
    hp: 100, maxHp: 100,
    xp: 0, nextXp: 100, level: 1,
    kills: 0, time: 0,
    weapons: [], 
    passives: { might: 1, cooldown: 1, speed: 180, area: 1 },
    isPaused: false
};

const WEAPONS_DB = [
    { id: 'spike', name: 'Espinho Ósseo', desc: 'Dispara projétil perfurante no inimigo mais próximo.', type: 'projectile', dmg: 20, cd: 900, speed: 400, color: 0xffffff },
    { id: 'gas', name: 'Gás Neurotóxico', desc: 'Aura que danifica inimigos próximos constantemente.', type: 'aura', dmg: 5, cd: 200, area: 120, color: 0x00ff00 },
    { id: 'drone', name: 'Parasita Orbital', desc: 'Gira ao redor do hospedeiro causando dano de contato.', type: 'orbital', dmg: 15, cd: 0, speed: 2, count: 1, color: 0xff003c }
];

const BOSS_DB = [
    { name: "O Açougueiro", color: 0xff0000, scale: 3, hpMult: 100, ai: 'charger' },
    { name: "Mente Colmeia", color: 0xaa00ff, scale: 2.5, hpMult: 80, ai: 'shooter' },
    { name: "Bio-Titã", color: 0x444444, scale: 5, hpMult: 200, ai: 'tank' }
];

class MainScene extends Phaser.Scene {
    constructor() { super('MainScene'); }

    preload() {
        // Carrega assets do usuário SE existirem, senão cria gráficos
        if(ASSETS_URL.player) this.load.image('player', ASSETS_URL.player);
        if(ASSETS_URL.bg) this.load.image('bg', ASSETS_URL.bg);
        
        // Gerador de Gráficos Fallback (Caso não tenha imagem)
        const createGfx = (key, color, w, h, circle=false) => {
            if(this.textures.exists(key)) return;
            const g = this.make.graphics().fillStyle(color);
            if(circle) g.fillCircle(w/2, w/2, w/2);
            else g.fillRect(0,0,w,h);
            g.generateTexture(key, w, h);
        };

        createGfx('gfx_player', 0x00ff66, 32, 32);
        createGfx('gfx_enemy', 0xcc0000, 24, 24);
        createGfx('gfx_boss', 0xff003c, 64, 64);
        createGfx('gfx_xp', 0x00aaff, 10, 10, true);
        createGfx('gfx_proj', 0xffffff, 12, 12, true);
        createGfx('gfx_aura', 0x00ff00, 200, 200, true);
        createGfx('gfx_orb', 0xff003c, 16, 16, true);
    }

    create() {
        // Reset State
        STATE.hp = 100; STATE.level = 1; STATE.weapons = []; STATE.time = 0; STATE.kills = 0;

        // Mundo
        this.physics.world.setBounds(0, 0, 3000, 3000);
        this.add.grid(1500, 1500, 3000, 3000, 128, 128, 0x003311).setAlpha(0.3);
        
        // Player
        const pKey = ASSETS_URL.player ? 'player' : 'gfx_player';
        this.player = this.physics.add.sprite(1500, 1500, pKey);
        this.player.setCollideWorldBounds(true);
        
        this.cameras.main.startFollow(this.player, true);
        this.cameras.main.setZoom(1);

        // Grupos
        this.enemies = this.physics.add.group({ runChildUpdate: true });
        this.bullets = this.physics.add.group({ runChildUpdate: true });
        this.xpGems = this.physics.add.group();
        this.texts = this.add.group();

        // Colisões
        this.physics.add.overlap(this.bullets, this.enemies, this.hitEnemy, null, this);
        this.physics.add.overlap(this.player, this.enemies, this.hitPlayer, null, this);
        this.physics.add.overlap(this.player, this.xpGems, this.collectXp, null, this);

        // Inputs
        this.keys = this.input.keyboard.addKeys('W,A,S,D');

        // Timers
        this.time.addEvent({ delay: 1000, callback: this.tickSecond, callbackScope: this, loop: true });
        this.time.addEvent({ delay: 400, callback: this.spawnEnemy, callbackScope: this, loop: true });

        // Arma Inicial
        this.addWeapon('spike');
    }

    update(time, delta) {
        if(STATE.isPaused) return;

        // 1. Movimento Player
        this.player.setVelocity(0);
        const spd = STATE.passives.speed;
        if(this.keys.A.isDown) this.player.setVelocityX(-spd);
        if(this.keys.D.isDown) this.player.setVelocityX(spd);
        if(this.keys.W.isDown) this.player.setVelocityY(-spd);
        if(this.keys.S.isDown) this.player.setVelocityY(spd);

        // 2. Sistema de Armas
        STATE.weapons.forEach(w => {
            // Cooldown de disparo
            if(time > w.nextFire) {
                this.fireWeapon(w);
                w.nextFire = time + (w.cd * STATE.passives.cooldown);
            }
            
            // Lógica de Orbitais
            if(w.type === 'orbital') {
                w.angle = (w.angle || 0) + (w.speed * (delta/1000));
                w.sprites.forEach((s, i) => {
                    const offset = (Math.PI * 2 / w.count) * i;
                    s.x = this.player.x + Math.cos(w.angle + offset) * 100;
                    s.y = this.player.y + Math.sin(w.angle + offset) * 100;
                });
            }
            
            // Lógica de Aura
            if(w.type === 'aura' && w.sprite) {
                w.sprite.setPosition(this.player.x, this.player.y);
            }
        });

        // 3. IA Inimigos Simples
        this.enemies.children.iterate(e => {
            if(!e.active) return;
            if(e.isBoss) this.updateBoss(e, time);
            else this.physics.moveToObject(e, this.player, e.speed);
        });

        // 4. Magneto XP
        this.xpGems.children.iterate(xp => {
            if(Phaser.Math.Distance.Between(this.player.x, this.player.y, xp.x, xp.y) < 150) {
                this.physics.moveToObject(xp, this.player, 400);
            }
        });
    }

    // ================== LÓGICA DE COMBATE ==================

    fireWeapon(w) {
        if(w.type === 'projectile') {
            let target = this.getClosestEnemy();
            if(target) {
                const b = this.bullets.create(this.player.x, this.player.y, 'gfx_proj');
                b.setTint(w.color);
                this.physics.moveToObject(b, target, w.speed);
                b.damage = w.dmg * STATE.passives.might;
                this.time.delayedCall(2000, () => b.destroy());
            }
        }
    }

    getClosestEnemy() {
        let closest = null;
        let min = 1000;
        this.enemies.children.iterate(e => {
            if(!e.active) return;
            const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, e.x, e.y);
            if(d < min) { min = d; closest = e; }
        });
        return closest;
    }

    hitEnemy(bullet, enemy) {
        if(bullet.isAura || bullet.isOrbital) {
            // Dano contínuo (requer timer interno no inimigo)
            if(enemy.invuln > this.time.now) return;
            enemy.invuln = this.time.now + 300;
        } else {
            bullet.destroy();
        }

        const dmg = bullet.damage || (bullet.weaponRef ? bullet.weaponRef.dmg * STATE.passives.might : 10);
        enemy.hp -= dmg;
        this.showDamage(enemy.x, enemy.y, Math.floor(dmg));

        if(enemy.hp <= 0) {
            this.spawnXp(enemy.x, enemy.y, enemy.isBoss ? 500 : 10);
            STATE.kills++;
            document.getElementById('hud-kills').innerText = STATE.kills;
            enemy.destroy();
            if(enemy.isBoss) {
                document.getElementById('boss-alert').style.display = 'none';
                this.cameras.main.shake(1000, 0.01);
            }
        } else {
            enemy.setTint(0xffffff);
            this.time.delayedCall(50, () => enemy.clearTint());
        }
    }

    hitPlayer(player, enemy) {
        if(player.invuln) return;
        STATE.hp -= 10;
        player.setTint(0xff0000);
        player.invuln = true;
        this.cameras.main.shake(100, 0.01);
        
        document.getElementById('hud-hp').innerText = Math.max(0, Math.ceil(STATE.hp));
        
        this.time.delayedCall(500, () => {
            player.clearTint();
            player.invuln = false;
        });

        if(STATE.hp <= 0) {
            this.physics.pause();
            STATE.isPaused = true;
            alert(`GAME OVER\nNível: ${STATE.level}\nTempo: ${document.getElementById('hud-time').innerText}`);
            location.reload();
        }
    }

    // ================== SISTEMA DE BOSS ==================

    spawnBoss() {
        const data = BOSS_DB[Math.floor(Math.random() * BOSS_DB.length)];
        
        // Calcular posição longe da tela
        const angle = Math.random() * Math.PI * 2;
        const x = this.player.x + Math.cos(angle) * 600;
        const y = this.player.y + Math.sin(angle) * 600;

        const boss = this.enemies.create(x, y, ASSETS_URL.boss ? 'boss' : 'gfx_boss');
        boss.setScale(data.scale);
        boss.setTint(data.color);
        boss.isBoss = true;
        
        // HP Escala com o jogo
        boss.maxHp = 1000 * STATE.level * (data.hpMult/100);
        boss.hp = boss.maxHp;
        boss.aiType = data.ai;
        boss.state = 'CHASE'; 
        boss.stateTimer = 0;
        boss.speed = 60; // Boss é mais lento
        
        // UI
        const alert = document.getElementById('boss-alert');
        alert.innerText = `⚠️ ${data.name} ⚠️`;
        alert.style.display = 'block';
        setTimeout(() => alert.style.display = 'none', 4000);
    }

    updateBoss(boss, time) {
        if(time < boss.stateTimer) return;

        // Máquina de Estados Simples
        const dist = Phaser.Math.Distance.Between(boss.x, boss.y, this.player.x, this.player.y);

        if(boss.state === 'CHASE') {
            this.physics.moveToObject(boss, this.player, boss.speed);
            if(dist < 200) {
                boss.state = 'ATTACK';
                boss.stateTimer = time + 1500; // Prepara ataque
                boss.body.setVelocity(0);
                boss.setTint(0xffffff); // Flash de aviso
            }
        } 
        else if (boss.state === 'ATTACK') {
            boss.clearTint(); // Volta cor original
            // Executa golpe baseado no tipo
            if(boss.aiType === 'charger') {
                this.physics.moveToObject(boss, this.player, 400); // Investida rápida
            } else if (boss.aiType === 'shooter') {
                // Atira em leque
                for(let i=-2; i<=2; i++) {
                    const b = this.enemies.create(boss.x, boss.y, 'gfx_proj'); // Usa inimigo pequeno como bala
                    b.setScale(0.5); b.hp = 1; b.speed = 300;
                    this.physics.moveTo(b, this.player.x + (i*50), this.player.y, 300);
                }
            }
            boss.state = 'COOLDOWN';
            boss.stateTimer = time + 2000;
        }
        else if (boss.state === 'COOLDOWN') {
            boss.state = 'CHASE';
        }
    }

    // ================== GERENCIAMENTO E SPAWN ==================

    spawnEnemy() {
        if(this.enemies.countActive() > 200) return;
        
        // Spawn ao redor da câmera
        const cam = this.cameras.main;
        const x = Phaser.Math.Between(cam.worldView.left - 100, cam.worldView.right + 100);
        const y = Phaser.Math.Between(cam.worldView.top - 100, cam.worldView.bottom + 100);
        
        if(Phaser.Math.Distance.Between(x,y,this.player.x,this.player.y) < 500) return; // Longe do player

        const type = (Math.random() > 0.8) ? 'gfx_enemy' : 'gfx_enemy'; // Poderia variar sprite aqui
        const e = this.enemies.create(x, y, type);
        
        // Escala de Dificuldade
        e.hp = 15 + (STATE.level * 2);
        e.speed = 80 + (Math.random() * 40);
        if(Math.random() < 0.1) { e.setScale(1.5); e.hp *= 3; e.speed *= 0.8; } // Elite
    }

    spawnXp(x, y, amount) {
        const gem = this.xpGems.create(x, y, 'gfx_xp');
        gem.value = amount;
    }

    collectXp(player, gem) {
        gem.destroy();
        STATE.xp += gem.value;
        const pct = (STATE.xp / STATE.nextXp) * 100;
        document.getElementById('xp-bar').style.width = Math.min(100, pct) + '%';
        
        if(STATE.xp >= STATE.nextXp) {
            STATE.xp = 0;
            STATE.nextXp = Math.floor(STATE.nextXp * 1.3);
            STATE.level++;
            STATE.hp = STATE.maxHp; // Cura ao subir de nível
            document.getElementById('hud-lvl').innerText = STATE.level;
            document.getElementById('hud-hp').innerText = STATE.maxHp;
            document.getElementById('xp-bar').style.width = '0%';
            
            this.openLevelUp();
        }
    }

    // ================== UI E UTILITÁRIOS ==================

    tickSecond() {
        if(STATE.isPaused) return;
        STATE.time++;
        const m = Math.floor(STATE.time / 60).toString().padStart(2,'0');
        const s = (STATE.time % 60).toString().padStart(2,'0');
        document.getElementById('hud-time').innerText = `${m}:${s}`;
        
        // Spawn Boss a cada minuto
        if(STATE.time % 60 === 0 && STATE.time > 0) this.spawnBoss();
    }

    showDamage(x, y, val) {
        const t = this.add.text(x, y, val, { fontSize: '18px', color: '#fff', stroke: '#000', strokeThickness: 2 });
        this.tweens.add({ targets: t, y: y-30, alpha: 0, duration: 500, onComplete: ()=>t.destroy() });
    }

    openLevelUp() {
        STATE.isPaused = true;
        this.physics.pause();
        const screen = document.getElementById('levelup-screen');
        const list = document.getElementById('upgrade-list');
        list.innerHTML = '';
        screen.classList.remove('hidden');

        // Selecionar 3 opções aleatórias
        const options = [...WEAPONS_DB]; // Simplificado: pode repetir
        for(let i=0; i<3; i++) {
            const item = options[Math.floor(Math.random()*options.length)];
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = `<h3>${item.name}</h3><small>${item.type.toUpperCase()}</small><p>${item.desc}</p>`;
            card.onclick = () => {
                this.addWeapon(item.id);
                screen.classList.add('hidden');
                STATE.isPaused = false;
                this.physics.resume();
            };
            list.appendChild(card);
        }
    }

    addWeapon(id) {
        const stats = WEAPONS_DB.find(x => x.id === id);
        
        // Verifica se já tem
        const existing = STATE.weapons.find(w => w.id === id);
        if(existing) {
            existing.dmg *= 1.5; // Level up da arma
            if(existing.type === 'orbital') {
                existing.count++;
                existing.sprites.forEach(s => s.destroy());
                existing.sprites = [];
                for(let i=0; i<existing.count; i++) existing.sprites.push(this.physics.add.sprite(0,0,'gfx_orb').setTint(stats.color));
            }
        } else {
            const newWep = { ...stats, nextFire: 0, sprites: [] };
            if(newWep.type === 'aura') {
                newWep.sprite = this.add.sprite(0,0,'gfx_aura').setAlpha(0.2).setTint(newWep.color);
                this.physics.add.existing(newWep.sprite);
                this.bullets.add(newWep.sprite); // Adiciona ao grupo de colisão
                newWep.sprite.isAura = true;
                newWep.sprite.weaponRef = newWep;
            }
            if(newWep.type === 'orbital') {
                newWep.sprites.push(this.physics.add.sprite(0,0,'gfx_orb').setTint(newWep.color));
                newWep.sprites.forEach(s => { s.isOrbital = true; s.weaponRef = newWep; this.bullets.add(s); });
            }
            STATE.weapons.push(newWep);
        }
    }
}

// INICIALIZAÇÃO
const config = {
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight,
    backgroundColor: '#050505',
    parent: document.body,
    physics: { default: 'arcade', arcade: { debug: false, fps: 60 } },
    scene: MainScene
};

const game = new Phaser.Game(config);
</script>
</body>
</html>

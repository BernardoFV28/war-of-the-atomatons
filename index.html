<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons - Survivor Mode (Fixed)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000008c7; }
    canvas { display: block; margin: auto; }
    .menu-overlay, .shop-overlay, .pause-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.85); display: flex; justify-content: center; align-items: center; z-index: 1000; color: #FFF; backdrop-filter: blur(5px); }
    .menu-container, .shop-container, .pause-container { background-color: #333; border: 2px solid #555; padding: 20px; border-radius: 8px; text-align: center; width: 80%; max-width: 900px; box-shadow: 0 0 20px rgba(0,0,0,0.8); }
    .menu-title, .shop-title, .pause-title { font-size: 36px; margin-bottom: 20px; color: #00FFFF; text-shadow: 0 0 10px #00FFFF; }
    .cards-container, .shop-items-container { display: flex; justify-content: space-around; gap: 20px; flex-wrap: wrap; }
    .card, .shop-item { background-color: #222; border: 1px solid #444; border-radius: 8px; padding: 15px; width: 250px; display: flex; flex-direction: column; align-items: center; text-align: left; min-height: 220px; transition: transform 0.2s; }
    .card:hover { transform: translateY(-5px); box-shadow: 0 5px 20px rgba(0, 255, 255, 0.5); border-color: #00FFFF; }
    .card-title, .shop-item-name { font-size: 22px; color: #FFD700; margin-bottom: 5px; }
    .card-button, .shop-item-button, .shop-close-button, .pause-close-button, .pause-tab-button { padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; margin-top: auto; font-weight: bold; }
    .card-button { background-color: #008CBA; color: white; width: 100%; }
    .card-button:hover { background-color: #00779E; }
    .shop-item-button { background-color: #28a745; color: white; }
    .shop-close-button, .pause-close-button { background-color: #dc3545; color: white; }
    .card-rarity { font-size: 14px; font-weight: bold; margin: 5px 0 10px 0; text-transform: uppercase; }
  </style>
</head>
<body>
<script>
// --- Game Configuration ---
const WORLD_SIZE = 4000; 
const config = {
  type: Phaser.AUTO,
  width: 1320,
  height: 590,
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: { debug: false, gravity: { y: 0 } } // Debug false para performance
  },
  scene: { preload, create, update }
};

// --- Centralized Game Balance & Config ---
const GAME_CONFIG = {
    PLAYER: {
        INITIAL_SCALE: 0.08,
        DEFAULT_TINT: 0xFFFFFF,
        DASH_DURATION: 150, DASH_DISTANCE: 400, DASH_COOLDOWN_BASE: 2000,
        ACCELERATION: 2000, DRAG: 0.6,
        BASE_MAGNET_RANGE: 150,
        BASE_PIERCING: 1
    },
    BULLET: { INITIAL_SPEED: 1000, INITIAL_SCALE: 0.01 },
    WEAPONS: {
        1: { fireRate: 800, damage: 2, speed: 1000, range: 450 },     
    },
    WAVE: {
        INITIAL_ENEMY_COUNT: 10, // Aumentei um pouco para ficar dinâmico
        ENEMY_INCREMENT_PER_WAVE: 5,
        INITIAL_SPAWN_RATE: 800,
        SPAWN_RATE_DECREASE_PER_WAVE: 50,
        MAX_ENEMIES_ON_SCREEN: 150,
        MIN_SPAWN_RATE: 100
    },
    CAMERA_SHAKE: { PLAYER_HIT: { DURATION: 100, INTENSITY: 0.01 } }
};

// --- Global Variables ---
let player, cursors, bullets, enemies, xpGemsGroup;
let hud;
let lastShoot = 0;
let waveNumber = 1;

// Controle de Wave Robusto
let enemiesToKillThisWave = GAME_CONFIG.WAVE.INITIAL_ENEMY_COUNT; 
let enemiesKilledThisWave = 0; 

let enemySpawnRate = GAME_CONFIG.WAVE.INITIAL_SPAWN_RATE;
let currentWeapon = 1;
let gamePaused = false, levelUpMenuOpen = false;
let closestEnemy = null;
let spawnerEvent = null; // FIX: Variável para guardar referência do timer

// --- Player Stats ---
let playerStats = {
  life: 3, maxLife: 3,
  bulletDamage: 2, fireRate: 600, playerSpeed: 300,
  xp: 0, level: 1, xpToNextLevel: 20, 
  currency: 0,
  magnetRange: GAME_CONFIG.PLAYER.BASE_MAGNET_RANGE,
  piercingCount: GAME_CONFIG.PLAYER.BASE_PIERCING,
  dashAvailable: false, dashCooldown: false, doubleBullets: false,
  incomingDamageMultiplier: 1, weaponBulletSpeed: GAME_CONFIG.BULLET.INITIAL_SPEED,
  inventory: []
};

// --- Enemy Definitions ---
const enemyTypes = {
  normal: { texture: 'enemy_robot', baseHealth: 4, speed: 100, scale: 0.06, xpValue: 5 },
  fast: { texture: 'enemy_fast', baseHealth: 3, speed: 220, scale: 0.06, xpValue: 8 },
  tank: { texture: 'enemy_tank', baseHealth: 20, speed: 60, scale: 0.08, xpValue: 25 },
  boss_robot: { texture: 'boss_robot', baseHealth: 500, speed: 200, scale: 0.2, xpValue: 200, boss: true }
};

// --- Item Rarity ---
const itemRarities = {
    common: { color: '#FFFFFF' }, rare: { color: '#00BFFF' }, epic: { color: '#9932CC' }, legendary: { color: '#FFD700' }
};

// --- Card Options ---
const itemOptions = [
  { nome: "Balas de Titânio", descricao: "+20% Dano", rarity: 'common', efeito: () => playerStats.bulletDamage *= 1.2 },
  { nome: "Gatilho Rápido", descricao: "+15% Velocidade de Ataque", rarity: 'common', efeito: () => playerStats.fireRate *= 0.85 },
  { nome: "Motor V8", descricao: "+10% Velocidade de Movimento", rarity: 'common', efeito: () => playerStats.playerSpeed *= 1.1 },
  { nome: "Imã de Sucata", descricao: "+50% Alcance de Coleta", rarity: 'common', efeito: () => playerStats.magnetRange *= 1.5 },
  { nome: "Projétil Perfurante", descricao: "Balas atravessam +1 inimigo", rarity: 'rare', efeito: () => playerStats.piercingCount += 1 },
  { nome: "Pele Reforçada", descricao: "+1 Vida Máxima", rarity: 'rare', efeito: () => { playerStats.maxLife++; playerStats.life++; hud.updateHealthBar(); } },
  { nome: "Tiro Duplo", descricao: "Dispara um segundo projétil", rarity: 'epic', efeito: () => playerStats.doubleBullets = true },
  { nome: "Módulo de Dash", descricao: "Habilita Dash (Espaço)", rarity: 'epic', efeito: () => playerStats.dashAvailable = true },
];

// --- HUD Class ---
class HUD extends Phaser.GameObjects.Container {
  constructor(scene, x, y) {
    super(scene, x, y);
    scene.add.existing(this);
    this.setDepth(1000); 
    this.setScrollFactor(0); 
    this.lifeText = scene.add.text(20, 20, '', { fontSize: '24px', fontStyle: 'bold', fill: '#FF4444', stroke: '#000', strokeThickness: 4 }).setScrollFactor(0);
    this.levelText = scene.add.text(20, 50, '', { fontSize: '20px', fill: '#FFFF00', stroke: '#000', strokeThickness: 3 }).setScrollFactor(0);
    this.xpBarBg = scene.add.rectangle(20, 85, 200, 10, 0x333333).setOrigin(0).setScrollFactor(0).setStrokeStyle(1, 0xFFFFFF);
    this.xpBar = scene.add.rectangle(20, 85, 0, 10, 0x00FF00).setOrigin(0).setScrollFactor(0);
    this.waveText = scene.add.text(config.width / 2, 30, '', { fontSize: '32px', fontStyle: 'bold', fill: '#FFFFFF', stroke: '#000', strokeThickness: 4 }).setOrigin(0.5).setScrollFactor(0);
    this.add([this.lifeText, this.levelText, this.xpBarBg, this.xpBar, this.waveText]);
    this.updateAll();
  }
  updateAll() {
      this.lifeText.setText(`HP: ${Math.ceil(playerStats.life)} / ${playerStats.maxLife}`);
      this.levelText.setText(`LVL: ${playerStats.level}`);
      this.waveText.setText(`WAVE ${waveNumber} - Kills: ${enemiesKilledThisWave}/${enemiesToKillThisWave}`); 
      
      let xpRatio = playerStats.xp / playerStats.xpToNextLevel;
      if (xpRatio > 1) xpRatio = 1;
      this.xpBar.width = 200 * xpRatio;
  }
  updateHealthBar() { this.updateAll(); }
  updateXpBar() { this.updateAll(); }
}

// --- Phaser Scene Functions ---
function preload() {
  // Usando assets placeholders confiáveis
  this.load.image('player', 'https://labs.phaser.io/assets/sprites/phaser-dude.png');
  this.load.image('bullet', 'https://labs.phaser.io/assets/sprites/bullets/bullet7.png');
  this.load.image('enemy_robot', 'https://labs.phaser.io/assets/sprites/space-baddie.png');
  this.load.image('enemy_fast', 'https://labs.phaser.io/assets/sprites/shmup-baddie2.png');
  this.load.image('enemy_tank', 'https://labs.phaser.io/assets/sprites/baddie-cat-1.png');
  this.load.image('boss_robot', 'https://labs.phaser.io/assets/sprites/phaser-ship.png');
  this.load.image('ammo', 'https://labs.phaser.io/assets/sprites/orb-green.png');
  this.load.image('background_tile', 'https://labs.phaser.io/assets/skies/space2.png');
}

function create() {
  this.physics.world.setBounds(0, 0, WORLD_SIZE, WORLD_SIZE);
  // TileSprite para fundo infinito
  this.add.tileSprite(WORLD_SIZE / 2, WORLD_SIZE / 2, WORLD_SIZE, WORLD_SIZE, 'background_tile').setScrollFactor(0.5).setScale(2);

  player = this.physics.add.sprite(WORLD_SIZE / 2, WORLD_SIZE / 2, 'player').setScale(GAME_CONFIG.PLAYER.INITIAL_SCALE);
  player.setCollideWorldBounds(true);
  player.setDrag(GAME_CONFIG.PLAYER.DRAG); player.setMaxVelocity(playerStats.playerSpeed);
  player.setDepth(10);

  this.cameras.main.setBounds(0, 0, WORLD_SIZE, WORLD_SIZE);
  this.cameras.main.startFollow(player, true, 0.09, 0.09); 

  cursors = this.input.keyboard.createCursorKeys();
  this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
  this.keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);
  this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
  this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
  this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);

  bullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 100 });
  enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true, maxSize: GAME_CONFIG.WAVE.MAX_ENEMIES_ON_SCREEN });
  xpGemsGroup = this.physics.add.group({ classType: XPGem, runChildUpdate: true, maxSize: 300 });

  this.physics.add.overlap(bullets, enemies, bulletHitEnemy, null, this);
  this.physics.add.collider(player, enemies, playerHitEnemy, null, this);
  this.physics.add.overlap(player, xpGemsGroup, collectXPGem, null, this);

  hud = new HUD(this, 0, 0); 
  switchWeapon.call(this, 1);

  // FIX: Armazenar referência do evento
  this.spawnerEvent = this.time.addEvent({ delay: enemySpawnRate, callback: spawnEnemy, callbackScope: this, loop: true });
}

function update(time, delta) {
  if (gamePaused || levelUpMenuOpen) return;

  // Movimentação
  player.setAcceleration(0);
  if (cursors.left.isDown || this.keyA.isDown) player.setAccelerationX(-GAME_CONFIG.PLAYER.ACCELERATION);
  else if (cursors.right.isDown || this.keyD.isDown) player.setAccelerationX(GAME_CONFIG.PLAYER.ACCELERATION);
  if (cursors.up.isDown || this.keyW.isDown) player.setAccelerationY(-GAME_CONFIG.PLAYER.ACCELERATION);
  else if (cursors.down.isDown || this.keyS.isDown) player.setAccelerationY(GAME_CONFIG.PLAYER.ACCELERATION);

  // Dash
  if (Phaser.Input.Keyboard.JustDown(this.keySpace) && playerStats.dashAvailable && !playerStats.dashCooldown) {
    performDash(this);
  }
  
  // Auto-Targeting
  closestEnemy = null;
  let minDistance = Infinity;
  const weaponRange = GAME_CONFIG.WEAPONS[currentWeapon].range;

  // Otimização: Só procurar inimigos se houver inimigos ativos
  if (enemies.countActive() > 0) {
      enemies.children.each(enemy => {
          if (enemy.active) {
              const dist = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
              if (dist < minDistance && dist <= weaponRange) {
                  minDistance = dist;
                  closestEnemy = enemy;
              }
          }
      });
  }

  if (time > lastShoot) {
    // Se não tiver inimigo, atira na direção que o player está andando ou olhando
    if (closestEnemy) {
        shootBullet.call(this, closestEnemy);
        lastShoot = time + playerStats.fireRate;
    } else if (cursors.left.isDown || cursors.right.isDown || cursors.up.isDown || cursors.down.isDown) {
        // Opcional: Atirar para frente se estiver andando
        // shootStraight(this); 
    }
  }
}

// --- Game Logic Functions ---
function shootBullet(targetEnemy) {
  let baseBulletCount = playerStats.doubleBullets ? 2 : 1;
  const angleRad = Phaser.Math.Angle.Between(player.x, player.y, targetEnemy.x, targetEnemy.y);
  
  for (let i = 0; i < baseBulletCount; i++) {
    let offsetAngle = (baseBulletCount > 1) ? Phaser.Math.DEG_TO_RAD * ((i === 0 ? -10 : 10)) : 0;
    const bullet = bullets.get(player.x, player.y);
    if (bullet) bullet.fire(angleRad + offsetAngle, playerStats.weaponBulletSpeed, playerStats.bulletDamage, playerStats.piercingCount);
  }
}

function switchWeapon(weaponNum) {
  currentWeapon = weaponNum;
  const weaponConfig = GAME_CONFIG.WEAPONS[currentWeapon];
  playerStats.fireRate = weaponConfig.fireRate;
  playerStats.bulletDamage = weaponConfig.damage;
  playerStats.weaponBulletSpeed = weaponConfig.speed;
}

function bulletHitEnemy(bullet, enemy) {
  if (!bullet.active || !enemy.active) return;
  
  // Efeito visual
  enemy.setTint(0xFF0000);
  enemy.takeDamage(bullet.damage);
  
  bullet.piercingHealth--;
  if (bullet.piercingHealth <= 0) bullet.kill();
  
  // A verificação de morte agora acontece no takeDamage/update do inimigo para evitar race conditions
  if (enemy.health <= 0) handleEnemyDeath.call(this, enemy);
}

function playerHitEnemy(player, enemy) {
    if (!player.active || !enemy.active || player.isInvulnerable) return;
    
    this.cameras.main.shake(GAME_CONFIG.CAMERA_SHAKE.PLAYER_HIT.DURATION, GAME_CONFIG.CAMERA_SHAKE.PLAYER_HIT.INTENSITY);
    playerStats.life -= 1;
    hud.updateHealthBar();
    player.setTint(0xFF0000);
    player.isInvulnerable = true;
    
    // Knockback
    const angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, player.x, player.y);
    const knockback = this.physics.velocityFromRotation(angle, 400);
    player.body.setVelocity(knockback.x, knockback.y);

    this.time.delayedCall(1000, () => { 
        if(player.active) {
            player.clearTint(); 
            player.isInvulnerable = false; 
        }
    });
    
    if (playerStats.life <= 0) gameOver.call(this);
}

function handleEnemyDeath(enemy) {
    if (!enemy.active || enemy.isDeadFlag) return; // Previne contar morte 2x
    enemy.isDeadFlag = true; // Marca como morto
    
    dropXPGem(this, enemy.x, enemy.y, enemy.enemyType.xpValue);
    enemy.kill();

    enemiesKilledThisWave++;
    hud.updateAll();
    
    if (enemiesKilledThisWave >= enemiesToKillThisWave) {
        startNextWave.call(this);
    }
}

function dropXPGem(scene, x, y, xpValue) {
    const gem = xpGemsGroup.get(x, y);
    if (gem) {
        gem.spawn(xpValue);
    } else {
        // Se o pool estiver cheio, recicla o mais antigo (crudamente)
        const oldGem = xpGemsGroup.getFirstAlive();
        if(oldGem) {
            oldGem.kill();
            const newGem = xpGemsGroup.get(x, y);
            if(newGem) newGem.spawn(xpValue);
        }
    }
}

function collectXPGem(player, gem) {
    if(gem.isBeingCollected) return;
    gem.isBeingCollected = true;
    gainXp.call(this, gem.xpValue);
    gem.kill();
}

function gainXp(amount) {
  playerStats.xp += amount;
  checkLevelUp.call(this); // Chama função separada para checagem recursiva
  hud.updateAll();
}

function checkLevelUp() {
    if (playerStats.xp >= playerStats.xpToNextLevel) {
        playerStats.level++;
        playerStats.xp -= playerStats.xpToNextLevel;
        playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.3);
        hud.updateAll();
        showLevelUpMenu.call(this);
    }
}

function performDash(scene) {
    playerStats.dashCooldown = true;
    const dashVelocity = scene.physics.velocityFromRotation(player.rotation, GAME_CONFIG.PLAYER.DASH_DISTANCE * 4);
    
    // Se o player estiver parado, dash para frente do sprite ou direita padrão
    if (player.body.velocity.x === 0 && player.body.velocity.y === 0) {
        player.body.setVelocity(GAME_CONFIG.PLAYER.DASH_DISTANCE * 3, 0);
    } else {
        // Dash na direção do movimento atual
        player.body.velocity.normalize().scale(GAME_CONFIG.PLAYER.DASH_DISTANCE * 3);
    }

    player.setTint(0x00FFFF);
    scene.time.delayedCall(GAME_CONFIG.PLAYER.DASH_DURATION, () => player.clearTint());
    scene.time.delayedCall(GAME_CONFIG.PLAYER.DASH_COOLDOWN_BASE, () => playerStats.dashCooldown = false);
}

function spawnEnemy() {
  if (gamePaused) return;
  if (enemies.countActive() >= GAME_CONFIG.WAVE.MAX_ENEMIES_ON_SCREEN) return;

  // FIX: Lógica de Spawn "Inteligente"
  // Só para de spawnar se já matamos o suficiente OU se a tela já está cheia de inimigos suficientes para completar a wave
  const enemiesAlive = enemies.countActive();
  const enemiesRemainingToKill = enemiesToKillThisWave - enemiesKilledThisWave;
  
  if (enemiesKilledThisWave >= enemiesToKillThisWave) return; // Já matou todos
  if (enemiesAlive >= enemiesRemainingToKill + 2) return; // Já tem inimigos suficientes vivos para acabar a wave (com margem de erro)
  
  const cam = this.cameras.main; 
  let x, y;
  const padding = 100;
  
  // Spawn fora da câmera
  if (Math.random() < 0.5) { 
      x = (Math.random() < 0.5) ? cam.scrollX - padding : cam.scrollX + cam.width + padding;
      y = Phaser.Math.Between(cam.scrollY - padding, cam.scrollY + cam.height + padding);
  } else { 
      x = Phaser.Math.Between(cam.scrollX - padding, cam.scrollX + cam.width + padding);
      y = (Math.random() < 0.5) ? cam.scrollY - padding : cam.scrollY + cam.height + padding;
  }

  // Clamp para dentro do mundo
  x = Phaser.Math.Clamp(x, 50, WORLD_SIZE - 50);
  y = Phaser.Math.Clamp(y, 50, WORLD_SIZE - 50);

  let enemyTypeKey = 'normal';
  const rand = Math.random();
  
  if (waveNumber % 5 === 0 && enemiesKilledThisWave === 0 && enemies.countActive() === 0) {
      // Spawn garantido de Boss no inicio de waves multiplas de 5 (opcional)
      // enemyTypeKey = 'boss_robot'; 
  } else {
      if(waveNumber > 2 && rand > 0.7) enemyTypeKey = 'fast';
      if(waveNumber > 4 && rand > 0.85) enemyTypeKey = 'tank';
  }

  const enemy = enemies.get(x, y);
  if (enemy) {
    enemy.spawn(enemyTypes[enemyTypeKey]);
  }
}

function startNextWave() {
  waveNumber++;
  
  // Balanceamento
  enemiesToKillThisWave += GAME_CONFIG.WAVE.ENEMY_INCREMENT_PER_WAVE; 
  enemiesKilledThisWave = 0; 
  
  let newRate = enemySpawnRate - GAME_CONFIG.WAVE.SPAWN_RATE_DECREASE_PER_WAVE;
  enemySpawnRate = Math.max(GAME_CONFIG.WAVE.MIN_SPAWN_RATE, newRate);
  
  // FIX: Usar a variável spawnerEvent armazenada corretamente
  if(this.spawnerEvent) {
      this.spawnerEvent.remove();
      this.spawnerEvent = this.time.addEvent({ delay: enemySpawnRate, callback: spawnEnemy, callbackScope: this, loop: true });
  }

  // Cura um pouco o player na troca de wave
  playerStats.life = Math.min(playerStats.life + 1, playerStats.maxLife);
  hud.updateAll();

  // Texto visual de aviso
  const waveTitle = this.add.text(this.cameras.main.centerX, this.cameras.main.centerY - 100, `WAVE ${waveNumber}`, { fontSize: '64px', color: '#FFF', stroke: '#000', strokeThickness: 6 }).setOrigin(0.5).setScrollFactor(0);
  this.tweens.add({
      targets: waveTitle, alpha: 0, duration: 2000, ease: 'Power2',
      onComplete: () => waveTitle.destroy()
  });
}

// --- Custom Classes ---
class Bullet extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y) { super(scene, x, y, 'bullet'); }
  fire(angle, speed, damage, piercing) {
      this.setActive(true).setVisible(true).setScale(GAME_CONFIG.BULLET.INITIAL_SCALE);
      this.damage = damage; this.piercingHealth = piercing; this.setRotation(angle);
      this.scene.physics.velocityFromRotation(angle, speed, this.body.velocity);
      this.lifeSpan = 1500; // Tempo de vida da bala
  }
  kill() { this.setActive(false).setVisible(false); this.body.stop(); }
  preUpdate(time, delta) {
      super.preUpdate(time, delta);
      this.lifeSpan -= delta;
      if (this.lifeSpan <= 0) this.kill();
  }
}

class Enemy extends Phaser.Physics.Arcade.Sprite {
  constructor(scene, x, y) { super(scene, x, y, 'enemy_robot'); }
  spawn(enemyData) {
      this.setActive(true).setVisible(true).setTexture(enemyData.texture).setScale(enemyData.scale);
      // Vida escala com Wave
      this.health = enemyData.baseHealth * (1 + (waveNumber * 0.15));
      this.speed = enemyData.speed; 
      this.enemyType = enemyData; 
      this.isDeadFlag = false; // Flag para evitar morte duplicada
      this.setTint(0xffffff);
      this.body.setSize(this.width * 0.8, this.height * 0.8); // Hitbox melhorada
  }
  takeDamage(amount) { 
      this.health -= amount; 
      this.scene.time.delayedCall(50, ()=> { if(this.active && !this.isDeadFlag) this.clearTint() }); 
  }
  kill() { this.setActive(false).setVisible(false); this.body.stop(); }
  update(time, delta) {
    if (!this.active || this.isDeadFlag) return;
    if (gamePaused) { this.body.setVelocity(0,0); return; }
    
    if (player.active && !player.isDead) {
        this.scene.physics.moveToObject(this, player, this.speed);
    }
  }
}

class XPGem extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) { 
        super(scene, x, y, 'ammo'); 
        this.setScale(0.5); this.setTint(0x00ff00);
    }
    spawn(xpValue) {
        this.setActive(true).setVisible(true);
        this.xpValue = xpValue; this.isBeingCollected = false; this.body.setVelocity(0);
        this.setAlpha(1);
    }
    kill() { this.setActive(false).setVisible(false); }
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        if(!this.active) return;
        
        const dist = Phaser.Math.Distance.Between(this.x, this.y, player.x, player.y);
        if (dist < playerStats.magnetRange) {
            this.isBeingCollected = true;
            this.scene.physics.moveToObject(this, player, 700); // Velocidade de atração
        } else {
            this.body.setVelocity(0); // Para se sair do range
            this.isBeingCollected = false;
        }
    }
}

// --- Menus HTML ---
function showLevelUpMenu() {
    if (levelUpMenuOpen) return;
    gamePaused = true; levelUpMenuOpen = true; this.physics.pause();
    
    const overlay = document.createElement('div'); overlay.className = 'menu-overlay';
    const container = document.createElement('div'); container.className = 'menu-container';
    container.innerHTML = '<h2 class="menu-title">LEVEL UP!</h2>';
    const cardsDiv = document.createElement('div'); cardsDiv.className = 'cards-container';
    
    // Seleciona 3 cartas aleatórias
    const choices = Phaser.Utils.Array.Shuffle([...itemOptions]).slice(0, 3);
    
    choices.forEach(item => {
        const card = document.createElement('div'); card.className = 'card';
        card.innerHTML = `
            <h3 class="card-title">${item.nome}</h3>
            <p class="card-rarity" style="color:${itemRarities[item.rarity].color}">${item.rarity}</p>
            <p style="flex-grow:1">${item.descricao}</p>
            <button class="card-button">Selecionar</button>
        `;
        card.querySelector('button').onclick = () => {
            item.efeito(this);
            document.body.removeChild(overlay);
            levelUpMenuOpen = false; 
            gamePaused = false; 
            this.physics.resume();
            
            // FIX: Verificar se tem mais XP acumulado para outro level up
            checkLevelUp.call(this);
        };
        cardsDiv.appendChild(card);
    });
    container.appendChild(cardsDiv); overlay.appendChild(container); document.body.appendChild(overlay);
}

function gameOver() {
  if(gamePaused) return;
  this.physics.pause(); gamePaused = true; player.isDead = true;
  const overlay = document.createElement('div'); overlay.className = 'menu-overlay';
  overlay.innerHTML = `
    <div class="menu-container" style="border-color: red;">
        <h2 class="menu-title" style="color:red">SISTEMA CRÍTICO</h2>
        <p>Você sobreviveu até a Wave ${waveNumber}</p>
        <button class="card-button" onclick="location.reload()">Reiniciar Protocolo</button>
    </div>`;
  document.body.appendChild(overlay);
}

new Phaser.Game(config);
</script>
</body>
</html>

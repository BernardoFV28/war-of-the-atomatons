<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons V1.3 - A Cruzada da Rainha</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0a0000ce;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh; /* Garante que o body ocupe a altura total da viewport */
    }
    #game-container {
      width: 100%; /* Permite que o Phaser.Scale gerencie o tamanho */
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas {
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
<div id="game-container"></div>
<script>
const config = {
  type: Phaser.AUTO,
  width: 1380,
  height: 580,
  backgroundColor: '#000000',
  parent: 'game-container',
  physics: {
    default: 'arcade',
    arcade: {
      gravity: { y: 0 },
      debug: false // Mudar para true para ver os bodies de colisão
    }
  },
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH
  },
  scene: {
    preload: preloadScene,
    create: createScene,
    update: updateScene
  }
};

let game = new Phaser.Game(config);

// Variáveis Globais (movidas para fora das funções para fácil acesso global)
let player;
let cursors;
let bullets;
let enemyBullets;
let enemies;
let obstaclesGroup;
let scoreText;
let healthText;
let waveText;
let score = 0;
let playerHealth = 100;
let playerMaxHealth = 100;
let playerSpeed = 400;
let originalPlayerSpeed = 400;
let playerDamage = 10;
let wave = 1;
let enemiesToSpawn = 5;
let enemiesKilledThisWave = 0;
let enemySpawnDelay = 1000;
let lastEnemySpawnTime = 0;
let gameOver = false;
let bossMode = false;
let boss = null;
let killStreak = 0;
let frenzyActive = false;
let frenzyTimer = null;
let playerOriginalDamage = 10;
let playerOriginalTint = 0xFFFFFF; // Cor original do sprite do jogador
let playerIsSlowed = false;
let playerSpeedRestoreTimer = null;
let temporaryEffectText = null;
let temporaryEffectTimer = null;
let currentWeapon = 'pistol';
let weaponText; // Texto para exibir a arma atual
let weaponIcon; // Ícone da arma atual
let enemySpawnEvent; // Referência para o evento de spawn
let bulletFireRate = 200; // Taxa de tiro inicial da pistola
let shotgunPellets = 5; // Número de projéteis da shotgun
let rifleFireRate = 50; // Taxa de tiro do rifle
let nextFireTime = 0; // Próximo tempo que o jogador pode atirar
let inventoryText; // Texto para o inventário
let activableItemCooldownText; // Texto para cooldown de item ativável
let lastUsedItemTime = 0; // Tempo da última vez que um item ativável foi usado
let lastWeaponPickupTime = 0; // Tempo da última coleta de arma
const WEAPON_PICKUP_COOLDOWN = 2000; // 2 segundos de cooldown para pegar armas
let playerInventory = {
    weapons: {
        pistol: true,
        shotgun: false,
        rifle: false
    },
    activableItems: {
        healPack: { count: 0, ready: true, lastUsed: 0, cooldown: 10000 }, // 10 segundos
        grenade: { count: 0, ready: true, lastUsed: 0, cooldown: 5000 },   // 5 segundos
        holographicClone: { count: 0, ready: true, lastUsed: 0, cooldown: 15000 } // 15 segundos
    },
    passiveItems: []
};
let powerUpGroup;
let cursedItemGroup;
let gunsGroup; // Grupo para as armas no chão
let frenzyTintTween = null; // Para controlar o tween de frenesi

// Novos grupos para gerenciar clones e outras entidades
let holographicClonesGroup;

function preloadScene() {
    this.load.image('player', 'assets/player.png');
    this.load.image('bullet', 'assets/bullet.png');
    this.load.image('enemyBullet', 'assets/enemyBullet.png');
    this.load.image('background', 'assets/background.png'); // Carrega a imagem de fundo

    // Sprites dos inimigos
    this.load.image('enemyBasic', 'assets/enemyBasic.png');
    this.load.image('enemyShooter', 'assets/enemyShooter.png');
    this.load.image('enemyCharger', 'assets/enemyCharger.png');
    this.load.image('enemyMiniBoss', 'assets/enemyMiniBoss.png'); // Boss
    this.load.image('boss', 'assets/boss.png'); // Boss final

    // Sprites de obstáculos
    this.load.image('scrapBlock', 'assets/scrapBlock.png');
    this.load.image('electricCoil', 'assets/electricCoil.png');
    this.load.image('spikes', 'assets/spikes.png');

    // Sprites de Power-ups
    this.load.image('powerUpSpeed', 'assets/powerUpSpeed.png');
    this.load.image('powerUpDamage', 'assets/powerUpDamage.png');
    this.load.image('powerUpHealth', 'assets/powerUpHealth.png');
    this.load.image('powerUpFireRate', 'assets/powerUpFireRate.png');

    // Sprites de Itens Amaldiçoados
    this.load.image('cursedItem', 'assets/cursedItem.png');

    // Sprites de Armas
    this.load.image('pistol', 'assets/pistol.png');
    this.load.image('shotgun', 'assets/shotgun.png');
    this.load.image('rifle', 'assets/rifle.png');

    // Sprites de Itens Ativáveis (se tiver)
    this.load.image('healPack', 'assets/healPack.png');
    this.load.image('grenade', 'assets/grenade.png');
    this.load.image('holographicClone', 'assets/holographicClone.png');

    // Sprites de Explosões (se animado, carregar spritesheet)
    this.load.spritesheet('explosion', 'assets/explosion.png', { frameWidth: 64, frameHeight: 64 });
}

function createScene() {
    // Adiciona o background tiled, preenchendo a tela
    this.add.tileSprite(0, 0, config.width * 2, config.height * 2, 'background').setOrigin(0).setScrollFactor(0);

    // Cria o jogador
    player = this.physics.add.sprite(config.width / 4, config.height / 2, 'player');
    player.setScale(0.5); // **OPTIMIZAÇÃO: Reduz o tamanho do jogador**
    player.setOrigin(0.05);
    player.setCollideWorldBounds(true);
    player.setDamping(true);
    player.setDrag(0.9); // Aplica atrito

    cursors = this.input.keyboard.createCursorKeys();
    this.input.keyboard.addKey('W').on('down', () => player.setAccelerationY(-playerSpeed));
    this.input.keyboard.addKey('S').on('down', () => player.setAccelerationY(playerSpeed));
    this.input.keyboard.addKey('A').on('down', () => player.setAccelerationX(-playerSpeed));
    this.input.keyboard.addKey('D').on('down', () => player.setAccelerationX(playerSpeed));
    this.input.keyboard.addKey('W').on('up', () => { if (!this.input.keyboard.addKey('S').isDown) player.setAccelerationY(0); });
    this.input.keyboard.addKey('S').on('up', () => { if (!this.input.keyboard.addKey('W').isDown) player.setAccelerationY(0); });
    this.input.keyboard.addKey('A').on('up', () => { if (!this.input.keyboard.addKey('D').isDown) player.setAccelerationX(0); });
    this.input.keyboard.addKey('D').on('up', () => { if (!this.input.keyboard.addKey('A').isDown) player.setAccelerationX(0); });

    this.input.keyboard.addKey('SPACE').on('down', shootBullet, this);
    this.input.keyboard.addKey('E').on('down', useActivableItem, this); // Usar item ativável

    // Cria grupo de balas do jogador
    bullets = this.physics.add.group({
        classType: Phaser.Physics.Arcade.Image,
        maxSize: 30, // Limita o número de balas na tela
        runChildUpdate: true
    });
    bullets.createMultiple({
        key: 'bullet',
        repeat: 29, // Cria 30 balas no total (0 a 29)
        active: false,
        visible: false,
        setScale: 0.8 // **OPTIMIZAÇÃO: Escala inicial para todas as balas**
    });

    // Cria grupo de balas inimigas
    enemyBullets = this.physics.add.group({
        classType: Phaser.Physics.Arcade.Image,
        maxSize: 50,
        runChildUpdate: true
    });
    enemyBullets.createMultiple({
        key: 'enemyBullet',
        repeat: 49,
        active: false,
        visible: false,
        setScale: 0.8 // **OPTIMIZAÇÃO: Escala inicial para todas as balas inimigas**
    });

    // Cria grupo de inimigos
    enemies = this.physics.add.group();
    obstaclesGroup = this.physics.add.staticGroup(); // Grupo para obstáculos estáticos
    powerUpGroup = this.physics.add.group(); // Grupo para power-ups
    cursedItemGroup = this.physics.add.group(); // Grupo para itens amaldiçoados
    gunsGroup = this.physics.add.group(); // Grupo para armas no chão
    holographicClonesGroup = this.physics.add.group(); // Grupo para clones holográficos

    // HUD
    scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '24px', fill: '#FFF' });
    healthText = this.add.text(16, 40, 'Health: 100', { fontSize: '24px', fill: '#FFF' });
    waveText = this.add.text(16, 64, 'Wave: 1', { fontSize: '24px', fill: '#FFF' });
    weaponText = this.add.text(config.width - 200, 16, 'Weapon: Pistol', { fontSize: '24px', fill: '#FFF' }).setOrigin(1, 0);
    weaponIcon = this.add.image(config.width - 100, 40, currentWeapon).setScale(0.05).setOrigin(0.5, 0.5); // Ícone da arma
    inventoryText = this.add.text(config.width - 200, 80, 'Heal Pack: 0\nGrenade: 0\nClone: 0', { fontSize: '20px', fill: '#FFF' }).setOrigin(1, 0);
    activableItemCooldownText = this.add.text(config.width - 200, 150, '', { fontSize: '18px', fill: '#FF0000' }).setOrigin(1, 0);

    // Ajusta a profundidade do HUD para sempre ficar por cima
    scoreText.setDepth(1);
    healthText.setDepth(1);
    waveText.setDepth(1);
    weaponText.setDepth(1);
    weaponIcon.setDepth(1);
    inventoryText.setDepth(1);
    activableItemCooldownText.setDepth(1);

    // Colisões e Overlaps
    this.physics.add.collider(player, enemies, hitPlayer, null, this);
    this.physics.add.collider(player, obstaclesGroup); // Colisão entre jogador e obstáculos
    this.physics.add.collider(enemies, enemies); // Inimigos colidem entre si
    this.physics.add.collider(enemies, obstaclesGroup); // Inimigos colidem com obstáculos
    this.physics.add.overlap(bullets, enemies, hitEnemy, null, this);
    this.physics.add.overlap(enemyBullets, player, hitPlayer, null, this);
    this.physics.add.overlap(player, powerUpGroup, collectPowerUp, null, this);
    this.physics.add.overlap(player, cursedItemGroup, collectCursedItem, null, this);
    this.physics.add.overlap(player, gunsGroup, collectWeapon, null, this);
    this.physics.add.overlap(holographicClonesGroup, enemies, hitHolographicCloneEnemy, null, this); // Clones causam dano a inimigos
    this.physics.add.overlap(bullets, obstaclesGroup, bulletHitObstacle, null, this); // Balas colidem com obstáculos

    // Animações
    this.anims.create({
        key: 'explode',
        frames: this.anims.generateFrameNumbers('explosion', { start: 0, end: 15 }),
        frameRate: 24,
        repeat: 0,
        hideOnComplete: true
    });

    resetGameVariables();
    startNewWave(this); // Inicia a primeira onda
}

function updateScene(time, delta) {
    if (gameOver) {
        return;
    }

    // Movimento do jogador (usando aceleração para atrito)
    player.setAcceleration(0);
    if (this.input.keyboard.addKey('W').isDown) player.setAccelerationY(-playerSpeed);
    if (this.input.keyboard.addKey('S').isDown) player.setAccelerationY(playerSpeed);
    if (this.input.keyboard.addKey('A').isDown) player.setAccelerationX(-playerSpeed);
    if (this.input.keyboard.addKey('D').isDown) player.setAccelerationX(playerSpeed);

    // Rotação do jogador para olhar o mouse
    let angle = Phaser.Math.Angle.Between(player.x, player.y, this.input.activePointer.x, this.input.activePointer.y);
    player.setRotation(angle + Math.PI / 2); // Ajusta para o sprite estar "para cima"

    // Tiro com o mouse
    if (this.input.activePointer.isDown && time > nextFireTime) {
        shootBullet.call(this);
        nextFireTime = time + bulletFireRate;
    }

    // Atualiza inimigos
    enemies.children.each(function(enemy) {
        if (enemy.active) {
            // Lógica de movimento e ataque dos inimigos
            const target = (enemy.type === 'enemyShooter' && holographicClonesGroup.getLength() > 0) ? findNearestTarget(enemy, player, holographicClonesGroup) : player;

            if (enemy.type === 'enemyBasic' || enemy.type === 'enemyCharger') {
                this.physics.moveToObject(enemy, target, enemy.speed);
            } else if (enemy.type === 'enemyShooter') {
                this.physics.moveToObject(enemy, target, enemy.speed); // Ainda se move, mas mais devagar
                if (time > enemy.nextShotTime) {
                    shootEnemyBullet.call(this, enemy, target);
                    enemy.nextShotTime = time + enemy.fireRate;
                }
            } else if (enemy.type === 'enemyMiniBoss' || enemy.type === 'boss') {
                this.physics.moveToObject(enemy, target, enemy.speed);
                if (time > enemy.nextShotTime) {
                    shootEnemyBullet.call(this, enemy, target);
                    enemy.nextShotTime = time + enemy.fireRate;
                }
            }
        }
    }, this);

    // Atualiza o texto do inventário
    updateInventoryDisplay();
    updateActivableItemCooldownDisplay(time);

    // Verifica condição de Game Over
    if (playerHealth <= 0 && !gameOver) {
        endGame(this);
    }
}

function resetGameVariables() {
    playerHealth = 100;
    playerMaxHealth = 100;
    playerSpeed = 400;
    originalPlayerSpeed = 400;
    playerDamage = 10;
    score = 0;
    wave = 1;
    enemiesToSpawn = 5;
    enemiesKilledThisWave = 0;
    enemySpawnDelay = 1000;
    lastEnemySpawnTime = 0;
    gameOver = false;
    bossMode = false;
    boss = null;
    killStreak = 0;
    frenzyActive = false;
    frenzyTimer = null;
    playerOriginalDamage = 10;
    playerOriginalTint = 0xFFFFFF;
    playerIsSlowed = false;
    playerSpeedRestoreTimer = null;
    temporaryEffectText = null;
    temporaryEffectTimer = null;
    currentWeapon = 'pistol';
    frenzyTintTween = null;

    // Resetar inventário
    playerInventory.weapons = {
        pistol: true,
        shotgun: false,
        rifle: false
    };
    playerInventory.activableItems = {
        healPack: { count: 0, ready: true, lastUsed: 0, cooldown: 10000 },
        grenade: { count: 0, ready: true, lastUsed: 0, cooldown: 5000 },
        holographicClone: { count: 0, ready: true, lastUsed: 0, cooldown: 15000 }
    };
    playerInventory.passiveItems = [];

    for (const itemKey in playerInventory.activableItems) {
        playerInventory.activableItems[itemKey].ready = true;
        playerInventory.activableItems[itemKey].lastUsed = 0;
    }

    // Limpar grupos
    if (enemies) enemies.clear(true, true);
    if (bullets) bullets.clear(true, true);
    if (enemyBullets) enemyBullets.clear(true, true);
    if (obstaclesGroup) obstaclesGroup.clear(true, true);
    if (powerUpGroup) powerUpGroup.clear(true, true);
    if (cursedItemGroup) cursedItemGroup.clear(true, true);
    if (gunsGroup) gunsGroup.clear(true, true);
    if (holographicClonesGroup) holographicClonesGroup.clear(true, true);

    // Resetar HUD
    scoreText.setText('Score: 0');
    healthText.setText('Health: 100');
    waveText.setText('Wave: 1');
    weaponText.setText('Weapon: Pistol');
    weaponIcon.setTexture('pistol');
    updateInventoryDisplay();
    activableItemCooldownText.setText('');

    // Parar eventos de spawn existentes
    if (enemySpawnEvent) {
        enemySpawnEvent.remove(false);
        enemySpawnEvent = null;
    }

    // Resetar velocidade e tintura do jogador
    player.setTint(playerOriginalTint);
    player.body.setDrag(0.9); // Reaplicar atrito se necessário
}

function spawnEnemies(scene, count) {
    for (let i = 0; i < count; i++) {
        let x = Phaser.Math.Between(config.width / 2, config.width - 50);
        let y = Phaser.Math.Between(50, config.height - 50);

        let enemyType;
        let random = Math.random();
        if (random < 0.6) { // 60% chance de inimigo básico
            enemyType = 'enemyBasic';
        } else if (random < 0.85) { // 25% chance de inimigo atirador
            enemyType = 'enemyShooter';
        } else { // 15% chance de inimigo carregador
            enemyType = 'enemyCharger';
        }

        let enemy = enemies.create(x, y, enemyType);
        enemy.setScale(0.7); // **OPTIMIZAÇÃO: Escala do inimigo**
        enemy.setCollideWorldBounds(true);
        enemy.setBounce(1); // Inimigos ricocheteiam nas bordas
        enemy.setPushable(true); // Inimigos são empurráveis

        enemy.health = 50;
        enemy.damage = 10;
        enemy.speed = 100;
        enemy.type = enemyType; // Adiciona o tipo para lógica específica

        if (enemyType === 'enemyShooter') {
            enemy.health = 70;
            enemy.speed = 80;
            enemy.fireRate = 2000; // Atira a cada 2 segundos
            enemy.nextShotTime = scene.time.now + Phaser.Math.Between(0, enemy.fireRate); // Variar o primeiro tiro
        } else if (enemyType === 'enemyCharger') {
            enemy.health = 80;
            enemy.speed = 150;
            enemy.damage = 15;
        }

        enemy.setData('originalTint', enemy.tintTopLeft); // Guarda a tintura original para resetar se for danificado
    }
}

function spawnObstacles(scene, count) {
    obstaclesGroup.clear(true, true); // Limpa obstáculos anteriores

    for (let i = 0; i < count; i++) {
        let x = Phaser.Math.Between(config.width / 4, config.width - 50);
        let y = Phaser.Math.Between(50, config.height - 50);

        let obstacleType;
        let random = Math.random();
        if (random < 0.6) {
            obstacleType = 'scrapBlock';
        } else if (random < 0.8) {
            obstacleType = 'electricCoil';
        } else {
            obstacleType = 'spikes';
        }

        let obstacle = obstaclesGroup.create(x, y, obstacleType);
        obstacle.setScale(0.8); // **OPTIMIZAÇÃO: Escala dos obstáculos**
        obstacle.setImmovable(true); // Não pode ser movido
        obstacle.refreshBody(); // Atualiza o corpo de física para estáticos

        obstacle.type = obstacleType; // Para lógica de dano ou efeito
    }
}

function spawnMiniBoss(scene) {
    bossMode = true;
    let x = config.width - 100;
    let y = Phaser.Math.Between(50, config.height - 50);

    boss = enemies.create(x, y, 'enemyMiniBoss');
    boss.setScale(1.5); // **OPTIMIZAÇÃO: Escala do mini-boss**
    boss.setCollideWorldBounds(true);
    boss.setBounce(1);
    boss.setPushable(false); // Mini-boss não é empurrável

    boss.health = 300;
    boss.damage = 25;
    boss.speed = 60;
    boss.type = 'enemyMiniBoss';
    boss.fireRate = 1500; // Atira a cada 1.5 segundos
    boss.nextShotTime = scene.time.now + Phaser.Math.Between(0, boss.fireRate); // Variar o primeiro tiro

    boss.setData('originalTint', boss.tintTopLeft);
}

function spawnBoss(scene) {
    bossMode = true;
    let x = config.width - 100;
    let y = Phaser.Math.Between(50, config.height - 50);

    boss = enemies.create(x, y, 'boss');
    boss.setScale(2); // **OPTIMIZAÇÃO: Escala do boss final**
    boss.setCollideWorldBounds(true);
    boss.setBounce(1);
    boss.setPushable(false);

    boss.health = 1000;
    boss.damage = 50;
    boss.speed = 50;
    boss.type = 'boss';
    boss.fireRate = 1000; // Atira a cada 1 segundo
    boss.nextShotTime = scene.time.now + Phaser.Math.Between(0, boss.fireRate);

    boss.setData('originalTint', boss.tintTopLeft);
}

function shootBullet() {
    if (gameOver) return;

    // Garante que o jogador pode atirar de acordo com a taxa de tiro da arma atual
    if (this.time.now < nextFireTime) {
        return;
    }

    const currentWeaponData = getWeaponData(currentWeapon);
    const bulletsToShoot = currentWeaponData.pellets || 1; // Para shotgun
    const spreadAngle = currentWeaponData.spreadAngle || 0; // Para shotgun

    for (let i = 0; i < bulletsToShoot; i++) {
        let bullet = bullets.get(player.x, player.y);
        if (bullet) {
            let angle = Phaser.Math.Angle.Between(player.x, player.y, this.input.activePointer.x, this.input.activePointer.y);

            if (bulletsToShoot > 1) { // Aplicar spread para shotgun
                const randomSpread = Phaser.Math.Between(-spreadAngle / 2, spreadAngle / 2) * (Math.PI / 180);
                angle += randomSpread;
            }

            let velocityX = Math.cos(angle) * 800;
            let velocityY = Math.sin(angle) * 800;

            bullet.setActive(true).setVisible(true).setRotation(angle + Math.PI / 2);
            bullet.body.setVelocity(velocityX, velocityY);
            bullet.damage = playerDamage; // Dano da bala é o dano do jogador
            bullet.setScale(0.8); // **OPTIMIZAÇÃO: Escala da bala**
            bullet.setDepth(0); // Garante que a bala está abaixo do HUD

            // Desativa a bala se sair da tela
            bullet.body.onWorldBounds = true;
            bullet.body.world.on('worldbounds', function(body) {
                if (body.gameObject === bullet) {
                    bullet.disableBody(true, true);
                }
            }, this);
        }
    }
    nextFireTime = this.time.now + currentWeaponData.fireRate;
}

function shootEnemyBullet(enemy, target) {
    let enemyBullet = enemyBullets.get(enemy.x, enemy.y);
    if (enemyBullet) {
        let angle = Phaser.Math.Angle.Between(enemy.x, enemy.y, target.x, target.y);
        let velocityX = Math.cos(angle) * 400; // Velocidade da bala inimiga
        let velocityY = Math.sin(angle) * 400;

        enemyBullet.setActive(true).setVisible(true);
        enemyBullet.setRotation(angle + Math.PI / 2); // Aponta na direção do alvo
        enemyBullet.body.setVelocity(velocityX, velocityY);
        enemyBullet.damage = enemy.damage; // Dano da bala inimiga é o dano do inimigo
        enemyBullet.setScale(0.8); // **OPTIMIZAÇÃO: Escala da bala inimiga**
        enemyBullet.setDepth(0);

        enemyBullet.body.onWorldBounds = true;
        enemyBullet.body.world.on('worldbounds', function(body) {
            if (body.gameObject === enemyBullet) {
                enemyBullet.disableBody(true, true);
            }
        }, this);
    }
}

function hitPlayer(player, target) {
    if (gameOver) return;

    let damageAmount = target.damage || 10; // Padrão de dano se não especificado
    if (target.type === 'electricCoil') { // Dano contínuo para bobina elétrica
        damageAmount = 0.5; // Dano menor mas por tick
    } else if (target.type === 'spikes') { // Dano contínuo para espinhos
        damageAmount = 1;
    }

    playerHealth -= damageAmount;
    healthText.setText('Health: ' + Math.max(0, Math.floor(playerHealth))); // Garante que não exiba negativo

    // Efeito visual de dano
    player.setTint(0xff0000); // Vermelho
    this.time.delayedCall(100, () => {
        player.setTint(playerOriginalTint); // Volta ao normal
    });

    if (target.active && target.disableBody && target.type !== 'electricCoil' && target.type !== 'spikes') {
        target.disableBody(true, true); // Desativa o inimigo ou bala, a menos que seja um obstáculo de dano contínuo
    }

    if (playerHealth <= 0) {
        endGame(this);
    }
}

function hitEnemy(bullet, enemy) {
    bullet.disableBody(true, true); // Desativa a bala

    enemy.health -= bullet.damage;

    // Efeito visual de dano no inimigo
    enemy.setTint(0xff0000); // Vermelho
    this.time.delayedCall(100, () => {
        enemy.setTint(enemy.getData('originalTint')); // Volta à cor original do sprite
    });

    if (enemy.health <= 0) {
        enemiesKilledThisWave++;
        score += 10;
        killStreak++;
        scoreText.setText('Score: ' + score);
        createExplosion(this, enemy.x, enemy.y); // Cria animação de explosão
        enemy.disableBody(true, true); // Desativa o inimigo

        // Chance de drop de Power-up, Cursed Item ou Arma
        dropRandomItem(this, enemy.x, enemy.y);

        if (enemiesKilledThisWave >= enemiesToSpawn && !bossMode) {
            this.time.delayedCall(2000, () => startNewWave(this)); // Inicia nova onda após 2 segundos
        } else if (bossMode && enemy === boss) {
            // Boss derrotado
            endGame(this, true); // Passa true para indicar vitória
        }

        // Ativação do Frenesi
        if (killStreak >= 5 && !frenzyActive) {
            activateFrenzy(this);
        }
    }
}

function hitHolographicCloneEnemy(clone, enemy) {
    // Clone é destruído em contato
    clone.disableBody(true, true);

    // Inimigo toma dano (você pode ajustar o dano que o clone causa)
    enemy.health -= playerDamage * 0.5; // Exemplo: clone causa metade do dano do jogador

    // Efeito visual de dano no inimigo
    enemy.setTint(0xff0000); // Vermelho
    this.time.delayedCall(100, () => {
        enemy.setTint(enemy.getData('originalTint'));
    });

    if (enemy.health <= 0) {
        enemiesKilledThisWave++;
        score += 10;
        killStreak++;
        scoreText.setText('Score: ' + score);
        createExplosion(this, enemy.x, enemy.y);
        enemy.disableBody(true, true);

        dropRandomItem(this, enemy.x, enemy.y);

        if (enemiesKilledThisWave >= enemiesToSpawn && !bossMode) {
            this.time.delayedCall(2000, () => startNewWave(this));
        } else if (bossMode && enemy === boss) {
            endGame(this, true);
        }

        if (killStreak >= 5 && !frenzyActive) {
            activateFrenzy(this);
        }
    }
}

function bulletHitObstacle(bullet, obstacle) {
    bullet.disableBody(true, true); // Bala é destruída ao atingir o obstáculo
    // Não causa dano ao obstáculo, eles são imunes
}

function startNewWave(scene) {
    enemiesKilledThisWave = 0;
    wave++;
    waveText.setText('Wave: ' + wave);

    enemiesToSpawn = 5 + (wave * 2); // Mais inimigos a cada onda
    enemySpawnDelay = Math.max(200, 1000 - (wave * 50)); // Reduz o delay mínimo

    // Limpa inimigos remanescentes e balas
    enemies.clear(true, true);
    enemyBullets.clear(true, true);
    bullets.clear(true, true);
    holographicClonesGroup.clear(true, true); // Limpa clones também

    // Limpa power-ups, itens amaldiçoados e armas que sobraram no chão
    powerUpGroup.clear(true, true);
    cursedItemGroup.clear(true, true);
    gunsGroup.clear(true, true);

    // Reseta o boss se estiver no modo boss
    bossMode = false;
    boss = null;

    // Reseta Kill Streak para a nova onda
    killStreak = 0;
    deactivateFrenzy(scene); // Garante que o frenesi seja desativado

    // Spawna obstáculos para a nova onda
    spawnObstacles(scene, Math.floor(wave / 2) + 1); // Aumenta obstáculos com as ondas

    // Define um evento cronometrado para spawnar inimigos gradualmente
    if (enemySpawnEvent) {
        enemySpawnEvent.remove(false);
    }
    let spawnedCount = 0;
    enemySpawnEvent = scene.time.addEvent({
        delay: enemySpawnDelay,
        callback: () => {
            spawnEnemies(scene, 1); // Spawna um inimigo por vez
            spawnedCount++;
            if (spawnedCount >= enemiesToSpawn) {
                enemySpawnEvent.remove(false); // Remove o evento quando todos os inimigos da onda foram spawnados
            }
        },
        callbackScope: scene,
        loop: true
    });

    // Spawna mini-boss em ondas específicas
    if (wave % 5 === 0 && wave !== 10) { // Mini-boss a cada 5 ondas, exceto a 10
        scene.time.delayedCall(5000, () => spawnMiniBoss(scene)); // Spawna 5 segundos após o início da onda
    } else if (wave === 10) { // Boss final na onda 10
        scene.time.delayedCall(5000, () => spawnBoss(scene));
    }
}

function endGame(scene, win = false) {
    gameOver = true;
    player.setTint(0x555555); // Escurece o jogador
    player.disableBody(true, true); // Desabilita o jogador
    enemies.children.each(enemy => enemy.disableBody(true, true)); // Desabilita inimigos
    bullets.children.each(bullet => bullet.disableBody(true, true)); // Desabilita balas
    enemyBullets.children.each(bullet => bullet.disableBody(true, true)); // Desabilita balas inimigas
    holographicClonesGroup.clear(true, true); // Remove clones

    // Parar eventos de spawn
    if (enemySpawnEvent) {
        enemySpawnEvent.remove(false);
    }

    let message;
    let fillColor;
    if (win) {
        message = 'Você Venceu a Cruzada da Rainha!\nScore Final: ' + score;
        fillColor = '#00FF00'; // Verde
    } else {
        message = 'GAME OVER!\nScore Final: ' + score + '\nClique para Reiniciar';
        fillColor = '#FF0000'; // Vermelho
    }

    const finalScoreText = scene.add.text(config.width / 2, config.height / 2, message, {
        fontSize: '48px',
        fill: fillColor,
        align: 'center'
    }).setOrigin(0.5);
    finalScoreText.setDepth(2); // Garante que esteja acima de tudo

    // Adiciona interatividade para reiniciar o jogo
    if (!win) {
        scene.input.once('pointerdown', () => {
            finalScoreText.destroy();
            scene.scene.restart();
        });
    }
}

function dropRandomItem(scene, x, y) {
    const dropChance = Math.random();

    if (dropChance < 0.05) { // 5% de chance de arma
        dropWeapon(scene, x, y);
    } else if (dropChance < 0.25) { // 20% de chance de power-up (0.25 - 0.05)
        dropPowerUp(scene, x, y);
    } else if (dropChance < 0.30) { // 5% de chance de item amaldiçoado (0.30 - 0.25)
        dropCursedItem(scene, x, y);
    } else if (dropChance < 0.40) { // 10% de chance de item ativável (0.40 - 0.30)
        dropActivableItem(scene, x, y);
    }
}

function dropPowerUp(scene, x, y) {
    const powerUpTypes = ['powerUpSpeed', 'powerUpDamage', 'powerUpHealth', 'powerUpFireRate'];
    const randomType = Phaser.Utils.Array.GetRandom(powerUpTypes);

    let powerUp = powerUpGroup.create(x, y, randomType);
    powerUp.setScale(0.7); // **OPTIMIZAÇÃO: Escala do power-up**
    powerUp.setDepth(0);
    powerUp.type = randomType;
}

function dropCursedItem(scene, x, y) {
    let cursedItem = cursedItemGroup.create(x, y, 'cursedItem');
    cursedItem.setScale(0.7); // **OPTIMIZAÇÃO: Escala do item amaldiçoado**
    cursedItem.setDepth(0);
    // Pode ter diferentes tipos de maldição, por agora, um genérico
    cursedItem.type = 'genericCurse';
}

function dropWeapon(scene, x, y) {
    const availableWeapons = [];
    if (!playerInventory.weapons.shotgun) availableWeapons.push('shotgun');
    if (!playerInventory.weapons.rifle) availableWeapons.push('rifle');

    if (availableWeapons.length > 0) {
        const randomWeapon = Phaser.Utils.Array.GetRandom(availableWeapons);
        let gun = gunsGroup.create(x, y, randomWeapon);
        gun.setScale(0.7); // **OPTIMIZAÇÃO: Escala da arma no chão**
        gun.setDepth(0);
        gun.weaponType = randomWeapon;
    }
}

function dropActivableItem(scene, x, y) {
    const activableItemTypes = ['healPack', 'grenade', 'holographicClone'];
    const randomType = Phaser.Utils.Array.GetRandom(activableItemTypes);

    let item = powerUpGroup.create(x, y, randomType); // Usa o grupo de power-ups para colisão
    item.setScale(0.7); // **OPTIMIZAÇÃO: Escala do item ativável**
    item.setDepth(0);
    item.type = randomType; // Marca o tipo para coleta
    item.isActivableItem = true; // Flag para diferenciar de power-ups
}

function collectPowerUp(player, powerUp) {
    if (gameOver) return;

    powerUp.disableBody(true, true); // Remove o power-up

    // Efeito visual de coleta
    createFloatingText(this, powerUp.x, powerUp.y, '+' + powerUp.type.replace('powerUp', ''), '#00FF00');

    switch (powerUp.type) {
        case 'powerUpSpeed':
            playerSpeed += 50;
            displayTemporaryEffect(this, 'Velocidade Aumentada!', '#00FF00');
            break;
        case 'powerUpDamage':
            playerDamage += 5;
            displayTemporaryEffect(this, 'Dano Aumentado!', '#00FF00');
            break;
        case 'powerUpHealth':
            playerHealth = Math.min(playerMaxHealth, playerHealth + 25);
            healthText.setText('Health: ' + Math.floor(playerHealth));
            displayTemporaryEffect(this, 'Saúde Restaurada!', '#00FF00');
            break;
        case 'powerUpFireRate':
            bulletFireRate = Math.max(50, bulletFireRate - 20); // Diminui o tempo entre tiros (aumenta fire rate)
            rifleFireRate = Math.max(20, rifleFireRate - 10);
            displayTemporaryEffect(this, 'Cadência Aumentada!', '#00FF00');
            break;
        case 'healPack':
        case 'grenade':
        case 'holographicClone':
            // Isso é um item ativável, trata a coleta
            if (powerUp.isActivableItem) {
                playerInventory.activableItems[powerUp.type].count++;
                updateInventoryDisplay();
            }
            break;
    }
}

function collectCursedItem(player, cursedItem) {
    if (gameOver) return;

    cursedItem.disableBody(true, true); // Remove o item amaldiçoado

    // Efeito visual de maldição
    createFloatingText(this, cursedItem.x, cursedItem.y, 'MALDIÇÃO!', '#FF0000');

    // Aplica um efeito negativo aleatório
    const curseEffects = ['slow', 'damage', 'fireRateDecrease'];
    const randomCurse = Phaser.Utils.Array.GetRandom(curseEffects);

    switch (randomCurse) {
        case 'slow':
            playerSpeed *= 0.7; // Reduz velocidade em 30%
            playerIsSlowed = true;
            if (playerSpeedRestoreTimer) playerSpeedRestoreTimer.remove(false);
            playerSpeedRestoreTimer = this.time.delayedCall(5000, () => {
                playerSpeed = originalPlayerSpeed; // Restaura velocidade original
                playerIsSlowed = false;
                displayTemporaryEffect(this, 'Velocidade Restaurada.', '#00FF00');
            });
            displayTemporaryEffect(this, 'Você está Lento!', '#FF0000');
            break;
        case 'damage':
            playerHealth -= 15; // Perde vida
            healthText.setText('Health: ' + Math.max(0, Math.floor(playerHealth)));
            displayTemporaryEffect(this, 'Perdeu Vida!', '#FF0000');
            if (playerHealth <= 0) {
                endGame(this);
            }
            break;
        case 'fireRateDecrease':
            bulletFireRate += 100; // Aumenta o tempo entre tiros (diminui fire rate)
            rifleFireRate += 50;
            if (playerSpeedRestoreTimer) playerSpeedRestoreTimer.remove(false); // Reutiliza o timer para clareza
            playerSpeedRestoreTimer = this.time.delayedCall(5000, () => {
                // Tenta reverter a taxa de tiro para o estado antes da maldição
                bulletFireRate = getWeaponData(currentWeapon).fireRate; // Volta para a taxa de tiro da arma atual
                displayTemporaryEffect(this, 'Cadência Restaurada.', '#00FF00');
            });
            displayTemporaryEffect(this, 'Cadência Diminuída!', '#FF0000');
            break;
    }
}

function collectWeapon(player, gun) {
    if (gameOver || this.time.now < lastWeaponPickupTime + WEAPON_PICKUP_COOLDOWN) return;

    const weaponType = gun.weaponType;

    if (!playerInventory.weapons[weaponType]) {
        playerInventory.weapons[weaponType] = true;
        currentWeapon = weaponType;
        updateWeaponDisplay();
        gun.disableBody(true, true);
        lastWeaponPickupTime = this.time.now; // Reseta o cooldown de coleta
        displayTemporaryEffect(this, 'Arma Coletada: ' + weaponType.toUpperCase() + '!', '#00FFFF');
    } else {
        // Se já tem a arma, apenas remove a arma do chão (pode-se adicionar um efeito ou não fazer nada)
        gun.disableBody(true, true);
        displayTemporaryEffect(this, 'Já Possui essa Arma!', '#FFFF00');
    }
}


function getWeaponData(weaponName) {
    switch (weaponName) {
        case 'pistol':
            return { fireRate: 200, pellets: 1, spreadAngle: 0 };
        case 'shotgun':
            return { fireRate: 800, pellets: shotgunPellets, spreadAngle: 30 }; // Maior spread
        case 'rifle':
            return { fireRate: rifleFireRate, pellets: 1, spreadAngle: 0 };
        default:
            return { fireRate: 200, pellets: 1, spreadAngle: 0 }; // Default para pistola
    }
}

function updateWeaponDisplay() {
    weaponText.setText('Weapon: ' + currentWeapon.charAt(0).toUpperCase() + currentWeapon.slice(1));
    weaponIcon.setTexture(currentWeapon);
    // Atualiza a taxa de tiro do jogador para a arma selecionada
    bulletFireRate = getWeaponData(currentWeapon).fireRate;
}

function updateInventoryDisplay() {
    let inventoryString = 'Heal Pack: ' + playerInventory.activableItems.healPack.count +
                          '\nGrenade: ' + playerInventory.activableItems.grenade.count +
                          '\nClone: ' + playerInventory.activableItems.holographicClone.count;
    inventoryText.setText(inventoryString);
}

function updateActivableItemCooldownDisplay(time) {
    let cooldownText = '';
    for (const itemKey in playerInventory.activableItems) {
        const item = playerInventory.activableItems[itemKey];
        if (!item.ready) {
            const timeElapsed = time - item.lastUsed;
            const timeLeft = Math.ceil((item.cooldown - timeElapsed) / 1000);
            if (timeLeft > 0) {
                cooldownText += `${itemKey.charAt(0).toUpperCase() + itemKey.slice(1)} CD: ${timeLeft}s\n`;
            } else {
                item.ready = true; // Marca como pronto se o cooldown acabou
                activableItemCooldownText.setText(''); // Limpa texto se não há mais cooldown
            }
        }
    }
    activableItemCooldownText.setText(cooldownText);
}

function useActivableItem() {
    if (gameOver) return;

    // Prioridade de uso (você pode mudar a ordem)
    if (playerInventory.activableItems.healPack.count > 0 && playerInventory.activableItems.healPack.ready) {
        activateHealPack(this);
    } else if (playerInventory.activableItems.grenade.count > 0 && playerInventory.activableItems.grenade.ready) {
        activateGrenade(this);
    } else if (playerInventory.activableItems.holographicClone.count > 0 && playerInventory.activableItems.holographicClone.ready) {
        activateHolographicClone(this);
    }
}

function activateHealPack(scene) {
    if (playerInventory.activableItems.healPack.count > 0 && playerInventory.activableItems.healPack.ready) {
        playerInventory.activableItems.healPack.count--;
        playerHealth = Math.min(playerMaxHealth, playerHealth + 50); // Cura 50 de vida
        healthText.setText('Health: ' + Math.floor(playerHealth));
        playerInventory.activableItems.healPack.ready = false;
        playerInventory.activableItems.healPack.lastUsed = scene.time.now;
        displayTemporaryEffect(scene, 'Heal Pack Usado!', '#00FF00');
        updateInventoryDisplay();
    }
}

function activateGrenade(scene) {
    if (playerInventory.activableItems.grenade.count > 0 && playerInventory.activableItems.grenade.ready) {
        playerInventory.activableItems.grenade.count--;
        playerInventory.activableItems.grenade.ready = false;
        playerInventory.activableItems.grenade.lastUsed = scene.time.now;
        displayTemporaryEffect(scene, 'Granada Lançada!', '#FFA500');
        updateInventoryDisplay();

        // Cria uma "granada" que explode após um tempo
        let grenade = scene.add.sprite(player.x, player.y, 'bullet'); // Usa a imagem de bala temporariamente
        grenade.setScale(2); // **OPTIMIZAÇÃO: Escala da granada**
        scene.physics.world.enable(grenade);
        grenade.body.setVelocity(Phaser.Math.Between(-300, 300), Phaser.Math.Between(-300, 300)); // Lança em uma direção aleatória
        grenade.setTint(0x808080); // Cor de granada

        scene.time.delayedCall(1500, () => {
            // Explode
            createExplosion(scene, grenade.x, grenade.y, 2); // Explosão maior
            grenade.destroy();

            // Causa dano a todos os inimigos próximos
            enemies.children.each(enemy => {
                const distance = Phaser.Math.Distance.Between(grenade.x, grenade.y, enemy.x, enemy.y);
                if (distance < 200) { // Raio da explosão
                    enemy.health -= 100; // Dano da granada
                    // Efeito visual de dano no inimigo
                    enemy.setTint(0xff0000); // Vermelho
                    scene.time.delayedCall(100, () => {
                        enemy.setTint(enemy.getData('originalTint')); // Volta à cor original do sprite
                    });

                    if (enemy.health <= 0) {
                        enemiesKilledThisWave++;
                        score += 10;
                        killStreak++;
                        scoreText.setText('Score: ' + score);
                        createExplosion(scene, enemy.x, enemy.y);
                        enemy.disableBody(true, true);
                        dropRandomItem(scene, enemy.x, enemy.y);
                    }
                }
            });
        });
    }
}

function activateHolographicClone(scene) {
    if (playerInventory.activableItems.holographicClone.count > 0 && playerInventory.activableItems.holographicClone.ready) {
        playerInventory.activableItems.holographicClone.count--;
        playerInventory.activableItems.holographicClone.ready = false;
        playerInventory.activableItems.holographicClone.lastUsed = scene.time.now;
        displayTemporaryEffect(scene, 'Clone Holográfico Criado!', '#ADD8E6');
        updateInventoryDisplay();

        createHolographicClone(scene);
    }
}

function createHolographicClone(scene) {
    // Cria o clone um pouco à frente do jogador
    const cloneX = player.x + Math.cos(player.rotation - Math.PI / 2) * 50;
    const cloneY = player.y + Math.sin(player.rotation - Math.PI / 2) * 50;

    const clone = holographicClonesGroup.create(cloneX, cloneY, 'holographicClone');
    clone.setScale(0.8); // **OPTIMIZAÇÃO: Escala do clone**
    clone.setTint(0xADD8E6); // Tonalidade azulada para indicar que é um clone
    clone.setCollideWorldBounds(true);
    clone.setBounce(1);
    clone.setPushable(false); // Clones não são empurráveis
    clone.health = 50; // Clone tem uma vida limitada
    clone.damage = playerDamage * 0.5; // Causa metade do dano do jogador
    clone.speed = playerSpeed * 0.8; // Move-se um pouco mais devagar
    clone.setRotation(player.rotation); // Mesma rotação do jogador
    clone.setDepth(player.depth - 1); // Fica um pouco atrás do jogador

    scene.time.delayedCall(7000, () => { // Clone dura 7 segundos
        if (clone.active) {
            createExplosion(scene, clone.x, clone.y, 0.5); // Explosão menor ao desaparecer
            clone.disableBody(true, true);
        }
    });

    // O clone persegue o inimigo mais próximo
    clone.update = function () {
        if (this.active) {
            const nearestEnemy = findNearestTarget(this, null, enemies);
            if (nearestEnemy) {
                scene.physics.moveToObject(this, nearestEnemy, this.speed);
                // O clone também gira para olhar o inimigo
                let cloneAngle = Phaser.Math.Angle.Between(this.x, this.y, nearestEnemy.x, nearestEnemy.y);
                this.setRotation(cloneAngle + Math.PI / 2);
            } else {
                this.body.setVelocity(0); // Para se não houver inimigos
            }
        }
    };
}

function findNearestTarget(source, primaryTarget, secondaryGroup) {
    let nearestTarget = primaryTarget;
    let minDistance = primaryTarget ? Phaser.Math.Distance.Between(source.x, source.y, primaryTarget.x, primaryTarget.y) : Infinity;

    if (secondaryGroup && secondaryGroup.getLength() > 0) {
        secondaryGroup.children.each(function(target) {
            if (target.active) {
                const distance = Phaser.Math.Distance.Between(source.x, source.y, target.x, target.y);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestTarget = target;
                }
            }
        });
    }
    return nearestTarget;
}


function createExplosion(scene, x, y, scale = 1) {
    let explosion = scene.add.sprite(x, y, 'explosion');
    explosion.setScale(scale); // **OPTIMIZAÇÃO: Escala da explosão**
    explosion.play('explode');
    explosion.on('animationcomplete', () => explosion.destroy(), this);
}

function activateFrenzy(scene) {
    frenzyActive = true;
    playerDamage *= 2; // Dobra o dano
    playerSpeed *= 1.2; // Aumenta velocidade
    bulletFireRate *= 0.5; // Aumenta fire rate
    rifleFireRate *= 0.5;

    player.setTint(0xFFA500); // Laranja para indicar frenesi
    if (frenzyTintTween) {
        frenzyTintTween.stop();
    }
    frenzyTintTween = scene.tweens.add({
        targets: player,
        tint: { from: 0xFFA500, to: playerOriginalTint }, // Pisca entre laranja e cor original
        duration: 200,
        yoyo: true,
        repeat: -1
    });

    displayTemporaryEffect(scene, 'FRENESI ATIVADO!', '#FFA500');

    if (frenzyTimer) frenzyTimer.remove(false); // Limpa timer anterior se houver
    frenzyTimer = scene.time.delayedCall(10000, () => deactivateFrenzy(scene)); // Dura 10 segundos
}

function deactivateFrenzy(scene) {
    if (!frenzyActive) return;

    frenzyActive = false;
    playerDamage = playerOriginalDamage; // Retorna dano original
    playerSpeed = originalPlayerSpeed; // Retorna velocidade original
    bulletFireRate = getWeaponData(currentWeapon).fireRate; // Retorna fire rate da arma atual
    rifleFireRate = getWeaponData('rifle').fireRate;

    if (frenzyTintTween) {
        frenzyTintTween.stop();
        frenzyTintTween = null;
    }
    player.setTint(playerOriginalTint); // Volta à cor original

    displayTemporaryEffect(scene, 'Frenesi Encerrado.', '#FFFFFF');
    killStreak = 0; // Reseta o kill streak
}


function displayTemporaryEffect(scene, text, color = '#FFFFFF') {
    if (temporaryEffectText) {
        temporaryEffectText.destroy(); // Remove o texto anterior se ainda estiver ativo
    }
    if (temporaryEffectTimer) {
        temporaryEffectTimer.remove(false); // Remove o timer anterior
    }

    temporaryEffectText = scene.add.text(config.width / 2, config.height / 2 - 50, text, {
        fontSize: '36px',
        fill: color,
        align: 'center'
    }).setOrigin(0.5);
    temporaryEffectText.setDepth(2); // Acima de tudo

    temporaryEffectTimer = scene.time.delayedCall(2000, () => {
        if (temporaryEffectText) {
            temporaryEffectText.destroy();
            temporaryEffectText = null;
        }
    });
}

function createFloatingText(scene, x, y, text, color = '#FFFFFF') {
    const floatText = scene.add.text(x, y, text, {
        fontSize: '18px',
        fill: color,
        align: 'center'
    }).setOrigin(0.5);
    floatText.setDepth(2);

    scene.tweens.add({
        targets: floatText,
        y: floatText.y - 50, // Move para cima
        alpha: 0, // Desaparece
        duration: 1500,
        ease: 'Power1',
        onComplete: () => {
            floatText.destroy();
        }
    });
}
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons - A Cruzada da Rainha</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000008c7;
    }
    canvas {
      display: block;
      margin: auto;
    }
    /* Styles for the Level Up/Card Selection Menu */
    .menu-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .menu-container {
      background-color: #333;
      border: 2px solid #555;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      color: #FFF;
      width: 80%;
      max-width: 900px;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
    }
    .menu-title {
      font-size: 36px;
      margin-bottom: 20px;
      color: #00FFFF;
    }
    .cards-container {
      display: flex;
      justify-content: space-around;
      gap: 20px;
      flex-wrap: wrap;
    }
    .card {
      background-color: #222;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 15px;
      width: 250px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: left;
      min-height: 220px; /* Ensures consistent height */
      position: relative;
    }
    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 5px 20px rgba(0, 255, 255, 0.5);
    }
    .card.selected {
      border-color: #00FFFF;
      box-shadow: 0 0 25px rgba(0, 255, 255, 0.9);
    }
    .card-title {
      font-size: 22px;
      margin-bottom: 5px;
      color: #FFD700;
      text-align: center;
      width: 100%;
    }
    .card-description {
      font-size: 14px;
      color: #CCC;
      flex-grow: 1; /* Pushes button to bottom */
    }
    .card-button {
      background-color: #008CBA;
      color: white;
      padding: 10px 15px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 15px;
    }
    .card-button:hover {
      background-color: #005F7F;
    }
    .card-rarity {
        font-size: 12px;
        font-style: italic;
        margin-top: 5px;
        margin-bottom: 10px;
        width: 100%;
        text-align: center;
    }

    /* Shop Menu Styles */
    .shop-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .shop-container {
      background-color: #333;
      border: 2px solid #555;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      color: #FFF;
      width: 80%;
      max-width: 900px;
      box-shadow: 0 0 15px rgba(255, 165, 0, 0.7);
    }
    .shop-title {
      font-size: 36px;
      margin-bottom: 20px;
      color: #FFA500;
    }
    .shop-items-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .shop-item {
      background-color: #222;
      border: 1px solid #444;
      border-radius: 8px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: left;
    }
    .shop-item-name {
      font-size: 18px;
      color: #FFD700;
      margin-bottom: 5px;
    }
    .shop-item-desc {
      font-size: 13px;
      color: #CCC;
      flex-grow: 1;
      margin-bottom: 10px;
    }
    .shop-item-cost {
      font-size: 16px;
      color: #00FF00;
      margin-top: auto; /* Push to bottom */
    }
    .shop-item-button {
      background-color: #28a745;
      color: white;
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-top: 10px;
    }
    .shop-item-button:disabled {
      background-color: #555;
      cursor: not-allowed;
    }
    .shop-close-button {
      background-color: #dc3545;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 18px;
      margin-top: 20px;
    }
    .shop-close-button:hover {
      background-color: #c82333;
    }
    .shop-currency-display {
      font-size: 24px;
      color: #FFD700;
      margin-bottom: 15px;
    }

    /* Pause Menu Styles */
    .pause-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1100;
    }
    .pause-container {
      background-color: #222;
      border: 2px solid #666;
      padding: 15px;
      border-radius: 10px;
      text-align: center;
      color: #FFF;
      width: 90%;
      height: 80%;
      max-width: 1000px;
      box-shadow: 0 0 20px rgba(128, 0, 128, 0.7);
      display: flex;
      flex-direction: column;
    }
    .pause-title {
      font-size: 48px;
      margin-bottom: 25px;
      color: #9932CC;
    }
    .pause-tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
      gap: 10px;
    }
    .pause-tab-button {
      background-color: #444;
      color: #FFF;
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 18px;
      transition: background-color 0.2s;
    }
    .pause-tab-button:hover {
      background-color: #666;
    }
    .pause-tab-button.active {
      background-color: #9932CC;
      font-weight: bold;
    }
    .pause-content {
      background-color: #333;
      padding: 20px;
      border-radius: 8px;
      text-align: left;
      min-height: 290px;
      max-height: 600px;
      overflow-y: auto;
      margin-bottom: 10px;
    }
    .pause-close-button {
      background-color: #8A2BE2;
      color: white;
      padding: 12px 25px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 20px;
      margin-top: 15px;
    }
    .pause-close-button:hover {
      background-color: #6A1BA0;
    }

    /* Specific Tab Styles */
    #stats-tab-content p {
      margin-bottom: 8px;
      font-size: 18px;
    }
    #stats-tab-content strong {
      color: #00FFFF;
    }

    .skill-category {
      margin-bottom: 20px;
      border: 1px solid #555;
      padding: 15px;
      border-radius: 8px;
      background-color: #2b2b2b;
    }
    .skill-category-title {
      font-size: 24px;
      color: #FFD700;
      margin-bottom: 10px;
      text-align: center;
    }
    .skill-talent {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px dotted #444;
    }
    .skill-talent:last-child {
      border-bottom: none;
    }
    .skill-talent-info {
      flex-grow: 1;
    }
    .skill-talent-name {
      font-size: 18px;
      color: #00FFFF;
    }
    .skill-talent-desc {
      font-size: 14px;
      color: #BBB;
    }
    .skill-talent-level {
      font-size: 16px;
      color: #FFF;
      margin-left: 10px;
    }
    .skill-talent-button {
      background-color: #28a745;
      color: white;
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-left: 15px;
    }
    .skill-talent-button:disabled {
      background-color: #555;
      cursor: not-allowed;
    }
    .skill-points-display {
      font-size: 20px;
      color: #FFD700;
      margin-bottom: 15px;
      text-align: center;
    }

    #quests-tab-content .quest-item {
        margin-bottom: 10px;
        padding: 10px;
        border: 1px solid #555;
        border-radius: 5px;
        background-color: #2b2b2b;
    }
    #quests-tab-content .quest-title {
        font-size: 18px;
        color: #00FFFF;
        margin-bottom: 5px;
    }
    #quests-tab-content .quest-desc {
        font-size: 14px;
        color: #BBB;
    }
    #quests-tab-content .quest-progress {
        font-size: 14px;
        color: #99FF99;
    }
    #quests-tab-content .quest-reward {
        font-size: 14px;
        color: #FFD700;
    }
    #achievements-tab-content .achievement-item {
        margin-bottom: 10px;
        padding: 10px;
        border: 1px solid #555;
        border-radius: 5px;
        background-color: #2b2b2b;
    }
    #achievements-tab-content .achievement-title {
        font-size: 18px;
        color: #FFD700;
        margin-bottom: 5px;
    }
    #achievements-tab-content .achievement-desc {
        font-size: 14px;
        color: #BBB;
    }
    #achievements-tab-content .achievement-status {
        font-size: 14px;
        font-weight: bold;
    }
    #achievements-tab-content .unlocked {
        color: #00FF00;
    }
    #achievements-tab-content .locked {
        color: #FF0000;
    }
    
    /* --- Estilos da Oficina (Crafting) --- */
    #crafting-tab-content .crafting-recipe {
        margin-bottom: 15px;
        padding: 15px;
        border: 1px solid #6c5ce7;
        border-radius: 8px;
        background-color: #2d3436;
    }
    #crafting-tab-content .recipe-title {
        font-size: 20px;
        color: #a29bfe;
        margin-bottom: 5px;
    }
    #crafting-tab-content .recipe-desc {
        font-size: 14px;
        color: #b2bec3;
        margin-bottom: 10px;
    }
    .crafting-materials {
        list-style: none;
        padding: 0;
        margin-bottom: 10px;
        font-size: 14px;
    }
    .crafting-materials li {
        color: #fdcb6e;
    }
    .crafting-materials li.missing {
        color: #ff7675;
    }
    #crafting-tab-content .crafting-button {
        background-color: #00b894;
        color: white;
        padding: 8px 15px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
    }
    #crafting-tab-content .crafting-button:disabled {
        background-color: #555;
        cursor: not-allowed;
    }
  </style>
</head>
<body>
<div id="game-container"></div>
<script>
// --- Game Configuration ---
const config = {
  type: Phaser.AUTO,
  width: 1320,
  height: 590,
  backgroundColor: '#000000',
  parent: 'game-container', // Attach to the div
  physics: {
    default: 'arcade',
    arcade: { debug: false, gravity: { y: 0 } }
  },
  scene: { preload, create, update }
};

// --- Centralized Game Balance & Config ---
const GAME_CONFIG = {
    PLAYER: {
        INITIAL_SCALE: 0.08,
        DEFAULT_TINT: 0xFFFFFF,
        DASH_DURATION: 150, DASH_DISTANCE: 300, DASH_COOLDOWN_BASE: 3000,
        ACCELERATION: 2000, DRAG: 0.6,
        BASE_MAGNET_RANGE: 200,
        BASE_PIERCING: 1,
    },
    BULLET: { INITIAL_SPEED: 900, INITIAL_SCALE: 0.01, INITIAL_RANGE: 1 },
    WAVE: {
        INITIAL_ENEMY_COUNT: 15,
        ENEMY_INCREMENT_PER_WAVE: 5,
        INITIAL_SPAWN_RATE: 1000, //ms
        SPAWN_RATE_DECREASE_PER_WAVE: 80,
        MAX_ENEMIES_ON_SCREEN: 200
    },
    CAMERA_SHAKE: {
        PLAYER_HIT: { DURATION: 100, INTENSITY: 0.01 },
        METEOR_IMPACT: { DURATION: 150, INTENSITY: 0.008 }
    }
};

// --- Global Variables (Game Objects & State) ---
let player, cursors;
let bullets, enemies, enemyBullets, armas, itemsGroup, destructiblesGroup, dronesGroup, meteorsGroup;
let hud;
let playerOriginalTint = GAME_CONFIG.PLAYER.DEFAULT_TINT;
let currentWeapon = 1;
let gamePaused = false, levelUpMenuOpen = false, shopMenuOpen = false, pauseMenuOpen = false;
let lastShoot = 0;
let lastEnemySpawn = 0;
let nearestEnemy = null;
let waveNumber = 1;
let enemiesInWave = GAME_CONFIG.WAVE.INITIAL_ENEMY_COUNT;
let enemiesSpawnedThisWave = 0;
let enemySpawnRate = GAME_CONFIG.WAVE.INITIAL_SPAWN_RATE;
let killStreak = 0;
let killStreakTimer;
let killStreakText;
let xpGemsGroup; // Novo: Grupo de Gemas de XP

// --- Player Stats & Inventory ---
let playerStats = {
    life: 5, maxLife: 5,
    bulletDamage: 2,
    bulletPiercing: GAME_CONFIG.PLAYER.BASE_PIERCING,
    bulletRange: GAME_CONFIG.BULLET.INITIAL_RANGE,
    bulletSpeed: GAME_CONFIG.BULLET.INITIAL_SPEED,
    fireRate: 350,
    playerSpeed: 260,
    xp: 0,
    level: 1,
    xpToNextLevel: 50,
    magnetRange: GAME_CONFIG.PLAYER.BASE_MAGNET_RANGE,
    dashAvailable: false,
    dashCooldown: false,
    dashTimer: null,
    doubleBullets: false,
    healOnKill: false,
    lifestealOnKill: 0,
    incomingDamageMultiplier: 1.0,
    touchDamage: 0,
    currency: 0,
    rareParts: 0, // Moeda rara
    skillPoints: 0,
    droneActive: false,
    poisonTrail: false,
    lumirenTeleport: false,
    metalionEchoActive: false,
    pactoDemonioActive: false,
    statusEffects: { /* Implementar posteriormente */ },
    skillTree: {
        forca: {
            DanoBase: { level: 0, max: 5, custo: 1, efeito: () => playerStats.bulletDamage += 1, desc: "Aumenta o dano base dos projéteis." },
            Perfuracao: { level: 0, max: 3, custo: 1, efeito: () => playerStats.bulletPiercing += 1, desc: "Projéteis perfuram mais inimigos." }
        },
        agilidade: {
            VelocidadeMovimento: { level: 0, max: 5, custo: 1, efeito: () => playerStats.playerSpeed += 50, desc: "Aumenta a velocidade de movimento." },
            RitmoDeFogo: { level: 0, max: 5, custo: 1, efeito: () => playerStats.fireRate = Math.max(50, playerStats.fireRate * 0.9), desc: "Reduz o tempo entre os tiros (mais rápido)." }
        },
        constituicao: {
            VidaMaxima: { level: 0, max: 5, custo: 1, efeito: () => { playerStats.maxLife++; playerStats.life++; hud.updateHealthBar(); }, desc: "Aumenta a vida máxima e cura totalmente." },
            ReducaoDano: { level: 0, max: 5, custo: 1, efeito: () => playerStats.incomingDamageMultiplier *= 0.9, desc: "Reduz o dano recebido em 10% por nível." }
        },
        inteligencia: {
            AnaliseDeAmeaca: { level: 0, max: 1, custo: 2, efeito: () => playerStats.analiseDeAmeaca = true, desc: "Ameaças no Mini-Mapa em vermelho." },
            DanoDeToque: { level: 0, max: 3, custo: 1, efeito: () => playerStats.touchDamage += 0.5, desc: "Causa dano por toque a inimigos próximos." }
        }
    }
};

let playerInventory = {
    passives: [],
    actives: [],
    setBonuses: {}
};

// --- Enemy Types ---
const enemyTypes = {
    normal: { texture: 'enemy_robot', baseHealth: 2, speed: 90, scale: 0.06, xpValue: 5, currencyReward: 5, attacks: ['melee'] },
    fast: { texture: 'enemy_fast', baseHealth: 1.2, speed: 150, scale: 0.06, xpValue: 6, currencyReward: 6, attacks: ['melee'] },
    tank: { texture: 'enemy_tank', baseHealth: 6, speed: 50, scale: 0.07, xpValue: 12, currencyReward: 10, attacks: ['melee'] },
    suicide: { texture: 'enemy_suicide', baseHealth: 0.5, speed: 100, scale: 0.05, xpValue: 8, currencyReward: 8, attacks: ['explode'] },
    shooter: { texture: 'enemy_shooter', baseHealth: 3, speed: 60, scale: 0.07, xpValue: 15, currencyReward: 15, attacks: ['ranged'] }
};

// --- Items & Rarity ---
const itemRarities = {
    common: { color: '#FFFFFF' },
    rare: { color: '#00BFFF' },
    epic: { color: '#FFD700' },
    legendary: { color: '#FF4500' }
};

const itemOptions = [
    { nome: "Projétil Perfurante", descricao: "Balas atravessam +1 inimigo", tipo: "passivo", textura: "ammo", efeito: () => playerStats.bulletPiercing += 1, peso: 1, rarity: 'rare' },
    { nome: "Pele Reforçada", descricao: "+1 Vida Máxima", tipo: "passivo", textura: "ammo", efeito: () => { playerStats.maxLife++; playerStats.life++; hud.updateHealthBar(); }, peso: 1, rarity: 'rare' },
    { nome: "Tiro Duplo", descricao: "Dispara um segundo projétil", tipo: "passivo", textura: "ammo", efeito: () => playerStats.doubleBullets = true, peso: 0.5, rarity: 'epic' },
    { nome: "Módulo de Dash", descricao: "Habilita a habilidade de Dash (Espaço)", tipo: "passivo", textura: "ammo", efeito: (scene) => { if(!playerStats.dashAvailable) { playerStats.dashAvailable = true; scene.input.keyboard.on('keydown-SPACE', () => { if (!gamePaused && playerStats.dashAvailable) performDash.call(scene, scene); }); } }, peso: 0.5, rarity: 'epic' },
    { nome: "Núcleo de Dano", descricao: "+20% Dano", tipo: "passivo", textura: "ammo", efeito: () => playerStats.bulletDamage *= 1.2, peso: 1, rarity: 'common' },
    { nome: "Sistema de Resfriamento", descricao: "+10% Velocidade de Ataque", tipo: "passivo", textura: "ammo", efeito: () => { playerStats.fireRate = Math.max(50, playerStats.fireRate * 0.9); }, peso: 1, rarity: 'common' },
    { nome: "Módulo de Salto (Ativável)", descricao: "Permite usar Dash.", tipo: "ativavel", textura: "ammo", cooldown: 5000, efeito: (scene) => { playerStats.dashAvailable = true; }, peso: 1, rarity: 'common' },
    { nome: "Corrente Eletrostática (Passivo)", descricao: "Bala perfurante.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.bulletPiercing += 1; }, peso: 1, rarity: 'common' },
    { nome: "Absorção de Energia (Passivo)", descricao: "Cura 0.5 de vida ao matar um inimigo.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.healOnKill = true; playerStats.lifestealOnKill += 0.5; }, peso: 1, rarity: 'rare' },
    { nome: "Campo de Distorção (Ativável)", descricao: "Cria zona segura por um tempo.", tipo: "ativavel", textura: "ammo", cooldown: 15000, efeito: (scene) => { playerStats.safeZoneActive = true; scene.time.delayedCall(5000, () => { playerStats.safeZoneActive = false; }); }, peso: 1, rarity: 'rare' },
    // Itens de Conjunto (Exemplos)
    { nome: "Armadura Reconstruída (Passivo)", descricao: "+1 Vida Máxima. Parte do conjunto 'Defesa Robusta'.", tipo: "passivo", textura: "ammo", efeito: () => playerStats.maxLife++, peso: 1, rarity: 'rare', set: 'Defesa Robusta' },
    { nome: "Bateria de Nêutrons (Passivo)", descricao: "Dash tem cooldown 10% menor. Parte do conjunto 'Defesa Robusta'.", tipo: "passivo", textura: "ammo", efeito: () => GAME_CONFIG.PLAYER.DASH_COOLDOWN_BASE *= 0.9, peso: 1, rarity: 'rare', set: 'Defesa Robusta' },
    // Itens de Debuff/High Risk (Exemplos)
    { nome: "Coração Fraturado de Basilisco", descricao: "+5% dano, -2 vida máxima, tiros deixam veneno.", tipo: "passivo", textura: "ammo", efeito: (scene) => { playerStats.bulletDamage *= 1.05; playerStats.maxLife = Math.max(1, playerStats.maxLife - 2); playerStats.life = Math.min(playerStats.life, playerStats.maxLife); scene.hud.updateHealthBar(); playerStats.poisonTrail = true; }, peso: 0.1, rarity: 'legendary' }
];

const setBonuses = {
    "Defesa Robusta": {
        items: ["Armadura Reconstruída (Passivo)", "Bateria de Nêutrons (Passivo)", "Armadura Reforçada (Passivo)"], // Supondo um terceiro item
        count: 2,
        effect: (scene) => { playerStats.incomingDamageMultiplier *= 0.85; scene.hud.displayTemporaryEffect('Bônus de Conjunto: Ataque Cibernético!', '#FF8C00', 2000); },
        bonusApplied: false
    }
};

const shopItems = [
    { nome: "Upgrade de Dano", descricao: "Aumenta o dano permanentemente em +1.", custo: 50, maxPurchases: 5, purchasedCount: 0, efeito: () => playerStats.bulletDamage += 1 },
    { nome: "Núcleo de Vida", descricao: "Aumenta a vida máxima em +1.", custo: 75, maxPurchases: 3, purchasedCount: 0, efeito: () => { playerStats.maxLife++; playerStats.life++; } },
    { nome: "Peça Rara", descricao: "Compra 1 Peça Rara (moeda de crafting)", custo: 100, maxPurchases: Infinity, purchasedCount: 0, efeito: () => playerStats.rareParts += 1 }
];

const craftingRecipes = [
    { id: 'revive_core', nome: "Núcleo de Reviver", descricao: "Permite reviver uma vez por jogo.", materiais: { rareParts: 3, currency: 50 }, crafted: false, maxCrafts: 1 },
    { id: 'drone_module', nome: "Módulo de Drone", descricao: "Libera o uso de Drones.", materiais: { rareParts: 5, currency: 100 }, crafted: false, maxCrafts: 1 }
];

const quests = [
    { id: 'kill50', title: 'Caçador Iniciante', desc: 'Derrote 50 inimigos.', target: 50, current: 0, completed: false, reward: { currency: 20 } },
    { id: 'reachWave5', title: 'Sobrevivente Júnior', desc: 'Alcance a Onda 5.', target: 5, current: 1, completed: false, reward: { currency: 50, rareParts: 1 } }
];

const achievements = {
    'FirstKill': { unlocked: false, description: "Derrote seu primeiro inimigo." },
    'Wave10': { unlocked: false, description: "Sobreviva até a Onda 10." },
    'MaxStats': { unlocked: false, description: "Alcance o nível máximo em uma habilidade." }
};


// --- HUD Class ---
class HUD extends Phaser.GameObjects.Container {
    constructor(scene) {
        super(scene, 0, 0);
        scene.add.existing(this);
        this.setDepth(1000);

        // Life Display
        this.lifeText = scene.add.text(10, 10, "", { fontSize: 20, fill: "#FF0000" });
        this.add(this.lifeText);

        // Level Display
        this.levelText = scene.add.text(10, 50, "", { fontSize: 20, fill: "#FFFF00" });
        this.add(this.levelText);

        // XP Bar
        this.xpBar = scene.add.graphics();
        this.add(this.xpBar);
        this.xpText = scene.add.text(10, 75, "", { fontSize: 14, fill: "#00FF00" });
        this.add(this.xpText);

        // Currency/Scrap Display
        this.currencyText = scene.add.text(config.width - 150, 10, "", { fontSize: 20, fill: "#00BFFF" }).setOrigin(1, 0);
        this.add(this.currencyText);

        // Rare Parts Display
        this.rarePartsText = scene.add.text(config.width - 150, 40, "", { fontSize: 16, fill: "#FFD700" }).setOrigin(1, 0);
        this.add(this.rarePartsText);

        // Wave Info
        this.waveText = scene.add.text(config.width / 2, 10, "", { fontSize: 24, fill: "#00FFFF" }).setOrigin(0.5, 0);
        this.add(this.waveText);

        // Kill Streak Display
        killStreakText = scene.add.text(config.width / 2, 50, 'Combo x0', { fontSize: 28, fill: '#FF4500', stroke: '#FFFFFF', strokeThickness: 4 }).setOrigin(0.5).setVisible(false);
        this.add(killStreakText);

        // Temporary Effect Text
        this.tempEffectText = scene.add.text(config.width / 2, 90, '', { fontSize: 28, fill: '#FF4500', align: 'center', stroke: '#FFFFFF', strokeThickness: 6 }).setOrigin(0.5).setDepth(2000).setVisible(false);
        this.add(this.tempEffectText);

        this.updateHealthBar();
        this.updateXpBar();
        this.updateLevelDisplay();
        this.updateCurrencyDisplay();
        this.updateRarePartsDisplay();
    }

    updateHealthBar() {
        this.lifeText.setText('Vida: ' + Math.ceil(playerStats.life) + '/' + playerStats.maxLife);
    }

    updateXpBar() {
        this.xpBar.clear();
        const xpBarWidth = 200;
        const xpBarHeight = 15;
        const currentXpRatio = playerStats.xp / playerStats.xpToNextLevel;

        this.xpBar.fillStyle(0x555555);
        this.xpBar.fillRect(10, 20 + 20, xpBarWidth, xpBarHeight);
        
        this.xpBar.fillStyle(0x00FF00);
        this.xpBar.fillRect(10, 20 + 20, xpBarWidth * currentXpRatio, xpBarHeight);

        this.xpText.setText(`XP: ${playerStats.xp} / ${playerStats.xpToNextLevel}`);
    }

    updateLevelDisplay() {
        this.levelText.setText(`Nível: ${playerStats.level}`);
    }
    
    updateWaveDisplay() {
        this.waveText.setText(`Onda: ${waveNumber}`);
    }

    updateCurrencyDisplay() {
        this.currencyText.setText(`Sucata: ${playerStats.currency}`);
    }

    updateRarePartsDisplay() {
        this.rarePartsText.setText(`Peças Raras: ${playerStats.rareParts}`);
    }

    displayTemporaryEffect(text, color, duration) {
        this.tempEffectText.setText(text);
        this.tempEffectText.setFill(color);
        this.tempEffectText.setVisible(true);
        this.scene.time.delayedCall(duration, () => {
            this.tempEffectText.setVisible(false);
        });
    }

    updateAll() {
        this.updateHealthBar();
        this.updateXpBar();
        this.updateLevelDisplay();
        this.updateWaveDisplay();
        this.updateCurrencyDisplay();
        this.updateRarePartsDisplay();
    }
}

// --- Scene Functions ---
function preload() {
    // Carregar todos os assets (Presume-se que existam na pasta 'assets')
    this.load.image('player', 'assets/player.png');
    this.load.image('bullet', 'assets/bullet.png');
    this.load.image('enemy_robot', 'assets/enemy_robot.png');
    this.load.image('enemy_fast', 'assets/enemy_fast.png');
    this.load.image('enemy_tank', 'assets/enemy_tank.png');
    this.load.image('enemy_suicide', 'assets/enemy_suicide.png');
    this.load.image('enemy_shooter', 'assets/enemy_shooter.png');
    this.load.image('ammo', 'assets/ammo.png'); // Usado para gemas de XP e itens
    this.load.image('drone_attack', 'assets/drone_attack.png');
    this.load.image('meteor', 'assets/meteor.png');
}

function create() {
    // Initialize Game State
    playerStats = {
        // Resetting all stats to initial values for a new game
        ...playerStats, // Keep base stats structure
        life: 5, maxLife: 5, xp: 0, level: 1, xpToNextLevel: 50, currency: 0, rareParts: 0, skillPoints: 0,
        bulletDamage: 2, bulletPiercing: GAME_CONFIG.PLAYER.BASE_PIERCING, fireRate: 350, playerSpeed: 260,
        dashAvailable: false, dashCooldown: false, doubleBullets: false, healOnKill: false, incomingDamageMultiplier: 1.0, touchDamage: 0, droneActive: false, poisonTrail: false, lumirenTeleport: false, metalionEchoActive: false, pactoDemonioActive: false,
    };
    playerInventory = { passives: [], actives: [], setBonuses: {} };
    waveNumber = 1; enemiesInWave = GAME_CONFIG.WAVE.INITIAL_ENEMY_COUNT; enemiesSpawnedThisWave = 0; enemySpawnRate = GAME_CONFIG.WAVE.INITIAL_SPAWN_RATE;

    // Player Setup
    player = this.physics.add.sprite(config.width/2, config.height/2, 'player')
      .setScale(GAME_CONFIG.PLAYER.INITIAL_SCALE)
      .setCollideWorldBounds(true)
      .setDrag(GAME_CONFIG.PLAYER.DRAG)
      .setMaxVelocity(playerStats.playerSpeed);
    
    playerOriginalTint = GAME_CONFIG.PLAYER.DEFAULT_TINT;

    // Input Setup
    cursors = this.input.keyboard.createCursorKeys();
    this.keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);
    this.keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
    this.keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
    this.keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);
    this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
    this.keyP = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.P);
    this.keyK = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.K); // Key for shop test

    this.keyP.on('down', () => { if (!levelUpMenuOpen && !shopMenuOpen) togglePauseMenu.call(this); });
    this.keyK.on('down', () => { if (!gamePaused) toggleShopMenu.call(this); });

    // Groups Setup
    bullets = this.physics.add.group({ classType: Bullet, runChildUpdate: true, maxSize: 50 });
    enemies = this.physics.add.group({ classType: Enemy, runChildUpdate: true, maxSize: 100 });
    xpGemsGroup = this.physics.add.group({ classType: XPGem, runChildUpdate: true, maxSize: 200 });
    enemyBullets = this.physics.add.group({ classType: EnemyBullet, runChildUpdate: true, maxSize: 50 });
    dronesGroup = this.physics.add.group({ runChildUpdate: true, maxSize: 5 });
    meteorsGroup = this.physics.add.group({ classType: Meteor, runChildUpdate: true, maxSize: 10 });

    // Colliders/Overlaps
    this.physics.add.overlap(bullets, enemies, bulletHitEnemy, null, this);
    this.physics.add.overlap(player, xpGemsGroup, collectGem, null, this);
    this.physics.add.collider(player, enemies, playerHitEnemy, null, this);
    this.physics.add.overlap(player, enemyBullets, playerHitEnemyBullet, null, this);
    this.physics.add.collider(meteorsGroup, enemies, meteorHitEnemy, null, this);

    // HUD Setup
    hud = new HUD(this);
    hud.updateAll();

    // Spawner Setup
    this.spawner = this.time.addEvent({
        delay: enemySpawnRate,
        callback: spawnEnemy,
        callbackScope: this,
        loop: true,
        id: 'spawner'
    });
}

function update(time, delta) {
    if (gamePaused || levelUpMenuOpen || shopMenuOpen || pauseMenuOpen) return;

    // Movimentação (Estilo VS - Joystick Virtual ou Teclado)
    player.setAcceleration(0);
    if (cursors.left.isDown || this.keyA.isDown) player.setAccelerationX(-GAME_CONFIG.PLAYER.ACCELERATION);
    else if (cursors.right.isDown || this.keyD.isDown) player.setAccelerationX(GAME_CONFIG.PLAYER.ACCELERATION);

    if (cursors.up.isDown || this.keyW.isDown) player.setAccelerationY(-GAME_CONFIG.PLAYER.ACCELERATION);
    else if (cursors.down.isDown || this.keyS.isDown) player.setAccelerationY(GAME_CONFIG.PLAYER.ACCELERATION);
    
    // Auto-Targeting and Shooting
    nearestEnemy = findNearestEnemy();
    if (nearestEnemy && time > lastShoot) {
        shootBullet.call(this, nearestEnemy);
        lastShoot = time + playerStats.fireRate;
    }

    // XP Gem Magnetism
    xpGemsGroup.children.each(gem => {
        if (!gem.active) return;
        const d = Phaser.Math.Distance.Between(player.x, player.y, gem.x, gem.y);
        if (d < playerStats.magnetRange) {
            this.physics.moveToObject(gem, player, 600);
        }
    });

    // Wave Progression Check
    if (enemiesSpawnedThisWave >= enemiesInWave && enemies.countActive(true) === 0) {
        startNextWave.call(this);
    }
}

// --- Gameplay Functions ---

function findNearestEnemy() {
    let minDist = Infinity, target = null;
    enemies.children.each(enemy => {
        if (!enemy.active) return;
        const d = Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y);
        if (d < minDist) { minDist = d; target = enemy; }
    });
    return target;
}

function shootBullet(target) {
    const angleRad = Phaser.Math.Angle.Between(player.x, player.y, target.x, target.y);
    const baseBulletCount = playerStats.doubleBullets ? 2 : 1;
    const bulletSpeed = playerStats.bulletSpeed;

    for (let i = 0; i < baseBulletCount; i++) {
        let offsetAngle = 0;
        if (baseBulletCount > 1) {
             offsetAngle = Phaser.Math.DEG_TO_RAD * ((i - (baseBulletCount - 1) / 2) * 10);
        }
        
        const bullet = bullets.get(player.x, player.y, 'bullet');
        if (bullet) {
            bullet.fire(angleRad + offsetAngle, playerStats.bulletDamage, playerStats.bulletPiercing, playerStats.bulletRange);
            this.physics.velocityFromRotation(angleRad + offsetAngle, bulletSpeed, bullet.body.velocity);
            
            // Apply status effects from items
            if (playerStats.poisonTrail) {
                bullet.addStatusEffect = { type: 'poisoned', duration: 3000, damagePerTick: 0.2 };
            }
        }
    }
}

function bulletHitEnemy(b, e) {
    if (!b.active || !e.active) return;

    e.takeDamage(b.damage);
    
    // Apply status effects
    if (b.addStatusEffect) {
        e.applyStatus(b.addStatusEffect.type, b.addStatusEffect.duration, b.addStatusEffect.damagePerTick);
    }

    b.piercing--;
    if (b.piercing <= 0) b.kill();

    if (e.health <= 0) {
        handleEnemyDeath.call(this, e);
    }
}

function playerHitEnemy() {
    if (!player.active) return;
    
    // Dano de toque (se houver)
    enemies.children.each(enemy => {
        if (this.physics.world.overlap(player, enemy)) {
            if (playerStats.touchDamage > 0) {
                enemy.health -= playerStats.touchDamage;
                if (enemy.health <= 0) handleEnemyDeath.call(this, enemy);
            }
            
            // Enemy Explode Logic
            if (enemy.enemyType.attacks.includes('explode')) {
                enemy.health = 0;
                handleEnemyDeath.call(this, enemy);
                playerTakeDamage.call(this, 2);
                this.hud.displayTemporaryEffect('Dano de Explosão!', '#FF0000', 1000);
            }
        }
    });

    playerTakeDamage.call(this, 1);
}

function playerHitEnemyBullet(p, eb) {
    if (!p.active || !eb.active) return;
    playerTakeDamage.call(this, eb.damage);
    eb.kill();
}

function playerTakeDamage(baseDamage) {
    if (!player.active) return;
    
    const damage = Math.max(1, baseDamage * playerStats.incomingDamageMultiplier);
    playerStats.life -= damage;
    this.cameras.main.shake(GAME_CONFIG.CAMERA_SHAKE.PLAYER_HIT.DURATION, GAME_CONFIG.CAMERA_SHAKE.PLAYER_HIT.INTENSITY);

    hud.updateHealthBar();

    if (playerStats.life <= 0) {
        // Check for 'Revive Core' crafting recipe
        const reviveCore = craftingRecipes.find(r => r.id === 'revive_core');
        if (reviveCore && reviveCore.crafted && reviveCore.maxCrafts > 0) {
            playerStats.life = playerStats.maxLife;
            reviveCore.maxCrafts--; // Use the one-time revive
            this.hud.updateHealthBar();
            this.hud.displayTemporaryEffect('Revivido!', '#00FF00', 2000);
        } else {
            gameOver.call(this);
        }
    }
}

function handleEnemyDeath(enemy) {
    if (!enemy.active) return;
    
    gainXp.call(this, enemy.xpReward);
    playerStats.currency += enemy.currencyReward || 5;
    this.hud.updateCurrencyDisplay();
    startKillStreak.call(this);
    updateQuestProgress.call(this, 'kill50', 1);

    dropGem(enemy.x, enemy.y, enemy.xpReward);
    
    // Lifesteal/Heal on Kill
    if (playerStats.healOnKill) {
        playerStats.life = Math.min(playerStats.maxLife, playerStats.life + playerStats.lifestealOnKill);
        this.hud.updateHealthBar();
    }
    
    // Achievement Check
    if (!playerStats.achievements.FirstKill.unlocked) unlockAchievement.call(this, 'FirstKill');

    enemy.kill();
}

function spawnEnemy() {
    if (enemies.countActive() >= GAME_CONFIG.WAVE.MAX_ENEMIES_ON_SCREEN || enemiesSpawnedThisWave >= enemiesInWave) return;
    
    enemiesSpawnedThisWave++;

    // Spawning logic (off-screen)
    let x, y;
    if (Math.random() < 0.5) { // Spawn on X edges
        x = (Math.random() < 0.5) ? -50 : config.width + 50;
        y = Phaser.Math.Between(50, config.height - 50);
    } else { // Spawn on Y edges
        x = Phaser.Math.Between(50, config.width - 50);
        y = (Math.random() < 0.5) ? -50 : config.height + 50;
    }
    
    // Select enemy type based on wave number
    let enemyTypeKey = 'normal';
    const availableEnemyTypes = [
        { type: 'normal', weight: 1.0 },
        { type: 'fast', weight: waveNumber >= 3 ? 0.4 : 0 },
        { type: 'tank', weight: waveNumber >= 5 ? 0.2 : 0 },
        { type: 'suicide', weight: waveNumber >= 7 ? 0.15 : 0 },
        { type: 'shooter', weight: waveNumber >= 10 ? 0.1 : 0 }
    ];
    
    const totalWeight = availableEnemyTypes.reduce((sum, t) => sum + t.weight, 0);
    let rand = Math.random() * totalWeight;
    for (const type of availableEnemyTypes) {
        if (rand < type.weight) {
            enemyTypeKey = type.type;
            break;
        }
        rand -= type.weight;
    }

    const data = enemyTypes[enemyTypeKey];
    const enemy = enemies.get(x, y);
    if (enemy) enemy.spawn(data);
}

function dropGem(x, y, xp) {
    const g = xpGemsGroup.get(x, y, 'ammo'); // Use 'ammo' texture for gem
    if (g) g.spawn(xp);
}

function collectGem(p, g) {
    gainXp.call(this, g.xpValue);
    g.kill();
}

function gainXp(amount) {
    playerStats.xp += amount;
    hud.updateXpBar();

    if (playerStats.xp >= playerStats.xpToNextLevel) {
        playerStats.level++;
        playerStats.xp -= playerStats.xpToNextLevel;
        playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.5); // XP Curve
        playerStats.skillPoints += 1;
        
        hud.displayTemporaryEffect(`Level Up! Nível ${playerStats.level}`, '#FFFF00', 3000);
        hud.updateAll();
        
        showLevelUpMenu.call(this);
    }
}

function performDash(scene) {
    if (playerStats.dashCooldown) return;

    playerStats.dashCooldown = true;
    
    // Determine dash direction
    let angle = 0;
    if (player.body.velocity.x !== 0 || player.body.velocity.y !== 0) {
        angle = Phaser.Math.Angle.Between(0, 0, player.body.velocity.x, player.body.velocity.y);
    } else {
        // Default to current direction or a safe direction if standing still (e.g., right)
        angle = player.rotation; 
    }

    // Set temporary velocity for dash
    scene.physics.velocityFromRotation(angle, GAME_CONFIG.PLAYER.DASH_DISTANCE / (GAME_CONFIG.PLAYER.DASH_DURATION / 1000), player.body.velocity);

    // Make player invulnerable and tint during dash
    player.setTint(0x00FFFF);
    player.body.checkCollision.none = true;

    // Dash End Timer
    scene.time.delayedCall(GAME_CONFIG.PLAYER.DASH_DURATION, () => {
        player.setTint(playerOriginalTint);
        player.body.checkCollision.none = false;
        player.setVelocity(0); // Stop dash velocity
        playerStats.dashTimer = scene.time.delayedCall(GAME_CONFIG.PLAYER.DASH_COOLDOWN_BASE, () => {
            playerStats.dashCooldown = false;
            scene.hud.displayTemporaryEffect('Dash Recarregado!', '#00FF00', 1000);
        });
    });
}

function startNextWave() {
    waveNumber++;
    enemiesInWave += GAME_CONFIG.WAVE.ENEMY_INCREMENT_PER_WAVE;
    enemiesSpawnedThisWave = 0;
    enemySpawnRate = Math.max(200, enemySpawnRate - GAME_CONFIG.WAVE.SPAWN_RATE_DECREASE_PER_WAVE); // Min spawn rate 200ms

    this.spawner.delay = enemySpawnRate;
    this.hud.displayTemporaryEffect(`Onda ${waveNumber} Iniciada!`, '#FF00FF', 3000);
    this.hud.updateWaveDisplay();
    
    updateQuestProgress.call(this, 'reachWave5', waveNumber);

    // Check for Wave 10 achievement
    if (waveNumber >= 10 && !achievements.Wave10.unlocked) {
        unlockAchievement.call(this, 'Wave10');
    }
    
    // Show card selection menu for Wave 3, 6, 9, etc.
    if (waveNumber % 3 === 0) {
        showCardSelectionMenu.call(this);
    }
}

// --- Menu Functions ---

function showLevelUpMenu() {
    if (levelUpMenuOpen) return;
    gamePaused = true;
    levelUpMenuOpen = true;
    this.physics.pause();

    const overlay = document.createElement('div');
    overlay.className = 'menu-overlay';
    overlay.id = 'levelUpMenu';

    const container = document.createElement('div');
    container.className = 'menu-container';
    overlay.appendChild(container);

    const title = document.createElement('h2');
    title.className = 'menu-title';
    title.innerText = 'Subiu de Nível! Escolha um Upgrade:';
    container.appendChild(title);

    const cardsContainer = document.createElement('div');
    cardsContainer.className = 'cards-container';
    container.appendChild(cardsContainer);
    
    const availableItemNames = itemOptions.filter(item => {
        // Filter out items the player already has if they are passives that shouldn't stack
        // For simplicity, we assume only one passive of each name is allowed unless its effect can stack
        if (item.tipo === "passivo" && playerInventory.passives.includes(item.nome)) return false;
        return true;
    }).map(item => item.nome);
    
    // Weighted selection logic based on rarity
    const itemPool = itemOptions.filter(item => availableItemNames.includes(item.nome));
    
    const chosenCards = [];
    while (chosenCards.length < 3 && itemPool.length > 0) {
        let totalWeight = itemPool.reduce((sum, item) => {
            let weight = item.peso || 1;
            if (item.rarity === 'rare') weight *= 0.5;
            if (item.rarity === 'epic') weight *= 0.3;
            if (item.rarity === 'legendary') weight *= 0.1;
            return sum + weight;
        }, 0);

        let rand = Math.random() * totalWeight;
        for (let i = 0; i < itemPool.length; i++) {
            const item = itemPool[i];
            let weight = item.peso || 1;
            if (item.rarity === 'rare') weight *= 0.5;
            if (item.rarity === 'epic') weight *= 0.3;
            if (item.rarity === 'legendary') weight *= 0.1;
            
            if (rand < weight) {
                chosenCards.push(item);
                itemPool.splice(i, 1); // Remove from pool to prevent duplicates
                break;
            }
            rand -= weight;
        }
    }


    chosenCards.forEach(item => {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
            <h3 class="card-title">${item.nome}</h3>
            <p class="card-rarity" style="color:${itemRarities[item.rarity].color}">${item.rarity}</p>
            <p class="card-description">${item.descricao}</p>
            <button class="card-button">Selecionar</button>
        `;
        
        card.querySelector('button').onclick = () => {
            // Apply effect
            item.efeito(this);

            // Add to inventory
            if (item.tipo === 'passivo') {
                playerInventory.passives.push(item.nome);
                // Check for set bonus
                if (item.set) checkSetBonus.call(this, item.set);
            } else if (item.tipo === 'ativavel') {
                playerInventory.actives.push(item.nome);
                // Setup active item logic (not fully implemented here for brevity, typically needs a UI button/keybind)
            }


            // Close menu
            document.body.removeChild(overlay);
            levelUpMenuOpen = false;
            gamePaused = false;
            this.physics.resume();
        };
        cardsContainer.appendChild(card);
    });

    document.body.appendChild(overlay);
}

function showCardSelectionMenu() {
    // This menu is for mid-wave rewards, similar to level up
    if (levelUpMenuOpen) return;
    gamePaused = true;
    levelUpMenuOpen = true;
    this.physics.pause();

    const overlay = document.createElement('div');
    overlay.className = 'menu-overlay';
    overlay.id = 'cardSelectionMenu';

    const container = document.createElement('div');
    container.className = 'menu-container';
    overlay.appendChild(container);

    const title = document.createElement('h2');
    title.className = 'menu-title';
    title.innerText = 'Recompensa de Onda! Escolha uma carta:';
    container.appendChild(title);

    // ... (logic to pick 3 cards, similar to showLevelUpMenu, but perhaps different set of items) ...
    
    // For simplicity, reusing the level-up logic
    const cardsContainer = document.createElement('div');
    cardsContainer.className = 'cards-container';
    container.appendChild(cardsContainer);
    
    const availableItemNames = itemOptions.filter(item => {
        if (item.tipo === "passivo" && playerInventory.passives.includes(item.nome)) return false;
        return true;
    }).map(item => item.nome);
    
    const itemPool = itemOptions.filter(item => availableItemNames.includes(item.nome));
    const chosenCards = [];
    while (chosenCards.length < 3 && itemPool.length > 0) {
        const randomIndex = Phaser.Math.RND.between(0, itemPool.length - 1);
        chosenCards.push(itemPool[randomIndex]);
        itemPool.splice(randomIndex, 1);
    }


    chosenCards.forEach(item => {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
            <h3 class="card-title">${item.nome}</h3>
            <p class="card-rarity" style="color:${itemRarities[item.rarity].color}">${item.rarity}</p>
            <p class="card-description">${item.descricao}</p>
            <button class="card-button">Selecionar</button>
        `;
        
        card.querySelector('button').onclick = () => {
            item.efeito(this);
            if (item.tipo === 'passivo') playerInventory.passives.push(item.nome);

            document.body.removeChild(overlay);
            levelUpMenuOpen = false;
            gamePaused = false;
            this.physics.resume();
        };
        cardsContainer.appendChild(card);
    });
    
    document.body.appendChild(overlay);
}

function toggleShopMenu() {
    if (shopMenuOpen) {
        // Close Shop
        document.body.removeChild(document.getElementById('shopMenu'));
        shopMenuOpen = false;
        gamePaused = false;
        this.physics.resume();
    } else {
        // Open Shop
        gamePaused = true;
        shopMenuOpen = true;
        this.physics.pause();
        
        const overlay = document.createElement('div');
        overlay.className = 'shop-overlay';
        overlay.id = 'shopMenu';

        const container = document.createElement('div');
        container.className = 'shop-container';
        overlay.appendChild(container);
        
        const title = document.createElement('h2');
        title.className = 'shop-title';
        title.innerText = 'Loja de Peças e Upgrades';
        container.appendChild(title);
        
        const currencyDisplay = document.createElement('p');
        currencyDisplay.className = 'shop-currency-display';
        currencyDisplay.innerHTML = `Sucata: <strong>${playerStats.currency}</strong> | Peças Raras: <strong>${playerStats.rareParts}</strong>`;
        container.appendChild(currencyDisplay);
        
        const itemsContainer = document.createElement('div');
        itemsContainer.className = 'shop-items-container';
        container.appendChild(itemsContainer);

        shopItems.forEach(item => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'shop-item';
            
            const costText = item.maxPurchases !== Infinity ? 
                `Custo: ${item.custo} Sucata (${item.purchasedCount}/${item.maxPurchases})` : 
                `Custo: ${item.custo} Sucata`;
                
            itemDiv.innerHTML = `
                <h3 class="shop-item-name">${item.nome}</h3>
                <p class="shop-item-desc">${item.descricao}</p>
                <p class="shop-item-cost">${costText}</p>
                <button class="shop-item-button" data-item="${item.nome}">Comprar</button>
            `;
            
            const buyButton = itemDiv.querySelector('.shop-item-button');
            const canAfford = playerStats.currency >= item.custo;
            const maxReached = item.maxPurchases && item.purchasedCount >= item.maxPurchases;

            buyButton.disabled = !canAfford || maxReached;
            if (maxReached) buyButton.innerText = 'Esgotado';
            
            buyButton.onclick = () => {
                if (playerStats.currency >= item.custo && !maxReached) {
                    playerStats.currency -= item.custo;
                    item.efeito(this);
                    item.purchasedCount = (item.purchasedCount || 0) + 1;

                    // Reopen to refresh state
                    toggleShopMenu.call(this); 
                }
            };
            itemsContainer.appendChild(itemDiv);
        });
        
        const closeButton = document.createElement('button');
        closeButton.className = 'shop-close-button';
        closeButton.innerText = 'Fechar Loja';
        closeButton.onclick = () => toggleShopMenu.call(this);
        container.appendChild(closeButton);

        document.body.appendChild(overlay);
        hud.updateAll(); // Update HUD in case stats were modified
    }
}

function togglePauseMenu() {
    if (pauseMenuOpen) {
        // Close Pause Menu
        document.body.removeChild(document.getElementById('pauseMenu'));
        pauseMenuOpen = false;
        gamePaused = false;
        this.physics.resume();
    } else {
        // Open Pause Menu
        gamePaused = true;
        pauseMenuOpen = true;
        this.physics.pause();
        
        const overlay = document.createElement('div');
        overlay.className = 'pause-overlay';
        overlay.id = 'pauseMenu';

        const container = document.createElement('div');
        container.className = 'pause-container';
        overlay.appendChild(container);
        
        const title = document.createElement('h2');
        title.className = 'pause-title';
        title.innerText = 'PAUSA';
        container.appendChild(title);

        const tabsDiv = document.createElement('div');
        tabsDiv.className = 'pause-tabs';
        tabsDiv.innerHTML = `
            <button class="pause-tab-button active" data-tab="stats">Estatísticas</button>
            <button class="pause-tab-button" data-tab="skills">Árvore de Habilidades</button>
            <button class="pause-tab-button" data-tab="quests">Missões</button>
            <button class="pause-tab-button" data-tab="achievements">Conquistas</button>
            <button class="pause-tab-button" data-tab="crafting">Oficina</button>
        `;
        container.appendChild(tabsDiv);
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'pause-content';
        contentDiv.id = 'pause-content-area';
        container.appendChild(contentDiv);

        const closeButton = document.createElement('button');
        closeButton.className = 'pause-close-button';
        closeButton.innerText = 'Continuar Jogo';
        closeButton.onclick = () => togglePauseMenu.call(this);
        container.appendChild(closeButton);

        document.body.appendChild(overlay);
        
        // Setup tab switching
        const sceneContext = this;
        tabsDiv.querySelectorAll('.pause-tab-button').forEach(button => {
            button.addEventListener('click', function() {
                tabsDiv.querySelectorAll('.pause-tab-button').forEach(btn => btn.classList.remove('active'));
                this.classList.add('active');
                displayPauseMenuTab.call(sceneContext, this.dataset.tab);
            });
        });

        // Display default tab
        displayPauseMenuTab.call(this, 'stats');
    }
}

function displayPauseMenuTab(tabName) {
    const contentDiv = document.getElementById('pause-content-area');
    if (!contentDiv) return;
    
    contentDiv.innerHTML = '';

    switch (tabName) {
        case 'stats':
            contentDiv.id = 'stats-tab-content';
            const damageReduction = (1 - playerStats.incomingDamageMultiplier) * 100;
            contentDiv.innerHTML = `
                <h3>Estatísticas de Combate:</h3>
                <p>Dano Base: <strong>${playerStats.bulletDamage.toFixed(2)}</strong></p>
                <p>Velocidade de Ataque: <strong>${(1000 / playerStats.fireRate).toFixed(2)} Tiros/s</strong></p>
                <p>Perfuração: <strong>${playerStats.bulletPiercing}</strong></p>
                <p>Velocidade de Movimento: <strong>${playerStats.playerSpeed}</strong></p>
                <p>Alcance de Magnetismo: <strong>${playerStats.magnetRange}</strong></p>
                <p>Redução de Dano: <strong>${damageReduction.toFixed(0)}%</strong></p>
                <hr>
                <h3>Inventário de Itens:</h3>
                <p>Passivos: <strong>${playerInventory.passives.join(', ') || 'Nenhum'}</strong></p>
                <p>Ativáveis: <strong>${playerInventory.actives.join(', ') || 'Nenhum'}</strong></p>
            `;
            break;

        case 'skills':
            contentDiv.id = 'skills-tab-content';
            contentDiv.innerHTML = `<p class="skill-points-display">Pontos de Habilidade Disponíveis: <strong>${playerStats.skillPoints}</strong></p>`;
            
            for (const statCat in playerStats.skillTree) {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'skill-category';
                categoryDiv.innerHTML = `<h4 class="skill-category-title">${statCat.charAt(0).toUpperCase() + statCat.slice(1)}</h4>`;
                
                for (const talentName in playerStats.skillTree[statCat]) {
                    const talent = playerStats.skillTree[statCat][talentName];
                    const talentDiv = document.createElement('div');
                    talentDiv.className = 'skill-talent';
                    
                    const isMax = talent.level >= talent.max;
                    const canAfford = playerStats.skillPoints >= talent.custo;

                    talentDiv.innerHTML = `
                        <div class="skill-talent-info">
                            <p class="skill-talent-name">${talentName} (${talent.level}/${talent.max})</p>
                            <p class="skill-talent-desc">${talent.desc}</p>
                        </div>
                        <button class="skill-talent-button" data-talent-cat="${statCat}" data-talent-name="${talentName}" ${isMax || !canAfford ? 'disabled' : ''}>
                            ${isMax ? 'MAX' : `Upgrade (${talent.custo})`}
                        </button>
                    `;
                    categoryDiv.appendChild(talentDiv);
                }
                contentDiv.appendChild(categoryDiv);
            }
            
            // Add click listener to skill buttons
            const sceneContext = this;
            contentDiv.querySelectorAll('.skill-talent-button').forEach(button => {
                button.addEventListener('click', function() {
                    const cat = this.dataset.talentCat;
                    const name = this.dataset.talentName;
                    const talent = playerStats.skillTree[cat][name];
                    
                    if (playerStats.skillPoints >= talent.custo && talent.level < talent.max) {
                        playerStats.skillPoints -= talent.custo;
                        talent.level++;
                        talent.efeito(sceneContext);
                        
                        // Check for Max Stats achievement
                        if (talent.level === talent.max) {
                            checkMaxStatsAchievement.call(sceneContext);
                        }
                        
                        // Refresh the menu tab
                        displayPauseMenuTab.call(sceneContext, 'skills');
                    }
                });
            });
            break;
            
        case 'quests':
            contentDiv.id = 'quests-tab-content';
            quests.forEach(quest => {
                const questDiv = document.createElement('div');
                questDiv.className = 'quest-item';
                
                const status = quest.completed ? 'Concluída' : 'Em Progresso';
                const statusColor = quest.completed ? '#00FF00' : '#FFFF00';
                
                questDiv.innerHTML = `
                    <h4 class="quest-title">${quest.title}</h4>
                    <p class="quest-desc">${quest.desc}</p>
                    <p class="quest-progress">Progresso: ${quest.current} / ${quest.target}</p>
                    <p class="quest-reward">Recompensa: ${quest.reward.currency ? `${quest.reward.currency} Sucata` : ''} ${quest.reward.rareParts ? `, ${quest.reward.rareParts} Peças Raras` : ''}</p>
                    <p style="color: ${statusColor}">Status: <strong>${status}</strong></p>
                `;
                
                if (quest.current >= quest.target && !quest.completed) {
                    // Button to manually collect reward, or auto-collect logic
                }
                
                contentDiv.appendChild(questDiv);
            });
            break;

        case 'achievements':
            contentDiv.id = 'achievements-tab-content';
            for (const key in achievements) {
                const ach = achievements[key];
                const achDiv = document.createElement('div');
                achDiv.className = 'achievement-item';
                
                const statusClass = ach.unlocked ? 'unlocked' : 'locked';
                const statusText = ach.unlocked ? 'Desbloqueado' : 'Bloqueado';
                
                achDiv.innerHTML = `
                    <h4 class="achievement-title">${key}</h4>
                    <p class="achievement-desc">${ach.description}</p>
                    <p class="achievement-status ${statusClass}">${statusText}</p>
                `;
                contentDiv.appendChild(achDiv);
            }
            break;

        case 'crafting':
            contentDiv.id = 'crafting-tab-content';
            craftingRecipes.forEach(recipe => {
                const recipeDiv = document.createElement('div');
                recipeDiv.className = 'crafting-recipe';
                
                const canCraft = playerStats.rareParts >= recipe.materiais.rareParts && playerStats.currency >= recipe.materiais.currency;
                const maxReached = recipe.maxCrafts !== Infinity && recipe.crafted;
                
                const materialsList = `
                    <ul class="crafting-materials">
                        <li class="${playerStats.rareParts < recipe.materiais.rareParts ? 'missing' : ''}">
                            ${recipe.materiais.rareParts} Peças Raras
                        </li>
                        <li class="${playerStats.currency < recipe.materiais.currency ? 'missing' : ''}">
                            ${recipe.materiais.currency} Sucata
                        </li>
                    </ul>
                `;
                
                recipeDiv.innerHTML = `
                    <h4 class="recipe-title">${recipe.nome}</h4>
                    <p class="recipe-desc">${recipe.descricao}</p>
                    ${materialsList}
                    <button class="crafting-button" data-recipe-id="${recipe.id}" ${!canCraft || maxReached ? 'disabled' : ''}>
                        ${maxReached ? 'Esgotado' : 'Criar'}
                    </button>
                `;
                
                contentDiv.appendChild(recipeDiv);
            });
            
            // Add crafting listener
            const sceneContextCraft = this;
            contentDiv.querySelectorAll('.crafting-button').forEach(button => {
                button.addEventListener('click', function() {
                    const recipeId = this.dataset.recipeId;
                    const recipe = craftingRecipes.find(r => r.id === recipeId);
                    
                    if (recipe && playerStats.rareParts >= recipe.materiais.rareParts && playerStats.currency >= recipe.materiais.currency && !recipe.crafted) {
                        playerStats.rareParts -= recipe.materiais.rareParts;
                        playerStats.currency -= recipe.materiais.currency;
                        recipe.crafted = true;
                        
                        // Apply effect if needed (e.g., drone module unlock)
                        if (recipeId === 'drone_module') {
                            // Example: Spawn a drone immediately
                            createDrone.call(sceneContextCraft, 'attack', 1, 500);
                        }
                        
                        sceneContextCraft.hud.displayTemporaryEffect(`${recipe.nome} Criado!`, '#A29BFE', 2000);
                        sceneContextCraft.hud.updateAll();
                        displayPauseMenuTab.call(sceneContextCraft, 'crafting'); // Refresh tab
                    }
                });
            });
            break;
    }
}


function checkMaxStatsAchievement() {
    let maxed = 0;
    for (const cat in playerStats.skillTree) {
        for (const name in playerStats.skillTree[cat]) {
            const talent = playerStats.skillTree[cat][name];
            if (talent.level === talent.max) maxed++;
        }
    }
    // Simple check: if at least one skill is maxed
    if (maxed > 0 && !achievements.MaxStats.unlocked) {
        unlockAchievement.call(this, 'MaxStats');
    }
}

function unlockAchievement(id) {
    if (achievements[id] && !achievements[id].unlocked) {
        achievements[id].unlocked = true;
        this.hud.displayTemporaryEffect(`Conquista Desbloqueada: ${achievements[id].description}`, '#FFD700', 5000);
    }
}

function updateQuestProgress(id, value) {
    const quest = quests.find(q => q.id === id);
    if (quest && !quest.completed) {
        if (id === 'kill50' || id === 'reachWave5') {
            quest.current = value;
            if (id === 'kill50') quest.current = Math.min(quest.target, quest.current + value);
        } else {
            quest.current = value;
        }

        if (quest.current >= quest.target) {
            completeQuest.call(this, id);
        }
    }
}

function completeQuest(id) {
    const quest = quests.find(q => q.id === id);
    if (quest && !quest.completed) {
        quest.completed = true;
        playerStats.currency += quest.reward.currency || 0;
        playerStats.rareParts += quest.reward.rareParts || 0;
        this.hud.updateCurrencyDisplay();
        this.hud.displayTemporaryEffect(`Missão Concluída: ${quest.title}!`, '#00FF00', 3000);
        if (pauseMenuOpen) displayPauseMenuTab.call(this, 'quests');
    }
}

function startKillStreak() {
  killStreak++;
  killStreakText.setText(`Combo x${killStreak}`);
  killStreakText.setVisible(true);

  if (killStreakTimer) killStreakTimer.remove(false);
  killStreakTimer = this.time.delayedCall(3000, endKillStreak, [], this);
}
function endKillStreak() {
  killStreak = 0;
  killStreakText.setVisible(false);
}

function createDrone(type, damage, fireRate) {
    // Simple Drone logic
    const droneTexture = 'drone_attack';
    const drone = dronesGroup.get(player.x + 50, player.y - 50, droneTexture);
    if (drone) {
        drone.setActive(true).setVisible(true).setScale(0.05);
        drone.setCollideWorldBounds(true);
        drone.body.setCircle(drone.width * 0.5); // Example collider
        drone.droneType = type;
        drone.damage = damage;
        drone.speed = 200;
        drone.owner = player;
        drone.fireRate = fireRate;
        playerStats.droneActive = true;
        
        // Simple update logic for the drone
        drone.update = function(time, delta) {
            if (!this.active || !this.owner.active) return;
            const distance = Phaser.Math.Distance.Between(this.x, this.y, this.owner.x, this.owner.y);
            if (distance > 60) this.scene.physics.moveToObject(this, this.owner, this.speed);
            else this.setVelocity(0);
            
            // Simple shooting
            if (time > this.lastDroneShootTime + this.fireRate) {
                const nearest = this.scene.findNearestEnemy();
                if (nearest) {
                     const angle = Phaser.Math.Angle.Between(this.x, this.y, nearest.x, nearest.y);
                     const bullet = this.scene.bullets.get(this.x, this.y);
                     if (bullet) bullet.fire(angle, this.damage, 1, 0.5); // Drone bullet with low range
                     this.lastDroneShootTime = time;
                }
            }
        };
        drone.lastDroneShootTime = 0;
    }
}

function gameOver() {
    this.physics.pause();
    player.setTint(0xFF0000);
    gamePaused = true;
    
    // Remove any existing game over menu
    if (document.getElementById('gameOverMenu')) document.body.removeChild(document.getElementById('gameOverMenu'));

    const overlay = document.createElement('div');
    overlay.className = 'menu-overlay';
    overlay.id = 'gameOverMenu';

    const container = document.createElement('div');
    container.className = 'menu-container';
    container.innerHTML = `
        <h2 class="menu-title" style="color:red">FIM DE JOGO</h2>
        <p style="font-size: 24px; margin-bottom: 20px;">Onda Alcançada: <strong>${waveNumber}</strong></p>
        <button class="card-button" onclick="window.location.reload()">Recomeçar</button>
    `;

    overlay.appendChild(container);
    document.body.appendChild(overlay);
}

// --- Entity Classes ---

class Bullet extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) {
        super(scene, x, y, 'bullet');
        this.damage = 1;
        this.piercing = 1;
        this.range = 1; // Range multiplier for lifespan
        this.lifeSpan = 0;
        this.addStatusEffect = null;
        this.setScale(GAME_CONFIG.BULLET.INITIAL_SCALE);
        this.body.setCircle(this.width * 0.5);
    }
    
    fire(a, dmg, pierce, rangeMult = 1) {
        this.setActive(true).setVisible(true);
        this.damage = dmg;
        this.piercing = pierce;
        this.range = rangeMult;
        this.lifeSpan = 0;
        this.setRotation(a);
        this.body.reset(player.x, player.y);
    }
    
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        this.lifeSpan += delta;
        // Bullet despawn after a certain time/distance
        if (this.lifeSpan > 1000 * this.range) { 
            this.kill();
        }
    }
    
    kill(){ this.disableBody(true,true); }
}

class EnemyBullet extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) {
        super(scene, x, y, 'bullet');
        this.damage = 1;
        this.range = 1;
        this.lifeSpan = 0;
        this.setScale(GAME_CONFIG.BULLET.INITIAL_SCALE * 1.5);
        this.setTint(0xFF0000);
        this.body.setCircle(this.width * 0.5);
    }
    
    fire(x, y, a, dmg, speed) {
        this.setActive(true).setVisible(true);
        this.damage = dmg;
        this.setRotation(a);
        this.body.reset(x, y);
        this.scene.physics.velocityFromRotation(a, speed, this.body.velocity);
    }
    
    preUpdate(time, delta) {
        super.preUpdate(time, delta);
        this.lifeSpan += delta;
        if (this.lifeSpan > 2000) { 
            this.kill();
        }
    }
    
    kill(){ this.disableBody(true,true); }
}


class Enemy extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) {
        super(scene, x, y);
        scene.physics.world.enable(this);
        this.lastAttack = 0;
        this.status = { poisoned: { active: false, timer: null, damagePerTick: 0 } };
        this.enemyType = enemyTypes.normal;
    }
    
    spawn(d){
        this.setActive(true).setVisible(true);
        this.setTexture(d.texture);
        this.setScale(d.scale);
        this.enemyType = d;
        this.health = d.baseHealth * (1 + waveNumber * 0.1); // Health scaling
        this.xpReward = d.xpValue;
        this.currencyReward = d.currencyReward;
        this.speed = d.speed;
        this.lastAttack = 0;
        this.body.reset(this.x, this.y);
        this.setTint(0xFFFFFF);
    }
    
    update(time, delta){
        if (!this.active || !player.active || gamePaused) return;

        // Move towards player
        this.scene.physics.moveToObject(this, player, this.speed);
        
        // Ranged Attack Logic
        if (this.enemyType.attacks.includes('ranged') && time > this.lastAttack + 2000) {
            const angle = Phaser.Math.Angle.Between(this.x, this.y, player.x, player.y);
            const bullet = this.scene.enemyBullets.get(this.x, this.y);
            if (bullet) {
                bullet.fire(this.x, this.y, angle, 1, 400); // Damage 1, Speed 400
                this.lastAttack = time;
            }
        }
        
        // Status effect update (e.g., Poisoned)
        if (this.status.poisoned.active) {
            if (time > this.status.poisoned.timer) {
                this.health -= this.status.poisoned.damagePerTick * 5; // Apply damage per second tick
                this.scene.hud.displayTemporaryEffect(`-${(this.status.poisoned.damagePerTick * 5).toFixed(1)}`, '#00FF00', 500);
                this.status.poisoned.timer = time + 500;
                
                if (this.health <= 0) {
                    handleEnemyDeath.call(this.scene, this);
                }
            }
        }
    }
    
    takeDamage(v){ 
        this.health -= v;
        this.setTint(0xFF0000);
        this.scene.time.delayedCall(50, () => this.setTint(0xFFFFFF));
    }
    
    applyStatus(type, duration, damagePerTick = 0) {
        if (type === 'poisoned') {
            if (this.status.poisoned.active) {
                // Reset timer/re-apply stronger effect
                this.status.poisoned.damagePerTick = Math.max(this.status.poisoned.damagePerTick, damagePerTick);
                this.scene.time.removeEvent(this.status.poisoned.effectTimer);
            } else {
                this.status.poisoned.active = true;
                this.status.poisoned.damagePerTick = damagePerTick;
                this.status.poisoned.timer = this.scene.time.now + 500;
            }
            // End effect timer
            this.status.poisoned.effectTimer = this.scene.time.delayedCall(duration, () => {
                this.status.poisoned.active = false;
            });
        }
    }
    
    kill(){ this.disableBody(true,true); }
}

class XPGem extends Phaser.Physics.Arcade.Sprite {
    constructor(scene, x, y) {
        super(scene, x, y, 'ammo');
        this.xpValue = 0;
        this.setScale(0.04);
        this.setTint(0x00FF00);
        this.body.setCircle(this.width * 0.5);
    }
    spawn(xp){
        this.setActive(true).setVisible(true);
        this.xpValue = xp;
        this.body.reset(this.x, this.y);
    }
    kill(){ this.disableBody(true,true); }
}

// --- Initialize Game ---
new Phaser.Game(config);
</script>
</body>
</html>

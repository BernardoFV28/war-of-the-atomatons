<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>War of the Automatons 1 - A Cruzada da Rainha</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #1a1a1a;
            overflow: hidden; /* Hide scrollbars */
            font-family: 'Press Start 2P', cursive; /* Optional: Pixel font */
            color: #eee;
        }

        /* Basic styles for the game container if needed */
        #game-container {
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5); /* Neon glow */
        }

        /* --- Level Up / Item Selection Menu --- */
        .level-up-overlay, .shop-overlay, .pause-overlay, .boss-ritual-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .level-up-container, .shop-container, .pause-container, .boss-ritual-container {
            background-color: #2a2a2a;
            border: 2px solid #00ffff; /* Neon border */
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            max-width: 900px;
            width: 90%;
            box-sizing: border-box;
            color: #eee;
            position: relative;
        }

        .level-up-title, .shop-title, .pause-title, .boss-ritual-title {
            color: #00ff00; /* Neon green for titles */
            margin-bottom: 25px;
            text-shadow: 0 0 8px rgba(0, 255, 0, 0.8);
            font-size: 2em;
        }

        .cards-container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }

        .card {
            background-color: #3a3a3a;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 20px;
            width: 250px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.7); /* Yellow glow on hover */
        }

        .card-icon {
            width: 60px;
            height: 60px;
            margin-bottom: 10px;
            border-radius: 5px;
            background-color: #444;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-left: auto;
            margin-right: auto;
        }

        .card-icon img {
            max-width: 100%;
            max-height: 100%;
        }

        .card-name {
            font-size: 1.3em;
            color: #00ffff; /* Cyan for item names */
            margin-bottom: 10px;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
        }

        .card-description {
            font-size: 0.9em;
            color: #ccc;
            min-height: 60px; /* Ensure consistent card height */
        }

        /* --- Shop Menu --- */
        .shop-container {
            max-width: 700px;
        }

        .shop-currency-display {
            font-size: 1.2em;
            color: #FFD700; /* Gold for currency */
            margin-bottom: 20px;
        }

        .shop-items-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .shop-item {
            background-color: #3a3a3a;
            border: 1px solid #777;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.4); /* Orange glow */
        }

        .shop-item-name {
            font-size: 1.1em;
            color: #00ffff;
            margin-bottom: 8px;
        }

        .shop-item-desc {
            font-size: 0.8em;
            color: #bbb;
            min-height: 40px;
        }

        .shop-item-cost {
            font-size: 1em;
            color: #FFD700;
            margin-top: 10px;
            margin-bottom: 15px;
        }

        .shop-item-button, .shop-close-button, .pause-close-button, .boss-ritual-button {
            background-color: #00aaff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px 10px rgba(0, 170, 255, 0.4);
        }

        .shop-item-button:hover, .shop-close-button:hover, .pause-close-button:hover, .boss-ritual-button:hover {
            background-color: #007bbd;
            transform: translateY(-2px);
        }

        .shop-item-button:disabled {
            background-color: #555;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* --- Pause Menu --- */
        .pause-container {
            max-width: 800px;
        }

        .pause-tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        .pause-tab-button {
            background-color: #3a3a3a;
            color: #eee;
            border: 1px solid #555;
            padding: 8px 15px;
            margin: 0 5px;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            font-size: 0.9em;
        }

        .pause-tab-button:hover {
            background-color: #4a4a4a;
        }

        .pause-tab-button.active {
            background-color: #00ffff;
            color: #1a1a1a;
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            font-weight: bold;
        }

        .pause-content {
            text-align: left;
            padding: 15px;
            background-color: #3a3a3a;
            border: 1px solid #555;
            border-radius: 0 0 8px 8px;
            min-height: 250px;
            overflow-y: auto;
            max-height: 400px;
        }

        .pause-content p {
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .skill-points-display {
            font-size: 1.1em;
            color: #FFD700;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 1px dashed #555;
            padding-bottom: 10px;
        }

        .skill-category {
            margin-bottom: 20px;
            border: 1px solid #444;
            padding: 10px;
            border-radius: 5px;
            background-color: #2e2e2e;
        }

        .skill-category-title {
            color: #00ff00;
            font-size: 1.2em;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        .skill-talent {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background-color: #3a3a3a;
            border-radius: 4px;
            border: 1px solid #444;
        }

        .skill-talent-info {
            flex-grow: 1;
        }

        .skill-talent-name {
            font-weight: bold;
            color: #00ffff;
            font-size: 1em;
        }

        .skill-talent-desc {
            font-size: 0.8em;
            color: #bbb;
            margin-top: 3px;
        }

        .skill-talent-level {
            font-size: 0.9em;
            color: #FFD700;
            margin-left: 15px;
            min-width: 70px; /* Ensure alignment */
            text-align: right;
        }

        .skill-talent-button {
            background-color: #00aaff;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-size: 1.5em;
            line-height: 1;
            cursor: pointer;
            margin-left: 10px;
            transition: background-color 0.2s;
        }

        .skill-talent-button:hover {
            background-color: #007bbd;
        }

        .skill-talent-button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .quest-item, .achievement-item {
            background-color: #2e2e2e;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
        }

        .quest-title, .achievement-title {
            color: #00ffff;
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .quest-desc, .achievement-desc {
            font-size: 0.9em;
            color: #bbb;
            margin-bottom: 5px;
        }

        .quest-progress, .quest-reward {
            font-size: 0.85em;
            color: #ccc;
        }

        .achievement-status {
            font-size: 0.9em;
            font-weight: bold;
        }
        .achievement-status.unlocked {
            color: #00ff00;
        }
        .achievement-status.locked {
            color: #ff0000;
        }

        /* --- Boss Ritual Menu --- */
        .boss-ritual-container {
            max-width: 600px;
            text-align: center;
        }

        .boss-ritual-description {
            font-size: 1.1em;
            color: #ddd;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .boss-ritual-warning {
            color: #ff4500; /* OrangeRed */
            font-weight: bold;
            margin-top: 20px;
            font-size: 1em;
        }

        /* --- HUD Styles (from previous context) --- */
        #hud-container {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 800px;
            background-color: rgba(0, 0, 0, 0.6);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #eee;
            font-size: 0.9em;
            z-index: 999;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            backdrop-filter: blur(5px);
        }

        .hud-section {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #health-bar-container {
            width: 150px;
            height: 15px;
            background-color: #555;
            border: 1px solid #888;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }

        #health-bar {
            height: 100%;
            width: 100%; /* Will be set dynamically */
            background-color: #ff0000; /* Red */
            transition: width 0.2s ease-out;
            border-radius: 5px;
        }

        .hud-label {
            color: #00ff00;
            font-weight: bold;
        }

        #level-display, #xp-display, #wave-display, #currency-display, #kill-streak-display, #skill-points-display {
            color: #FFD700;
            font-weight: bold;
        }

        #temp-effect-display {
            position: fixed;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            color: white;
            font-size: 1.1em;
            font-weight: bold;
            z-index: 1001;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.7);
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        /* Active Items Display */
        #active-items-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 999;
        }

        .active-item-slot {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .active-item-slot img {
            max-width: 80%;
            max-height: 80%;
            opacity: 0.8;
        }

        .active-item-cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 0.8em;
            font-weight: bold;
            height: 0%; /* Will be animated */
            transition: height 0.1s linear;
        }

        .active-item-keybind {
            position: absolute;
            bottom: 2px;
            right: 2px;
            background-color: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.7em;
            line-height: 1;
        }
    </style>
</head>
<body>
<div id="game-container"></div>
<div id="hud-container">
    <div class="hud-section">
        <span class="hud-label">Vida:</span>
        <div id="health-bar-container">
            <div id="health-bar"></div>
        </div>
    </div>
    <div class="hud-section">
        <span class="hud-label">Nível:</span>
        <span id="level-display">1</span>
    </div>
    <div class="hud-section">
        <span class="hud-label">XP:</span>
        <span id="xp-display">0/100</span>
    </div>
    <div class="hud-section">
        <span class="hud-label">Onda:</span>
        <span id="wave-display">1</span>
    </div>
    <div class="hud-section">
        <span class="hud-label">Sucata:</span>
        <span id="currency-display">0</span>
    </div>
    <div class="hud-section">
        <span class="hud-label">Kill Streak:</span>
        <span id="kill-streak-display">0</span>
    </div>
    <div class="hud-section">
        <span class="hud-label">Pontos de Habilidade:</span>
        <span id="skill-points-display">0</span>
    </div>
</div>
<div id="temp-effect-display"></div>
<div id="active-items-container"></div>

<script>
// --- Global Game State and Configuration ---
const config = {
    type: Phaser.AUTO,
    width: 1200,
    height: 700,
    parent: 'game-container',
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 },
            debug: false // Set to true for collision box visualization
        }
    },
    scene: [] // Scenes will be added dynamically
};

// Player Stats (Persistent across game, reset for new game)
const playerStats = {
    level: 1,
    xp: 0,
    xpToNextLevel: 100,
    skillPoints: 0,
    life: 10,
    maxLife: 10,
    playerSpeed: 200,
    bulletDamage: 1,
    fireRate: 500, // milliseconds between shots
    currency: 0,
    reviveOnce: false, // For Protocolo de Ressurreição item
    bulletPiercing: false, // For piercing bullets skill
    doubleBullets: false, // For double bullets skill
    thorns: false, // For thorns damage
    reflectDamage: 0, // Percentage of damage reflected
    touchDamage: 0, // Damage on touch
    healOnKill: false,
    lifestealOnKill: 0, // Amount healed per kill
    cooldownReduction: 0, // Percentage cooldown reduction
    passiveRegenActive: false, // For Auto Reparo skill
    increasedDropRate: false, // For item drop rate increase
    strength: 1, // Affects damage
    agility: 1, // Affects movement speed, fire rate
    constitution: 1, // Affects health, regen
    intelligence: 1, // Affects XP gain, cooldowns

    // Skill Tree structure
    skillTree: {
        strength: {
            "FuriaAutomatica": { description: "Aumenta o dano das suas balas.", level: 0, maxLevel: 5 },
            "PerfuracaoMecanica": { description: "Suas balas perfuram múltiplos inimigos.", level: 0, maxLevel: 1 },
            // Add more strength skills
        },
        agility: {
            "ReflexosRapidos": { description: "Aumenta sua velocidade de movimento.", level: 0, maxLevel: 5 },
            "TiroDuplo": { description: "Chance de atirar uma bala extra.", level: 0, maxLevel: 1 },
            // Add more agility skills
        },
        constitution: {
            "BlindagemAprimorada": { description: "Aumenta sua vida máxima.", level: 0, maxLevel: 5 },
            "AutoReparo": { description: "Regeneração passiva de vida.", level: 0, maxLevel: 1 },
            // Add more constitution skills
        },
        intelligence: {
            "CargaRapida": { description: "Reduz o tempo de recarga de itens ativáveis.", level: 0, maxLevel: 3 },
            "AnaliseDeAmeaca": { description: "Revela inimigos no minimapa.", level: 0, maxLevel: 1 },
            // Add more intelligence skills
        }
    },
    // Quest System
    activeQuests: [],
    completedQuests: [],

    // Achievements System
    achievements: {
        'FirstKill': { description: 'Derrote seu primeiro inimigo.', unlocked: false },
        'Level10': { description: 'Alcance o nível 10.', unlocked: false },
        'BossSlayer': { description: 'Derrote o chefe final.', unlocked: false },
        'RichScrapper': { description: 'Colete 500 de sucata.', unlocked: false },
        // Add more achievements
    }
};

let player;
let cursors;
let bullets;
let enemies;
let lastFired = 0;
let lastEnemySpawnTime = 0;
let waveNumber = 1;
let enemiesInWave = 5;
let enemiesSpawnedThisWave = 0;
let killStreak = 0;
let playerOriginalTint = 0xFFFFFF; // Store original player tint
let gamePaused = false;
let levelUpMenuOpen = false;
let shopMenuOpen = false;
let pauseMenuOpen = false;
let bossRitualMenuOpen = false;

// Destructibles
let destructiblesGroup;

// Drones
let dronesGroup;

// Items
let itemsGroup;

const PLAYER_INITIAL_SCALE = 0.08;
const BULLET_INITIAL_SCALE = 0.03;
const BULLET_INITIAL_SPEED = 500;

// Item Definitions (moved from MainScene to global)
const itemOptions = [
    {
        nome: "Oleo de Maquina",
        tipo: "passivo",
        description: "Aumenta a velocidade de movimento.",
        texture: 'icon_boots',
        efeito: (scene) => { playerStats.playerSpeed += 50; }
    },
    {
        nome: "Modulo de Dano",
        tipo: "passivo",
        description: "Aumenta permanentemente o dano da sua bala.",
        texture: 'icon_damage',
        efeito: (scene) => { playerStats.bulletDamage += 0.5; }
    },
    {
        nome: "Engrenagem Turbo",
        tipo: "passivo",
        description: "Aumenta a cadência de tiro.",
        texture: 'icon_fire_rate',
        efeito: (scene) => { playerStats.fireRate = Math.max(50, playerStats.fireRate - 50); }
    },
    {
        nome: "Placa de Blindagem",
        tipo: "passivo",
        description: "Aumenta sua vida máxima em 1.",
        texture: 'icon_shield',
        efeito: (scene) => { playerStats.maxLife += 1; playerStats.life = playerStats.maxLife; scene.hud.updateHealthBar(); }
    },
    {
        nome: "Teleportador Glitchado",
        tipo: "ativavel",
        description: "Teleporta para a posição do mouse. Cooldown: 15s.",
        texture: 'icon_teleport',
        cooldown: 15000,
        lastUsed: 0,
        keybind: 'Q',
        efeito: (scene) => { scene.teleportToMouse(); }
    },
    {
        nome: "Sopro de Igniun",
        tipo: "ativavel",
        description: "Causa uma explosão de fogo ao redor do jogador. Cooldown: 10s.",
        texture: 'icon_fire_aura',
        cooldown: 10000,
        lastUsed: 0,
        keybind: 'E',
        efeito: (scene) => { scene.igniunExplosion(); }
    },
    {
        nome: "Drone de Ataque",
        tipo: "passivo",
        description: "Spawna um drone que atira em inimigos próximos.",
        texture: 'drone_attack',
        efeito: (scene) => { scene.spawnDrone('attack'); }
    },
    {
        nome: "Protocolo de Reciclagem",
        tipo: "passivo",
        description: "Aumenta a chance de drop de itens.",
        texture: 'icon_loot_chance',
        efeito: (scene) => { playerStats.increasedDropRate = true; }
    },
    {
        nome: "Espinhos Repulsores",
        tipo: "passivo",
        description: "Causa dano a inimigos que tocam no jogador.",
        texture: 'icon_thorns',
        efeito: (scene) => { playerStats.thorns = true; playerStats.reflectDamage = 0.2; } // 20% of bullet damage
    },
    {
        nome: "Aura Eletrica",
        tipo: "passivo",
        description: "Causa dano contínuo a inimigos próximos.",
        texture: 'icon_electric_aura',
        efeito: (scene) => { playerStats.touchDamage += 0.1; } // Small continuous damage
    },
    {
        nome: "Modulo de Lifesteal",
        tipo: "passivo",
        description: "Restaura vida ao derrotar inimigos.",
        texture: 'icon_lifesteal',
        efeito: (scene) => { playerStats.healOnKill = true; playerStats.lifestealOnKill += 0.5; } // Heal 0.5 life per kill
    },
    {
        nome: "Clone Cibernetico",
        tipo: "ativavel",
        description: "Cria um clone do jogador que atira em inimigos. Cooldown: 30s.",
        texture: 'icon_clone',
        cooldown: 30000,
        lastUsed: 0,
        keybind: 'R',
        efeito: (scene) => { scene.createPlayerClone(); }
    }
];

class HUDScene extends Phaser.Scene {
    constructor() {
        super({ key: 'HUDScene' });
        this.activeItemSlots = [];
        this.keybinds = ['Q', 'E', 'R', 'T', 'Y']; // Example keybinds
    }

    preload() {
        // Load any HUD specific assets here if needed
    }

    create() {
        this.healthBar = document.getElementById('health-bar');
        this.levelDisplay = document.getElementById('level-display');
        this.xpDisplay = document.getElementById('xp-display');
        this.waveDisplay = document.getElementById('wave-display');
        this.currencyDisplay = document.getElementById('currency-display');
        this.killStreakDisplay = document.getElementById('kill-streak-display');
        this.skillPointsDisplay = document.getElementById('skill-points-display');
        this.tempEffectDisplay = document.getElementById('temp-effect-display');
        this.activeItemsContainer = document.getElementById('active-items-container');

        this.updateHealthBar();
        this.updateLevelDisplay();
        this.updateXpDisplay();
        this.updateWaveDisplay();
        this.updateCurrencyDisplay();
        this.updateKillStreak(0);
        this.updateSkillPointsDisplay();

        // Listen to events from MainScene for item activations
        this.game.events.on('activateItem', this.addActiveItem, this);
        this.game.events.on('updateCooldown', this.updateCooldowns, this);
    }

    updateHealthBar() {
        const percentage = (playerStats.life / playerStats.maxLife) * 100;
        this.healthBar.style.width = percentage + '%';
        this.healthBar.style.backgroundColor = percentage > 50 ? '#00ff00' : (percentage > 20 ? '#ffa500' : '#ff0000');
    }

    updateLevelDisplay() {
        this.levelDisplay.innerText = playerStats.level;
    }

    updateXpDisplay() {
        this.xpDisplay.innerText = `${playerStats.xp}/${playerStats.xpToNextLevel}`;
    }

    updateWaveDisplay() {
        this.waveDisplay.innerText = waveNumber;
    }

    updateCurrencyDisplay() {
        this.currencyDisplay.innerText = playerStats.currency;
    }

    updateKillStreak(streak) {
        killStreak = streak;
        this.killStreakDisplay.innerText = killStreak;
    }

    updateSkillPointsDisplay() {
        this.skillPointsDisplay.innerText = playerStats.skillPoints;
    }

    displayTemporaryEffect(message, color = '#FFFFFF', duration = 2000) {
        this.tempEffectDisplay.innerText = message;
        this.tempEffectDisplay.style.backgroundColor = `rgba(0, 0, 0, 0.7)`;
        this.tempEffectDisplay.style.color = color;
        this.tempEffectDisplay.style.opacity = 1;
        this.tempEffectDisplay.style.boxShadow = `0 0 15px ${color}`;

        this.time.delayedCall(duration, () => {
            this.tempEffectDisplay.style.opacity = 0;
        });
    }

    addActiveItem(item) {
        // Check if item is already active
        if (this.activeItemSlots.some(slot => slot.item.nome === item.nome)) {
            return;
        }

        const slotIndex = this.activeItemSlots.length;
        if (slotIndex >= this.keybinds.length) {
            this.displayTemporaryEffect('Limite de itens ativáveis atingido!', '#FF0000', 1500);
            return;
        }

        const slotDiv = document.createElement('div');
        slotDiv.className = 'active-item-slot';
        slotDiv.title = `${item.nome} (Cooldown: ${item.cooldown / 1000}s)`;

        const img = document.createElement('img');
        img.src = `assets/${item.texture}.png`; // Assuming item textures are in assets folder
        img.alt = item.nome;
        slotDiv.appendChild(img);

        const cooldownOverlay = document.createElement('div');
        cooldownOverlay.className = 'active-item-cooldown-overlay';
        cooldownOverlay.innerText = ''; // Will display time
        slotDiv.appendChild(cooldownOverlay);

        const keybindText = document.createElement('span');
        keybindText.className = 'active-item-keybind';
        keybindText.innerText = this.keybinds[slotIndex];
        slotDiv.appendChild(keybindText);

        this.activeItemsContainer.appendChild(slotDiv);

        this.activeItemSlots.push({
            item: item,
            slotElement: slotDiv,
            cooldownOverlay: cooldownOverlay,
            keybind: this.keybinds[slotIndex]
        });

        // Inform MainScene about the keybind
        this.scene.get('MainScene').addActiveItemKeybind(this.keybinds[slotIndex], item);
    }

    updateCooldowns() {
        const currentTime = this.game.scene.get('MainScene').time.now;
        this.activeItemSlots.forEach(slot => {
            const item = slot.item;
            const cooldownRemaining = Math.max(0, item.cooldown - (currentTime - item.lastUsed));
            const cooldownPercentage = (cooldownRemaining / item.cooldown) * 100;

            if (cooldownRemaining > 0) {
                slot.cooldownOverlay.style.height = `${cooldownPercentage}%`;
                slot.cooldownOverlay.innerText = `${Math.ceil(cooldownRemaining / 1000)}s`;
                slot.slotElement.style.borderColor = '#ff4500'; // Orange for cooldown
            } else {
                slot.cooldownOverlay.style.height = '0%';
                slot.cooldownOverlay.innerText = '';
                slot.slotElement.style.borderColor = '#00ffff'; // Cyan when ready
            }
        });
    }
}

class MainScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MainScene' });
        this.hud = null;
        this.activeItemKeybinds = {}; // Maps keybinds to activable items
        this.currentActiveItems = []; // List of active item objects with cooldown info
    }

    preload() {
        this.load.image('player', 'assets/player_ship.png');
        this.load.image('bullet', 'assets/bullet.png');
        this.load.image('enemy_robot', 'assets/enemy_robot.png');
        this.load.image('enemy_shooter', 'assets/enemy_shooter.png');
        this.load.image('enemy_kamikaze', 'assets/enemy_kamikaze.png');
        this.load.image('boss_robot', 'assets/boss_robot.png'); // Boss asset
        this.load.image('enemy_bullet', 'assets/enemy_bullet.png');
        this.load.image('background', 'assets/background_tile.png');

        // Load item icons
        this.load.image('icon_boots', 'assets/icon_boots.png');
        this.load.image('icon_damage', 'assets/icon_damage.png');
        this.load.image('icon_fire_rate', 'assets/icon_fire_rate.png');
        this.load.image('icon_shield', 'assets/icon_shield.png');
        this.load.image('icon_teleport', 'assets/icon_teleport.png');
        this.load.image('icon_fire_aura', 'assets/icon_fire_aura.png');
        this.load.image('drone_attack', 'assets/drone_attack.png'); // Drone icon
        this.load.image('icon_loot_chance', 'assets/icon_loot_chance.png');
        this.load.image('icon_thorns', 'assets/icon_thorns.png');
        this.load.image('icon_electric_aura', 'assets/icon_electric_aura.png');
        this.load.image('icon_lifesteal', 'assets/icon_lifesteal.png');
        this.load.image('icon_clone', 'assets/icon_clone.png');

        // Destructibles
        this.load.image('destructible_crate', 'assets/destructible_crate.png');
        this.load.image('item_currency', 'assets/item_currency.png'); // For currency drop from crates
    }

    create() {
        // Initialize HUD
        this.hud = this.scene.get('HUDScene'); // Get HUD scene instance

        // Background
        this.add.tileSprite(0, 0, config.width * 2, config.height * 2, 'background').setOrigin(0);

        // Player
        player = this.physics.add.sprite(config.width / 2, config.height / 2, 'player').setScale(PLAYER_INITIAL_SCALE);
        player.setCollideWorldBounds(true);
        player.body.setCircle(player.width / 2); // Make player collision a circle
        playerOriginalTint = player.tintTopLeft; // Store initial tint

        // Groups
        bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 100 // Max bullets on screen
        });
        enemies = this.physics.add.group();
        this.enemyBullets = this.physics.add.group(); // Group for enemy bullets

        destructiblesGroup = this.physics.add.group();
        itemsGroup = this.physics.add.group();
        dronesGroup = this.physics.add.group();

        // Input
        cursors = this.input.keyboard.createCursorKeys();
        this.input.keyboard.on('keydown-SPACE', this.shootBullet, this);
        this.input.on('pointerdown', this.shootBullet, this);
        this.input.keyboard.on('keydown-ESC', this.togglePauseMenu, this);

        // Active item keybinds
        this.input.keyboard.on('keydown', this.handleActiveItemKeybinds, this);

        // Collisions
        this.physics.add.collider(player, enemies, playerHitEnemy, null, this);
        this.physics.add.collider(bullets, enemies, bulletHitEnemy, null, this);
        this.physics.add.collider(this.enemyBullets, player, playerHitEnemyBullet, null, this);
        this.physics.add.overlap(player, itemsGroup, collectItem, null, this);
        this.physics.add.collider(bullets, destructiblesGroup, bulletHitDestructible, null, this);
        this.physics.add.collider(player, destructiblesGroup, playerHitDestructible, null, this);
        this.physics.add.collider(dronesGroup, enemies, droneHitEnemy, null, this); // Drones hit enemies
        this.physics.add.collider(this.enemyBullets, dronesGroup, enemyBulletHitDrone, null, this); // Enemy bullets hit drones

        // Initial Spawns
        this.spawnDestructibles();
        this.nextWave();

        // Passive Regen Timer
        this.time.addEvent({
            delay: 1000, // Every second
            callback: this.applyPassiveRegen,
            callbackScope: this,
            loop: true
        });

        // Quest System Events
        this.game.events.on('enemyKilled', this.updateQuestProgress, this);
        this.game.events.on('itemCollected', this.updateQuestProgress, this);
    }

    update(time, delta) {
        if (gamePaused) {
            return;
        }

        // Player movement
        player.setVelocity(0);
        if (cursors.left.isDown || this.input.keyboard.addKey('A').isDown) {
            player.setVelocityX(-playerStats.playerSpeed);
        } else if (cursors.right.isDown || this.input.keyboard.addKey('D').isDown) {
            player.setVelocityX(playerStats.playerSpeed);
        }
        if (cursors.up.isDown || this.input.keyboard.addKey('W').isDown) {
            player.setVelocityY(-playerStats.playerSpeed);
        } else if (cursors.down.isDown || this.input.keyboard.addKey('S').isDown) {
            player.setVelocityY(playerStats.playerSpeed);
        }
        player.body.velocity.normalize().scale(playerStats.playerSpeed);

        // Player rotation to mouse
        const pointer = this.input.activePointer;
        if (pointer.isDown || !pointer.isDown) { // Always rotate towards pointer
            const angle = Phaser.Math.Angle.Between(player.x, player.y, pointer.x, pointer.y);
            player.rotation = angle + Math.PI / 2; // Offset by 90 degrees for sprite
        }

        // Automatic shooting if mouse is down
        if (pointer.isDown) {
            this.shootBullet(time);
        }

        // Enemies logic
        enemies.children.each(enemy => {
            // Check for boss
            if (enemy.enemyType.texture === 'boss_robot') {
                this.physics.moveToObject(enemy, player, enemy.speed);
                if (time > enemy.lastSpecialAttackTime + enemy.specialAttackCooldown) {
                    this.bossSpecialAttack(enemy);
                    enemy.lastSpecialAttackTime = time;
                }
            } else {
                this.physics.moveToObject(enemy, player, enemy.speed);
            }

            // Enemy shooting logic (for shooter types)
            if (enemy.enemyType.attacks.includes('shoot') && time > enemy.lastShootTime + enemy.shootCooldown) {
                const enemyBullet = this.enemyBullets.create(enemy.x, enemy.y, 'enemy_bullet').setScale(0.02);
                enemyBullet.damage = enemy.damage; // Use enemy's damage for its bullets
                this.physics.moveToObject(enemyBullet, player, 300); // Speed of enemy bullets
                enemy.lastShootTime = time;
            }
        });

        // Drone logic
        dronesGroup.children.each(drone => {
            // Keep drone near player
            const distance = Phaser.Math.Distance.Between(drone.x, drone.y, player.x, player.y);
            const maxDistance = 150; // Max distance from player

            if (distance > maxDistance) {
                this.physics.moveToObject(drone, player, drone.speed);
            } else {
                drone.setVelocity(0);
            }

            // Attack drone shooting logic
            if (drone.droneType === 'attack' && time > drone.lastShootTime + drone.shootCooldown) {
                const nearestEnemy = this.physics.closest(drone, enemies.getChildren());
                if (nearestEnemy) {
                    const bullet = bullets.create(drone.x, drone.y, 'bullet');
                    bullet.setScale(BULLET_INITIAL_SCALE * 0.7); // Smaller bullets
                    bullet.setDamage(playerStats.bulletDamage * 0.5); // Less damage
                    this.physics.moveToObject(bullet, nearestEnemy, BULLET_INITIAL_SPEED);
                }
                drone.lastShootTime = time;
            }
        });

        // Update HUD cooldowns
        this.hud.updateCooldowns();
    }

    shootBullet(time) {
        if (gamePaused) return;

        // Apply fire rate reduction from intelligence skills
        let effectiveFireRate = playerStats.fireRate * (1 - playerStats.cooldownReduction);
        effectiveFireRate = Math.max(50, effectiveFireRate); // Minimum fire rate

        if (time > lastFired + effectiveFireRate) {
            const pointer = this.input.activePointer;

            if (playerStats.doubleBullets) {
                // Shoot two bullets with a slight offset
                const angle = Phaser.Math.Angle.Between(player.x, player.y, pointer.x, pointer.y);
                const offset = 10; // Pixels offset for double bullets

                // Bullet 1
                let bullet1 = bullets.get(player.x + Math.cos(angle - Math.PI / 2) * offset, player.y + Math.sin(angle - Math.PI / 2) * offset);
                if (bullet1) {
                    bullet1.setActive(true).setVisible(true);
                    bullet1.body.reset(player.x + Math.cos(angle - Math.PI / 2) * offset, player.y + Math.sin(angle - Math.PI / 2) * offset);
                    bullet1.setAngle(Phaser.Math.RadToDeg(angle) + 90); // Rotate sprite
                    bullet1.setScale(BULLET_INITIAL_SCALE);
                    bullet1.setDamage(playerStats.bulletDamage);
                    bullet1.piercing = playerStats.bulletPiercing;
                    bullet1.hits = 0; // Reset hit count for piercing
                    this.physics.moveTo(bullet1, pointer.x, pointer.y, BULLET_INITIAL_SPEED);
                }

                // Bullet 2
                let bullet2 = bullets.get(player.x + Math.cos(angle + Math.PI / 2) * offset, player.y + Math.sin(angle + Math.PI / 2) * offset);
                if (bullet2) {
                    bullet2.setActive(true).setVisible(true);
                    bullet2.body.reset(player.x + Math.cos(angle + Math.PI / 2) * offset, player.y + Math.sin(angle + Math.PI / 2) * offset);
                    bullet2.setAngle(Phaser.Math.RadToDeg(angle) + 90);
                    bullet2.setScale(BULLET_INITIAL_SCALE);
                    bullet2.setDamage(playerStats.bulletDamage);
                    bullet2.piercing = playerStats.bulletPiercing;
                    bullet2.hits = 0;
                    this.physics.moveTo(bullet2, pointer.x, pointer.y, BULLET_INITIAL_SPEED);
                }
            } else {
                let bullet = bullets.get(player.x, player.y);
                if (bullet) {
                    bullet.setActive(true).setVisible(true);
                    bullet.body.reset(player.x, player.y); // Reset position
                    const angle = Phaser.Math.Angle.Between(player.x, player.y, pointer.x, pointer.y);
                    bullet.setAngle(Phaser.Math.RadToDeg(angle) + 90); // Rotate sprite
                    bullet.setScale(BULLET_INITIAL_SCALE);
                    bullet.setDamage(playerStats.bulletDamage); // Set damage from player stats
                    bullet.piercing = playerStats.bulletPiercing;
                    bullet.hits = 0; // Initialize hit count for piercing
                    this.physics.moveTo(bullet, pointer.x, pointer.y, BULLET_INITIAL_SPEED);
                }
            }
            lastFired = time;
        }
    }

    addActiveItemKeybind(key, item) {
        this.activeItemKeybinds[key] = item;
    }

    handleActiveItemKeybinds(event) {
        if (gamePaused) return;

        const key = event.key.toUpperCase();
        const item = this.activeItemKeybinds[key];

        if (item && item.tipo === "ativavel") {
            const currentTime = this.time.now;
            // Apply cooldown reduction from intelligence skills
            const effectiveCooldown = item.cooldown * (1 - playerStats.cooldownReduction);
            if (currentTime > (item.lastUsed + effectiveCooldown)) {
                item.efeito(this);
                item.lastUsed = currentTime;
                this.hud.game.events.emit('updateCooldown'); // Notify HUD to update
            } else {
                this.hud.displayTemporaryEffect('Item ainda em cooldown!', '#FF0000', 1000);
            }
        }
    }

    spawnEnemy() {
        // Random position outside visible screen
        let x, y;
        const edge = Phaser.Math.RND.integerInRange(0, 3); // 0: top, 1: right, 2: bottom, 3: left

        if (edge === 0) { // Top
            x = Phaser.Math.RND.between(0, config.width);
            y = -50;
        } else if (edge === 1) { // Right
            x = config.width + 50;
            y = Phaser.Math.RND.between(0, config.height);
        } else if (edge === 2) { // Bottom
            x = Phaser.Math.RND.between(0, config.width);
            y = config.height + 50;
        } else { // Left
            x = -50;
            y = Phaser.Math.RND.between(0, config.height);
        }

        let enemyType = 'enemy_robot';
        let enemyHealth = 3;
        let enemySpeed = 100;
        let enemyDamage = 1;
        let enemyXp = 5;
        let enemyCurrency = 1;
        let enemyAttacks = ['melee'];

        // Introduce different enemy types based on wave number
        if (waveNumber >= 3 && Phaser.Math.RND.frac() < 0.4) { // 40% chance for shooter from wave 3
            enemyType = 'enemy_shooter';
            enemyHealth = 5;
            enemySpeed = 80;
            enemyDamage = 1;
            enemyXp = 7;
            enemyCurrency = 2;
            enemyAttacks = ['shoot'];
        }
        if (waveNumber >= 5 && Phaser.Math.RND.frac() < 0.3) { // 30% chance for kamikaze from wave 5
            enemyType = 'enemy_kamikaze';
            enemyHealth = 2;
            enemySpeed = 150;
            enemyDamage = 2; // Higher direct damage
            enemyXp = 10;
            enemyCurrency = 3;
            enemyAttacks = ['explode'];
        }

        // Increase enemy stats with wave number
        enemyHealth += Math.floor(waveNumber / 2);
        enemySpeed += Math.floor(waveNumber / 5) * 5; // Speed increases slower
        enemyDamage += Math.floor(waveNumber / 3);
        enemyXp += Math.floor(waveNumber / 4);
        enemyCurrency += Math.floor(waveNumber / 5);


        const enemy = enemies.create(x, y, enemyType).setScale(0.06);
        enemy.setCollideWorldBounds(true);
        enemy.setBounce(1); // Enemies bounce off walls
        enemy.body.setCircle(enemy.width / 2); // Circular collision
        enemy.health = enemyHealth;
        enemy.speed = enemySpeed;
        enemy.damage = enemyDamage;
        enemy.xpReward = enemyXp;
        enemy.currencyReward = enemyCurrency;
        enemy.enemyType = { texture: enemyType, attacks: enemyAttacks }; // Store type and attacks
        enemy.lastShootTime = 0; // For shooter enemies
        enemy.shootCooldown = 1500; // 1.5 seconds cooldown for shooting enemies

        enemiesSpawnedThisWave++;
    }

    spawnBoss() {
        const boss = enemies.create(config.width / 2, -100, 'boss_robot').setScale(0.3); // Spawn boss above screen
        boss.setCollideWorldBounds(true);
        boss.setBounce(0.5);
        boss.body.setCircle(boss.width / 2);
        boss.health = 50 + (waveNumber * 10); // Boss health scales with wave
        boss.speed = 70; // Boss moves slower
        boss.damage = 5; // Boss damage
        boss.xpReward = 100 + (waveNumber * 20);
        boss.currencyReward = 50 + (waveNumber * 10);
        boss.enemyType = { texture: 'boss_robot', attacks: ['melee', 'shoot', 'special'] };
        boss.lastShootTime = 0;
        boss.shootCooldown = 1000;
        boss.lastSpecialAttackTime = 0;
        boss.specialAttackCooldown = 5000; // Boss special attack every 5 seconds
        boss.setDepth(10); // Ensure boss is on top

        this.physics.moveToObject(boss, player, boss.speed); // Make boss move towards player initially
    }

    bossSpecialAttack(boss) {
        // Example: Boss shoots multiple bullets in a spread
        const numBullets = 8;
        const bulletSpeed = 200;
        const angleStep = (Math.PI * 2) / numBullets;

        for (let i = 0; i < numBullets; i++) {
            const angle = i * angleStep;
            const enemyBullet = this.enemyBullets.create(boss.x, boss.y, 'enemy_bullet').setScale(0.03);
            enemyBullet.damage = boss.damage;
            this.physics.velocityFromRotation(angle, bulletSpeed, enemyBullet.body.velocity);
        }
        this.hud.displayTemporaryEffect('CHEFE: ATAQUE ESPECIAL!', '#FF0000', 1000);
    }

    nextWave() {
        waveNumber++;
        enemiesInWave += 2; // Increase enemies per wave
        enemiesSpawnedThisWave = 0;
        killStreak = 0; // Reset kill streak for new wave
        this.hud.updateKillStreak(0);
        this.hud.updateWaveDisplay();

        this.hud.displayTemporaryEffect(`Onda ${waveNumber} Chegou!`, '#00ffff', 2000);

        if (waveNumber % 5 === 0) { // Every 5 waves, a boss appears
            this.showBossRitualMenu();
        } else {
            this.time.addEvent({
                delay: 1000, // Spawn an enemy every second
                callback: this.spawnEnemy,
                callbackScope: this,
                repeat: enemiesInWave - 1 // Total enemies to spawn this wave
            });
        }
    }

    addXp(amount) {
        playerStats.xp += amount;
        if (playerStats.xp >= playerStats.xpToNextLevel) {
            this.levelUp();
        }
        this.hud.updateXpDisplay();
    }

    levelUp() {
        playerStats.level++;
        playerStats.xp -= playerStats.xpToNextLevel; // Carry over excess XP
        playerStats.xpToNextLevel = Math.floor(playerStats.xpToNextLevel * 1.2); // Increase XP needed for next level
        playerStats.skillPoints++; // Grant a skill point on level up
        playerStats.maxLife++; // Small health increase
        playerStats.life = playerStats.maxLife; // Heal to full
        this.hud.updateHealthBar();
        this.hud.updateLevelDisplay();
        this.hud.updateXpDisplay();
        this.hud.updateSkillPointsDisplay();
        this.hud.displayTemporaryEffect('LEVEL UP!', '#00FF00', 2000);
        this.unlockAchievement('Level' + playerStats.level); // Check for level achievements

        // Show level up menu for item selection
        this.showLevelUpMenu();
    }

    applyPassiveRegen() {
        if (playerStats.passiveRegenActive && playerStats.life < playerStats.maxLife && !gamePaused) {
            playerStats.life += 0.1; // Heal a small amount
            playerStats.life = Math.min(playerStats.life, playerStats.maxLife); // Cap at max life
            this.hud.updateHealthBar();
        }
    }

    showBossRitualMenu() {
        if (levelUpMenuOpen || shopMenuOpen || pauseMenuOpen || bossRitualMenuOpen) return;
        gamePaused = true;
        bossRitualMenuOpen = true;
        this.physics.pause();

        const overlay = document.createElement('div');
        overlay.className = 'boss-ritual-overlay';
        overlay.id = 'bossRitualMenu';

        const container = document.createElement('div');
        container.className = 'boss-ritual-container';
        overlay.appendChild(container);

        const title = document.createElement('h2');
        title.className = 'boss-ritual-title';
        title.innerText = 'RITUAL DE SACRIFÍCIO';
        container.appendChild(title);

        const description = document.createElement('p');
        description.className = 'boss-ritual-description';
        description.innerHTML = `
            Uma energia distorcida emerge do tecido do universo glitch. Para enfrentar a criatura colossal que se aproxima, você deve fazer uma escolha.
            <br><br>
            Você pode <strong style="color: #00FF00;">sacrificar 1 de vida máxima</strong> para ganhar <strong style="color: #FFD700;">50 de Sucata</strong>,
            ou <strong style="color: #FFD700;">sacrificar 25 de Sucata</strong> para ganhar <strong style="color: #00FF00;">1 de vida máxima</strong>.
            <br><br>
            Escolha sabiamente, a batalha será intensa.
        `;
        container.appendChild(description);

        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'boss-ritual-buttons';
        container.appendChild(buttonContainer);

        const sacrificeLifeButton = document.createElement('button');
        sacrificeLifeButton.className = 'boss-ritual-button';
        sacrificeLifeButton.innerText = 'Sacrificar 1 Vida Máxima (Ganhar 50 Sucata)';
        sacrificeLifeButton.onclick = () => {
            if (playerStats.maxLife > 1) { // Prevent sacrificing last life point
                playerStats.maxLife -= 1;
                playerStats.life = Math.min(playerStats.life, playerStats.maxLife); // Adjust current life
                playerStats.currency += 50;
                this.hud.updateHealthBar();
                this.hud.updateCurrencyDisplay();
                this.hud.displayTemporaryEffect('Vida máxima sacrificada!', '#FFD700', 1500);
            } else {
                this.hud.displayTemporaryEffect('Não é possível sacrificar mais vida!', '#FF0000', 1500);
            }
            overlay.remove();
            bossRitualMenuOpen = false;
            gamePaused = false;
            this.physics.resume();
            this.spawnBoss(); // Spawn boss after ritual
        };
        buttonContainer.appendChild(sacrificeLifeButton);

        const sacrificeCurrencyButton = document.createElement('button');
        sacrificeCurrencyButton.className = 'boss-ritual-button';
        sacrificeCurrencyButton.innerText = 'Sacrificar 25 Sucata (Ganhar 1 Vida Máxima)';
        sacrificeCurrencyButton.onclick = () => {
            if (playerStats.currency >= 25) {
                playerStats.currency -= 25;
                playerStats.maxLife += 1;
                playerStats.life = playerStats.maxLife; // Heal to full
                this.hud.updateHealthBar();
                this.hud.updateCurrencyDisplay();
                this.hud.displayTemporaryEffect('Sucata sacrificada!', '#00FF00', 1500);
            } else {
                this.hud.displayTemporaryEffect('Sucata insuficiente!', '#FF0000', 1500);
            }
            overlay.remove();
            bossRitualMenuOpen = false;
            gamePaused = false;
            this.physics.resume();
            this.spawnBoss(); // Spawn boss after ritual
        };
        buttonContainer.appendChild(sacrificeCurrencyButton);

        const skipButton = document.createElement('button');
        skipButton.className = 'boss-ritual-button';
        skipButton.innerText = 'Ignorar Ritual (Não recomendado!)';
        skipButton.onclick = () => {
            this.hud.displayTemporaryEffect('Ritual Ignorado. Que os Deuses Glitch te ajudem!', '#FF0000', 2000);
            overlay.remove();
            bossRitualMenuOpen = false;
            gamePaused = false;
            this.physics.resume();
            this.spawnBoss(); // Spawn boss even if ritual skipped
        };
        buttonContainer.appendChild(skipButton);

        document.body.appendChild(overlay);
    }

    showLevelUpMenu() {
    if (levelUpMenuOpen || shopMenuOpen || pauseMenuOpen || bossRitualMenuOpen) return;
    gamePaused = true;
    levelUpMenuOpen = true;
    this.physics.pause();

    const overlay = document.createElement('div');
    overlay.className = 'level-up-overlay';
    overlay.id = 'levelUpMenu';

    const container = document.createElement('div');
    container.className = 'level-up-container';
    overlay.appendChild(container);

    const title = document.createElement('h2');
    title.className = 'level-up-title';
    title.innerText = 'NÍVEL UP! ESCOLHA UM ITEM';
    container.appendChild(title);

    const cardsContainer = document.createElement('div');
    cardsContainer.className = 'cards-container';
    container.appendChild(cardsContainer);

    const selectedItems = this.getRandomUniqueItems(3); // Get 3 random unique items

    selectedItems.forEach(item => {
      const card = document.createElement('div');
      card.className = 'card';
      card.innerHTML = `
        <div class="card-icon"><img src="assets/${item.texture}.png" alt="${item.nome}"></div>
        <h3 class="card-name">${item.nome}</h3>
        <p class="card-description">${item.description}</p>
      `;
      card.onclick = () => {
        item.efeito(this); // Pass 'this' (the scene context) to the effect function
        if (item.tipo === "ativavel") {
          // Add to current active items for cooldown tracking etc.
          this.currentActiveItems.push(item);
          this.hud.game.events.emit('activateItem', item); // Notify HUD to display cooldown
        }
        overlay.remove();
        levelUpMenuOpen = false;
        gamePaused = false;
        this.physics.resume();
      };
      cardsContainer.appendChild(card);
    });

    document.body.appendChild(overlay);
  }

  getRandomUniqueItems(count) {
    const availableItems = [...itemOptions];
    const selected = [];
    for (let i = 0; i < count && availableItems.length > 0; i++) {
      const randomIndex = Phaser.Math.RND.integerInRange(0, availableItems.length - 1);
      selected.push(availableItems.splice(randomIndex, 1)[0]);
    }
    return selected;
  }

  showShopMenu() {
    if (levelUpMenuOpen || shopMenuOpen || pauseMenuOpen || bossRitualMenuOpen) return;
    gamePaused = true;
    shopMenuOpen = true;
    this.physics.pause();

    const overlay = document.createElement('div');
    overlay.className = 'shop-overlay';
    overlay.id = 'shopMenu';

    const container = document.createElement('div');
    container.className = 'shop-container';
    overlay.appendChild(container);

    const title = document.createElement('h2');
    title.className = 'shop-title';
    title.innerText = 'Mercado de Sucata';
    container.appendChild(title);

    const currencyDisplay = document.createElement('p');
    currencyDisplay.className = 'shop-currency-display';
    currencyDisplay.innerText = `Sucata: ${playerStats.currency}`;
    container.appendChild(currencyDisplay);

    const itemsContainer = document.createElement('div');
    itemsContainer.className = 'shop-items-container';
    container.appendChild(itemsContainer);

    const shopItems = [
      { id: 'life', name: 'Kit de Reparo (Vida)', desc: 'Restaura totalmente sua vida.', cost: 50, effect: () => { playerStats.life = playerStats.maxLife; this.hud.updateHealthBar(); } },
      { id: 'max_life', name: 'Reforço de Blindagem (Vida Máxima)', desc: 'Aumenta sua vida máxima em 1.', cost: 100, effect: () => { playerStats.maxLife += 1; playerStats.life = playerStats.maxLife; this.hud.updateHealthBar(); } },
      { id: 'damage', name: 'Otimização de Tiro (Dano)', desc: 'Aumenta permanentemente o dano de suas balas.', cost: 75, effect: () => { playerStats.bulletDamage += 0.2; } },
      { id: 'fire_rate', name: 'Aprimoramento de Cadência (Velocidade de Tiro)', desc: 'Aumenta permanentemente sua velocidade de tiro.', cost: 75, effect: () => { playerStats.fireRate = Math.max(50, playerStats.fireRate * 0.9); } },
      { id: 'revive', name: 'Protocolo de Ressurreição', desc: 'Concede uma revivência única. Ativado automaticamente.', cost: 200, effect: () => { playerStats.reviveOnce = true; } }
    ];

    shopItems.forEach(item => {
      const itemDiv = document.createElement('div');
      itemDiv.className = 'shop-item';
      itemDiv.innerHTML = `
        <h3 class="shop-item-name">${item.name}</h3>
        <p class="shop-item-desc">${item.desc}</p>
        <p class="shop-item-cost">Custo: ${item.cost} Sucata</p>
        <button class="shop-item-button" data-item-id="${item.id}">Comprar</button>
      `;
      const buyButton = itemDiv.querySelector('button');
      buyButton.onclick = () => {
        if (playerStats.currency >= item.cost) {
          playerStats.currency -= item.cost;
          item.effect();
          this.hud.updateCurrencyDisplay();
          currencyDisplay.innerText = `Sucata: ${playerStats.currency}`; // Update display
          buyButton.disabled = true; // Disable after purchase for single-buy items
          this.hud.displayTemporaryEffect(`Comprado: ${item.name}!`, '#00FF00', 1500);
        } else {
          this.hud.displayTemporaryEffect('Sucata Insuficiente!', '#FF0000', 1500);
        }
      };
      // Disable if already bought or not enough currency (for initial display)
      if (item.id === 'revive' && playerStats.reviveOnce) {
          buyButton.disabled = true;
      }
      if (playerStats.currency < item.cost) {
          buyButton.disabled = true;
      }
      itemsContainer.appendChild(itemDiv);
    });

    const closeButton = document.createElement('button');
    closeButton.className = 'shop-close-button';
    closeButton.innerText = 'Sair do Mercado';
    closeButton.onclick = () => {
      overlay.remove();
      shopMenuOpen = false;
      gamePaused = false;
      this.physics.resume();
    };
    container.appendChild(closeButton);

    document.body.appendChild(overlay);
  }

  togglePauseMenu() {
    if (levelUpMenuOpen || shopMenuOpen || bossRitualMenuOpen) return; // Cannot open pause menu if other menus are open

    if (gamePaused && pauseMenuOpen) {
      // Close pause menu
      const pauseOverlay = document.getElementById('pauseMenu');
      if (pauseOverlay) {
        pauseOverlay.remove();
      }
      pauseMenuOpen = false;
      gamePaused = false;
      this.physics.resume();
    } else if (!gamePaused && !pauseMenuOpen) {
      // Open pause menu
      gamePaused = true;
      pauseMenuOpen = true;
      this.physics.pause();
      this.displayPauseMenu();
    }
  }

  displayPauseMenu() {
    const overlay = document.createElement('div');
    overlay.className = 'pause-overlay';
    overlay.id = 'pauseMenu';

    const container = document.createElement('div');
    container.className = 'pause-container';
    overlay.appendChild(container);

    const title = document.createElement('h2');
    title.className = 'pause-title';
    title.innerText = 'JOGO PAUSADO';
    container.appendChild(title);

    const tabsContainer = document.createElement('div');
    tabsContainer.className = 'pause-tabs';
    container.appendChild(tabsContainer);

    const statsButton = document.createElement('button');
    statsButton.className = 'pause-tab-button active';
    statsButton.innerText = 'Estatísticas';
    statsButton.onclick = () => this.showPauseTab('stats', tabsContainer);
    tabsContainer.appendChild(statsButton);

    const skillsButton = document.createElement('button');
    skillsButton.className = 'pause-tab-button';
    skillsButton.innerText = 'Habilidades';
    skillsButton.onclick = () => this.showPauseTab('skills', tabsContainer);
    tabsContainer.appendChild(skillsButton);

    const questsButton = document.createElement('button');
    questsButton.className = 'pause-tab-button';
    questsButton.innerText = 'Missões';
    questsButton.onclick = () => this.showPauseTab('quests', tabsContainer);
    tabsContainer.appendChild(questsButton);

    const achievementsButton = document.createElement('button');
    achievementsButton.className = 'pause-tab-button';
    achievementsButton.innerText = 'Conquistas';
    achievementsButton.onclick = () => this.showPauseTab('achievements', tabsContainer);
    tabsContainer.appendChild(achievementsButton);

    const contentContainer = document.createElement('div');
    contentContainer.className = 'pause-content';
    contentContainer.id = 'pause-content-area';
    container.appendChild(contentContainer);

    this.updatePauseMenuContent('stats', contentContainer); // Show stats by default

    const closeButton = document.createElement('button');
    closeButton.className = 'pause-close-button';
    closeButton.innerText = 'Continuar Jogo';
    closeButton.onclick = () => this.togglePauseMenu();
    container.appendChild(closeButton);

    document.body.appendChild(overlay);
  }

  showPauseTab(tabName, tabsContainer) {
    const contentArea = document.getElementById('pause-content-area');
    // Deactivate all tab buttons
    Array.from(tabsContainer.children).forEach(button => button.classList.remove('active'));
    // Activate the clicked button
    tabsContainer.querySelector(`button[onclick*='${tabName}']`).classList.add('active');
    this.updatePauseMenuContent(tabName, contentArea);
  }

  updatePauseMenuContent(tabName, contentArea) {
    contentArea.innerHTML = ''; // Clear previous content

    switch (tabName) {
      case 'stats':
        contentArea.id = 'stats-tab-content';
        contentArea.innerHTML = `
          <p><strong>Vida:</strong> ${playerStats.life}/${playerStats.maxLife}</p>
          <p><strong>XP:</strong> ${playerStats.xp}/${playerStats.xpToNextLevel}</p>
          <p><strong>Nível:</strong> ${playerStats.level}</p>
          <p><strong>Dano de Bala:</strong> ${playerStats.bulletDamage.toFixed(1)}</p>
          <p><strong>Cadência de Tiro:</strong> ${playerStats.fireRate} ms</p>
          <p><strong>Velocidade de Movimento:</strong> ${playerStats.playerSpeed} px/s</p>
          <p><strong>Sucata:</strong> ${playerStats.currency}</p>
          <p><strong>Pontos de Habilidade:</strong> ${playerStats.skillPoints}</p>
          <br>
          <p><strong>FORÇA:</strong> ${playerStats.strength}</p>
          <p><strong>AGILIDADE:</strong> ${playerStats.agility}</p>
          <p><strong>CONSTITUIÇÃO:</strong> ${playerStats.constitution}</p>
          <p><strong>INTELIGÊNCIA:</strong> ${playerStats.intelligence}</p>
        `;
        break;
      case 'skills':
        contentArea.id = 'skills-tab-content';
        contentArea.innerHTML = `<p class="skill-points-display">Pontos de Habilidade Disponíveis: ${playerStats.skillPoints}</p>`;

        for (const attribute in playerStats.skillTree) {
          const categoryDiv = document.createElement('div');
          categoryDiv.className = 'skill-category';
          categoryDiv.innerHTML = `<h3 class="skill-category-title">${attribute.toUpperCase()}</h3>`;

          for (const skillName in playerStats.skillTree[attribute]) {
            const skill = playerStats.skillTree[attribute][skillName];
            const skillTalentDiv = document.createElement('div');
            skillTalentDiv.className = 'skill-talent';
            skillTalentDiv.innerHTML = `
              <div class="skill-talent-info">
                <span class="skill-talent-name">${skillName}</span>
                <p class="skill-talent-desc">${skill.description}</p>
              </div>
              <span class="skill-talent-level">Nível: ${skill.level}/${skill.maxLevel}</span>
              <button class="skill-talent-button" data-skill-name="${skillName}">+</button>
            `;
            const upgradeButton = skillTalentDiv.querySelector('button');
            if (skill.level >= skill.maxLevel || playerStats.skillPoints <= 0) {
              upgradeButton.disabled = true;
            }
            upgradeButton.onclick = () => this.upgradeSkill(attribute, skillName, upgradeButton);
            categoryDiv.appendChild(skillTalentDiv);
          }
          contentArea.appendChild(categoryDiv);
        }
        break;
      case 'quests':
        contentArea.id = 'quests-tab-content';
        if (playerStats.activeQuests.length === 0) {
            contentArea.innerHTML = '<p>Nenhuma missão ativa no momento.</p>';
        } else {
            playerStats.activeQuests.forEach(quest => {
                const questDiv = document.createElement('div');
                questDiv.className = 'quest-item';
                questDiv.innerHTML = `
                    <h3 class="quest-title">${quest.name}</h3>
                    <p class="quest-desc">${quest.description}</p>
                    <p class="quest-progress">Progresso: ${quest.currentProgress}/${quest.targetProgress}</p>
                    <p class="quest-reward">Recompensa: ${quest.rewardDescription}</p>
                `;
                contentArea.appendChild(questDiv);
            });
        }
        break;
      case 'achievements':
        contentArea.id = 'achievements-tab-content';
        for (const achievementId in playerStats.achievements) {
            const achievement = playerStats.achievements[achievementId];
            const achievementDiv = document.createElement('div');
            achievementDiv.className = 'achievement-item';
            const statusClass = achievement.unlocked ? 'unlocked' : 'locked';
            const statusText = achievement.unlocked ? 'Desbloqueada' : 'Bloqueada';
            achievementDiv.innerHTML = `
                <h3 class="achievement-title">${achievementId}</h3>
                <p class="achievement-desc">${achievement.description}</p>
                <p class="achievement-status ${statusClass}">${statusText}</p>
            `;
            contentArea.appendChild(achievementDiv);
        }
        break;
    }
  }

  upgradeSkill(attribute, skillName, button) {
    const skill = playerStats.skillTree[attribute][skillName];
    if (playerStats.skillPoints > 0 && skill.level < skill.maxLevel) {
      skill.level++;
      playerStats.skillPoints--;
      this.hud.updateSkillPointsDisplay(); // Update HUD

      // Apply skill effect
      switch (skillName) {
        case "FuriaAutomatica":
          playerStats.bulletDamage += 0.1; // Example effect
          break;
        case "PerfuracaoMecanica":
          playerStats.bulletPiercing = true;
          break;
        case "ReflexosRapidos":
          playerStats.playerSpeed += 20;
          break;
        case "TiroDuplo":
          playerStats.doubleBullets = true;
          break;
        case "BlindagemAprimorada":
          playerStats.maxLife += 1;
          playerStats.life = playerStats.maxLife;
          this.hud.updateHealthBar();
          break;
        case "AutoReparo":
          playerStats.passiveRegenActive = true; // Activate passive regen
          break;
        case "CargaRapida":
          playerStats.cooldownReduction = (playerStats.cooldownReduction || 0) + 0.05; // 5% cooldown reduction per level
          break;
        case "AnaliseDeAmeaca":
          // Implement minimap revelation logic
          break;
      }

      // Update the pause menu to reflect changes
      const contentArea = document.getElementById('pause-content-area');
      this.updatePauseMenuContent('skills', contentArea);

      // Re-check button state after upgrade
      if (skill.level >= skill.maxLevel || playerStats.skillPoints <= 0) {
        button.disabled = true;
      }
    }
  }

  unlockAchievement(achievementId) {
    if (playerStats.achievements[achievementId] && !playerStats.achievements[achievementId].unlocked) {
        playerStats.achievements[achievementId].unlocked = true;
        this.hud.displayTemporaryEffect(`Conquista Desbloqueada: ${playerStats.achievements[achievementId].description}`, '#FFD700', 3000);
        // Optionally, trigger an event to update achievements tab if open
        if (pauseMenuOpen && document.getElementById('achievements-tab-content')) {
            this.updatePauseMenuContent('achievements', document.getElementById('pause-content-area'));
        }
    }
  }

  updateQuestProgress(eventType, data) {
    playerStats.activeQuests.forEach(quest => {
        let progressMade = false;
        if (quest.type === eventType) {
            if (quest.type === 'enemyKilled' && data.enemyType) { // Specific enemy type kill quest
                if (quest.targetEnemyType === 'any' || quest.targetEnemyType === data.enemyType) {
                    quest.currentProgress += 1;
                    progressMade = true;
                }
            } else if (quest.type === 'itemCollected' && data.itemType) { // Specific item collection quest
                if (quest.targetItemType === 'any' || quest.targetItemType === data.itemType) {
                    quest.currentProgress += 1;
                    progressMade = true;
                }
            }
            // Add more conditions for other quest types (e.g., 'reachWave', 'collectCurrency')
        }

        if (progressMade) {
            // Update quest progress display if pause menu is open and on quests tab
            if (pauseMenuOpen && document.getElementById('quests-tab-content')) {
                this.updatePauseMenuContent('quests', document.getElementById('pause-content-area'));
            }

            if (quest.currentProgress >= quest.targetProgress) {
                this.completeQuest(quest);
            }
        }
    });
  }

  completeQuest(quest) {
    this.hud.displayTemporaryEffect(`Missão Concluída: ${quest.name}!`, '#00FF00', 3000);
    // Apply rewards
    if (quest.rewardType === 'currency') {
        playerStats.currency += quest.rewardAmount;
        this.hud.updateCurrencyDisplay();
    } else if (quest.rewardType === 'xp') {
        this.addXp(quest.rewardAmount);
    } else if (quest.rewardType === 'item') {
        // Find and add a specific item to player's inventory/effects
        const awardedItem = itemOptions.find(item => item.nome === quest.rewardItemName);
        if (awardedItem) {
            awardedItem.efeito(this); // Apply the item's effect
            if (awardedItem.tipo === "ativavel") {
              this.currentActiveItems.push(awardedItem);
              this.hud.game.events.emit('activateItem', awardedItem);
            }
        }
    }

    // Move from active to completed quests
    playerStats.activeQuests = playerStats.activeQuests.filter(q => q !== quest);
    playerStats.completedQuests.push(quest);

    // Update quest display if pause menu is open
    if (pauseMenuOpen && document.getElementById('quests-tab-content')) {
        this.updatePauseMenuContent('quests', document.getElementById('pause-content-area'));
    }
  }

  // Example of adding a new quest
  addQuest(quest) {
      playerStats.activeQuests.push(quest);
      if (pauseMenuOpen && document.getElementById('quests-tab-content')) {
          this.updatePauseMenuContent('quests', document.getElementById('pause-content-area'));
      }
  }

  // --- Destructibles ---
  spawnDestructibles() {
    for (let i = 0; i < 5; i++) { // Spawn 5 crates
        const x = Phaser.Math.RND.between(50, config.width - 50);
        const y = Phaser.Math.RND.between(50, config.height - 50);
        const crate = destructiblesGroup.create(x, y, 'destructible_crate').setScale(0.1);
        crate.health = 3; // Crates have 3 health
        crate.setImmovable(true); // Crates don't move on collision
    }
  }

  // --- Drones ---
  spawnDrone(type) {
    const drone = dronesGroup.create(player.x + Phaser.Math.RND.between(-50, 50), player.y + Phaser.Math.RND.between(-50, 50), 'drone_attack').setScale(0.05);
    drone.droneType = type;
    drone.health = 5; // Drones have health
    drone.speed = 150; // Drones move faster than player
    drone.setCircle(drone.width / 2);
    drone.setCollideWorldBounds(true);
    drone.setBounce(0.5); // Drones bounce off walls
    drone.setDepth(9); // Drones slightly above enemies, below player

    if (type === 'attack') {
        drone.lastShootTime = 0;
        drone.shootCooldown = 700; // Attack drones shoot every 0.7 seconds
    }
  }

  // --- Special Ativavel Item Effects ---
  teleportToMouse() {
    const pointer = this.input.activePointer;
    player.setPosition(pointer.x, pointer.y);
    this.hud.displayTemporaryEffect('Teleporte Ativado!', '#00FFFF', 1000);
  }

  igniunExplosion() {
    // Create a temporary explosion graphic/animation
    const explosion = this.add.circle(player.x, player.y, 50, 0xFF4500, 0.5);
    this.time.delayedCall(300, () => { explosion.destroy(); }); // Destroy explosion graphic after short time

    // Damage enemies in range
    enemies.children.each(enemy => {
      if (Phaser.Math.Distance.Between(player.x, player.y, enemy.x, enemy.y) < 100) { // Explosion radius
        enemy.health -= playerStats.bulletDamage * 2; // Double damage for explosion
        if (enemy.health <= 0) {
          enemyKilled(enemy, this); // Call existing kill logic
        } else {
            enemy.setTint(0xFF4500); // Briefly tint red for hit
            this.time.delayedCall(100, () => enemy.setTint(0xFFFFFF));
        }
      }
    });
    this.hud.displayTemporaryEffect('Sopro de Igniun!', '#FF4500', 1000);
  }

  createPlayerClone() {
    const clone = this.physics.add.sprite(player.x + 50, player.y + 50, 'player').setScale(PLAYER_INITIAL_SCALE);
    clone.setTint(0x00FF00); // Green tint for clone
    clone.setCollideWorldBounds(true);
    clone.body.setCircle(clone.width / 2);
    clone.setAlpha(0.7); // Slightly transparent

    // Clone behavior (example: follow player and shoot)
    const cloneShootEvent = this.time.addEvent({
      delay: playerStats.fireRate * 1.5, // Clone shoots slower than player
      callback: () => {
        if (clone.active && enemies.countActive(true) > 0) {
          const nearestEnemy = this.physics.closest(clone, enemies.getChildren());
          if (nearestEnemy) {
            const bullet = bullets.create(clone.x, clone.y, 'bullet');
            bullet.setScale(BULLET_INITIAL_SCALE * 0.8);
            bullet.setDamage(playerStats.bulletDamage * 0.7); // Clone does less damage
            this.physics.moveToObject(bullet, nearestEnemy, BULLET_INITIAL_SPEED);
          }
        }
      },
      loop: true
    });

    this.time.delayedCall(10000, () => { // Clone lasts 10 seconds
      clone.destroy();
      cloneShootEvent.remove();
      this.hud.displayTemporaryEffect('Clone Desativado.', '#888888', 1000);
    });
    this.hud.displayTemporaryEffect('Clone Cibernético Ativado!', '#00FF00', 1000);
  }
}

// --- Collision Callbacks ---
function playerHitEnemy(player, enemy) {
  // If enemy is kamikaze, it explodes and takes damage
  if (enemy.enemyType.attacks.includes('explode')) {
    enemy.health = 0; // Instantly kill kamikaze
    // Visual explosion effect
    const explosion = this.add.circle(enemy.x, enemy.y, 50, 0xFF0000, 0.5);
    this.time.delayedCall(200, () => { explosion.destroy(); });
    this.hud.displayTemporaryEffect('Explosão Kamikaze!', '#FF0000', 1000);
    // Damage nearby enemies and player
    enemies.children.each(e => {
        if (e.active && e !== enemy && Phaser.Math.Distance.Between(enemy.x, enemy.y, e.x, e.y) < 100) {
            e.health -= enemy.damage * 2; // Double damage to other enemies
            if (e.health <= 0) {
                enemyKilled(e, this);
            }
        }
    });
  }

  // Reduce player health
  playerStats.life -= enemy.damage;
  this.hud.updateHealthBar();

  // Apply player invulnerability frame
  player.setTint(0xFF0000); // Red tint for hit
  this.time.delayedCall(200, () => {
    player.setTint(playerOriginalTint); // Reset tint
  });

  // Apply thorns damage to enemy
  if (playerStats.thorns && playerStats.reflectDamage > 0) {
      enemy.health -= playerStats.bulletDamage * playerStats.reflectDamage;
  }

  // Apply touch damage to enemy
  if (playerStats.touchDamage > 0) {
      enemy.health -= playerStats.touchDamage;
  }

  if (playerStats.life <= 0) {
    if (playerStats.reviveOnce) {
      playerStats.life = playerStats.maxLife; // Restore full health
      playerStats.reviveOnce = false; // Consume revive
      this.hud.updateHealthBar();
      this.hud.displayTemporaryEffect('Protocolo de Ressurreição Ativado!', '#00FFFF', 2000);
    } else {
      this.physics.pause();
      player.setTint(0xFF0000); // Player turns red on death
      this.hud.displayTemporaryEffect('GAME OVER', '#FF0000', 999999);
      // Optionally, show a restart button or end-game screen
    }
  }

  // Kill enemy if health drops to 0 (for kamikaze or if damage from player's thorns/touch kills it)
  if (enemy.health <= 0 && enemy.active) {
      enemyKilled(enemy, this);
  }
}

function playerHitEnemyBullet(player, enemyBullet) {
  enemyBullet.destroy();
  playerStats.life -= enemyBullet.damage;
  this.hud.updateHealthBar();

  player.setTint(0xFF0000);
  this.time.delayedCall(200, () => {
    player.setTint(playerOriginalTint);
  });

  if (playerStats.life <= 0) {
    if (playerStats.reviveOnce) {
      playerStats.life = playerStats.maxLife;
      playerStats.reviveOnce = false;
      this.hud.updateHealthBar();
      this.hud.displayTemporaryEffect('Protocolo de Ressurreição Ativado!', '#00FFFF', 2000);
    } else {
      this.physics.pause();
      player.setTint(0xFF0000);
      this.hud.displayTemporaryEffect('GAME OVER', '#FF0000', 999999);
    }
  }
}

function bulletHitEnemy(bullet, enemy) {
  if (!bullet.active || !enemy.active) return; // Ensure both are active

  enemy.health -= bullet.damage;

  if (!bullet.piercing) {
    bullet.destroy(); // Destroy bullet if it's not piercing
  } else {
    bullet.hits++; // Increment hit count for piercing bullets
    if (bullet.hits >= 3) { // Destroy after hitting 3 enemies (example)
        bullet.destroy();
    }
  }

  // Flash enemy red when hit
  enemy.setTint(0xFF0000);
  this.time.delayedCall(100, () => {
    if (enemy.active) { // Only reset tint if enemy is still active
      enemy.setTint(0xFFFFFF);
    }
  });

  if (enemy.health <= 0) {
    enemyKilled(enemy, this);
  }
}

function enemyKilled(enemy, scene) {
  // Play death animation/effect
  // scene.add.sprite(enemy.x, enemy.y, 'explosion').play('explode'); // Example explosion animation
  enemy.destroy();

  scene.addXp(enemy.xpReward);
  playerStats.currency += enemy.currencyReward;
  scene.hud.updateCurrencyDisplay();

  // Drop items based on rarity and increased drop rate
  const dropChance = 0.3 * (playerStats.increasedDropRate ? 1.5 : 1); // 30% base chance, increased by stat
  if (Phaser.Math.RND.frac() < dropChance) {
      const itemToDrop = Phaser.Math.RND.pick(itemOptions); // Simplified for now
      const item = itemsGroup.create(enemy.x, enemy.y, itemToDrop.texture).setScale(0.05);
      item.itemType = itemToDrop; // Store item data
      item.setBounce(0.5);
      item.setCollideWorldBounds(true);
      item.setVelocity(Phaser.Math.RND.between(-50, 50), Phaser.Math.RND.between(-50, 50));
  }

  // Kill streak logic
  killStreak++;
  scene.hud.updateKillStreak(killStreak);

  // Apply heal on kill
  if (playerStats.healOnKill && playerStats.lifestealOnKill > 0) {
      playerStats.life = Math.min(playerStats.maxLife, playerStats.life + playerStats.lifestealOnKill);
      scene.hud.updateHealthBar();
  }

  // Trigger achievement for first kill
  scene.unlockAchievement('FirstKill');
  // Trigger event for quests
  scene.game.events.emit('enemyKilled', { enemyType: enemy.enemyType });


  // Check if all enemies in wave are defeated if not a boss
  if (enemy.enemyType.texture !== 'boss_robot' && enemies.countActive(true) === 0 && enemiesSpawnedThisWave >= enemiesInWave) {
      scene.nextWave();
  } else if (enemy.enemyType.texture === 'boss_robot') {
      scene.unlockAchievement('BossSlayer');
      scene.hud.displayTemporaryEffect('CHEFE DERROTADO!', '#FFD700', 3000);
      // Transition to next level or end game
      scene.time.delayedCall(3000, () => {
          scene.showShopMenu(); // Show shop after boss defeat
      });
  }
}

function collectItem(player, item) {
  item.destroy();
  this.hud.displayTemporaryEffect(`Item Coletado: ${item.itemType.nome}`, '#00FFFF', 1500);

  // Apply item effect
  item.itemType.efeito(this); // Pass 'this' (the scene context) to the effect function

  // If it's an activable item, add to currentActiveItems
  if (item.itemType.tipo === "ativavel") {
      this.currentActiveItems.push(item.itemType);
      this.hud.game.events.emit('activateItem', item.itemType); // Notify HUD to display cooldown
  }

  // Trigger event for quests
  this.game.events.emit('itemCollected', { itemType: item.itemType.nome });
}

function bulletHitDestructible(bullet, destructible) {
  if (!bullet.piercing) {
    bullet.destroy();
  }
  destructible.health -= bullet.damage;
  if (destructible.health <= 0) {
      destructible.destroy();
      // Drop loot from destructibles
      if (Phaser.Math.RND.frac() < 0.5) { // 50% chance to drop currency
          const currencyItem = itemsGroup.create(destructible.x, destructible.y, 'item_currency').setScale(0.05);
          currencyItem.itemType = { nome: 'Sucata', tipo: 'currency', efeito: (scene) => { playerStats.currency += 10; scene.hud.updateCurrencyDisplay(); } };
          currencyItem.setBounce(0.5);
          currencyItem.setCollideWorldBounds(true);
          currencyItem.setVelocity(Phaser.Math.RND.between(-50, 50), Phaser.Math.RND.between(-50, 50));
      }
  }
}

function playerHitDestructible(player, destructible) {
  // Prevent player from moving through destructibles
}

function droneHitEnemy(drone, enemy) {
  // Drones can also do touch damage or slow enemies
  enemy.health -= 0.1; // Small passive damage
  if (enemy.health <= 0) {
      enemyKilled(enemy, this);
  }
}

function enemyBulletHitDrone(enemyBullet, drone) {
  enemyBullet.destroy();
  drone.health -= enemyBullet.damage;
  if (drone.health <= 0) {
      drone.destroy();
      this.hud.displayTemporaryEffect('Drone Destruído!', '#FF0000', 1000);
  }
}

// --- Game Initialization ---
const game = new Phaser.Game(config);
game.scene.add('HUDScene', HUDScene);
game.scene.add('MainScene', MainScene);
game.scene.start('MainScene');
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Biopunk: Robot Warfare Survivor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', monospace; }
        
        /* UI */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        .hud-box { 
            position: absolute; background: rgba(0, 10, 20, 0.9); 
            border: 1px solid #00d2ff; padding: 10px; border-radius: 5px;
            color: #00d2ff; font-weight: bold; text-shadow: 0 0 5px #00d2ff;
            pointer-events: auto;
        }

        #xp-container { 
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            width: 400px; height: 25px; background: #111; border: 2px solid #333; border-radius: 15px; overflow: hidden;
        }
        #xp-bar { width: 0%; height: 100%; background: linear-gradient(90deg, #00d2ff, #ffffff); transition: width 0.2s; }
        
        /* ALERTA DE BOSS */
        #boss-alert {
            position: absolute; top: 25%; width: 100%; text-align: center;
            font-size: 3rem; color: #ff003c; font-weight: 900; text-shadow: 0 0 20px #ff003c;
            display: none; text-transform: uppercase; animation: shake 0.5s infinite;
        }

        /* MENU CARDS */
        .overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; }
        .hidden { display: none !important; }
        
        .card-container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; }
        
        /* Estilo do Card usando sua imagem de fundo */
        .card { 
            width: 200px; height: 280px;
            background-image: url('assets/card.png'); /* SEU ASSET AQUI */
            background-size: cover; background-position: center;
            background-color: #222; /* Fallback se a imagem falhar */
            border: 2px solid #444; padding: 15px;
            border-radius: 8px; cursor: pointer; transition: 0.3s; text-align: center; color: #eee;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .card:hover { border-color: #00d2ff; transform: scale(1.05); box-shadow: 0 0 15px #00d2ff; }
        .card h3 { color: #ffd700; margin: 0 0 10px 0; text-shadow: 1px 1px 2px black; }
        .card small { color: #ccc; display: block; margin-bottom: 5px; font-weight: bold; }
        .card p { font-size: 0.9rem; text-shadow: 1px 1px 1px black; }

        @keyframes shake { 0% { transform: translate(1px, 1px); } 50% { transform: translate(-1px, -1px); } 100% { transform: translate(1px, 1px); } }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="hud-box" style="top: 10px; left: 10px;">
        LVL: <span id="hud-lvl">1</span> | HP: <span id="hud-hp">100</span>
    </div>
    <div class="hud-box" style="top: 10px; right: 10px;">
        TEMPO: <span id="hud-time">00:00</span> | MORTES: <span id="hud-kills">0</span>
    </div>
    <div id="xp-container"><div id="xp-bar"></div></div>
    <div id="boss-alert">ALERTA: TITÃ DETECTADO</div>
</div>

<div id="start-screen" class="overlay">
    <h1 style="color:#00d2ff; font-size: 4rem; text-shadow: 0 0 30px #00d2ff;"></h1>
    <h2 style="color:#fff;">MODO: SOBREVIVÊNCIA</h2>
    <p style="color:#ccc">WASD para mover. Mouse para mirar. Sobreviva à horda.</p>
    <button onclick="startGame()" style="padding: 15px 40px; font-size: 1.5rem; background: #00d2ff; border: none; font-weight: bold; cursor: pointer; border-radius: 5px;">INICIAR OPERAÇÃO</button>
</div>

<div id="levelup-screen" class="overlay hidden">
    <h2 style="color:#ffd700; text-shadow: 0 0 10px gold;">UPGRADE DE SISTEMA</h2>
    <div class="card-container" id="upgrade-list"></div>
</div>

<div id="game-container"></div>

<script>
// ================= DADOS DO JOGO (RPG) =================
const STATE = {
    hp: 100, maxHp: 100,
    xp: 0, nextXp: 100, level: 1,
    kills: 0, time: 0,
    weapons: [], 
    passives: { might: 1, cooldown: 1, speed: 200, area: 1 }, // Speed ajustado para o player
    isPaused: false,
    gameActive: false
};

const WEAPONS_DB = [
    { id: 'gun', name: 'Metralhadora', desc: 'Disparos rápidos contra o inimigo mais próximo.', type: 'projectile', dmg: 15, cd: 600, speed: 500, color: 0xffff00 },
    { id: 'gas', name: 'Campo de Radiação', desc: 'Aura que danifica inimigos próximos constantemente.', type: 'aura', dmg: 3, cd: 200, area: 130, color: 0x00ff00 },
    { id: 'drone', name: 'Drone Orbital', desc: 'Gira ao redor protegendo e causando dano.', type: 'orbital', dmg: 20, cd: 0, speed: 2.5, count: 1, color: 0x00d2ff }
];

const BOSS_DB = [
    { name: "Destruidor MK-1", tint: 0xffaaaa, scale: 2.0, hpMult: 100, ai: 'charger' }, // Tint leve para não perder a cor da imagem
    { name: "Ciber-Enxame", tint: 0xaaffaa, scale: 1.8, hpMult: 80, ai: 'shooter' },
    { name: "Goliath Prime", tint: 0xffffff, scale: 3.0, hpMult: 200, ai: 'tank' }
];

class MainScene extends Phaser.Scene {
    constructor() { super('MainScene'); }

    preload() {
        // --- AQUI ESTÃO OS SEUS ASSETS ---
        // Se a imagem falhar em carregar, o jogo não trava, mas mostra um quadrado preto/verde.
        
        this.load.image('bg', 'assets/dungeon_floor.png');
        this.load.image('player', 'assets/player.png');
        this.load.image('bullet', 'assets/bullet.png');
        
        // Inimigos
        this.load.image('enemy_basic', 'assets/enemy_robot.png');
        this.load.image('enemy_fast', 'assets/enemy_fast.png');
        this.load.image('enemy_tank', 'assets/enemy_tank.png');
        
        // Boss e Itens
        this.load.image('boss', 'assets/boss_robot.png');
        this.load.image('pickup', 'assets/ammo.png'); // Cura/XP
        
        // UI
        this.load.image('card_bg', 'assets/card.png');

        // Fallback: Gráficos gerados caso as imagens não existam na pasta
        const createFallback = (key, color) => {
            const g = this.make.graphics().fillStyle(color).fillRect(0,0,32,32);
            g.generateTexture('fallback_'+key, 32, 32);
        };
        createFallback('player', 0x00ff00);
        createFallback('enemy', 0xff0000);
    }

    create() {
        STATE.gameActive = true;
        
        // Mundo Infinito (TileSprite)
        this.physics.world.setBounds(0, 0, 4000, 4000);
        
        // Tenta usar a imagem 'bg', se não existir, usa uma cor sólida
        if(this.textures.exists('bg')) {
            this.bg = this.add.tileSprite(2000, 2000, 4000, 4000, 'bg');
        } else {
            this.add.grid(2000, 2000, 4000, 4000, 128, 128, 0x001133).setAlpha(0.5);
        }

        // Player
        const pKey = this.textures.exists('player') ? 'player' : 'fallback_player';
        this.player = this.physics.add.sprite(2000, 2000, pKey);
        this.player.setCollideWorldBounds(true);
        this.player.setDepth(10); 
        this.player.setScale(0.05);
        // Player sempre acima do chão
        
        // Câmera
        this.cameras.main.startFollow(this.player, true);
        this.cameras.main.setZoom(1.2);

        // Grupos
        this.enemies = this.physics.add.group({ runChildUpdate: true });
        this.bullets = this.physics.add.group({ runChildUpdate: true });
        this.xpGems = this.physics.add.group();
        this.damageTexts = this.add.group();

        // Colisões
        this.physics.add.overlap(this.bullets, this.enemies, this.hitEnemy, null, this);
        this.physics.add.overlap(this.player, this.enemies, this.hitPlayer, null, this);
        this.physics.add.overlap(this.player, this.xpGems, this.collectXp, null, this);

        // Inputs
        this.keys = this.input.keyboard.addKeys('W,A,S,D');

        // Timers
        this.time.addEvent({ delay: 1000, callback: this.tickSecond, callbackScope: this, loop: true });
        this.time.addEvent({ delay: 600, callback: this.spawnHorde, callbackScope: this, loop: true });

        // Arma Inicial
        this.addWeapon('gun');
    }

    update(time, delta) {
        if(STATE.isPaused || !STATE.gameActive) return;

        // 1. Movimento Player
        this.player.setVelocity(0);
        const spd = STATE.passives.speed;
        if(this.keys.A.isDown) this.player.setVelocityX(-spd);
        else if(this.keys.D.isDown) this.player.setVelocityX(spd);
        if(this.keys.W.isDown) this.player.setVelocityY(-spd);
        else if(this.keys.S.isDown) this.player.setVelocityY(spd);

        // 2. Armas
        STATE.weapons.forEach(w => {
            if(time > w.nextFire) {
                this.fireWeapon(w);
                w.nextFire = time + (w.cd * STATE.passives.cooldown);
            }
            if(w.type === 'orbital' && w.sprites) {
                w.angle = (w.angle || 0) + (w.speed * (delta/1000));
                w.sprites.forEach((s, i) => {
                    const offset = (Math.PI * 2 / w.count) * i;
                    s.x = this.player.x + Math.cos(w.angle + offset) * 80;
                    s.y = this.player.y + Math.sin(w.angle + offset) * 80;
                });
            }
            if(w.type === 'aura' && w.sprite) {
                w.sprite.setPosition(this.player.x, this.player.y);
            }
        });

        // 3. Inimigos perseguem
        this.enemies.children.iterate(e => {
            if(e && e.active) {
                if(e.isBoss) this.updateBossAI(e, time);
                else this.physics.moveToObject(e, this.player, e.speed);
            }
        });

        // 4. Magneto XP
        this.xpGems.children.iterate(xp => {
            if(Phaser.Math.Distance.Between(this.player.x, this.player.y, xp.x, xp.y) < 150) {
                this.physics.moveToObject(xp, this.player, 400);
            }
        });
    }

    // ================== COMBATE ==================

    fireWeapon(w) {
        if(w.type === 'projectile') {
            let target = this.getClosestEnemy();
            if(target) {
                const bKey = this.textures.exists('bullet') ? 'bullet' : 'fallback_player';
                const b = this.bullets.create(this.player.x, this.player.y, bKey);
                
                // Se a imagem for muito grande, diminui
                if(b.width > 20) b.setScale(0.5); 

                this.physics.moveToObject(b, target, w.speed);
                // Calcula rotação da bala
                const angle = Phaser.Math.Angle.Between(this.player.x, this.player.y, target.x, target.y);
                b.setRotation(angle);
                
                b.damage = w.dmg * STATE.passives.might;
                this.time.delayedCall(1500, () => { if(b.active) b.destroy(); });
            }
        }
    }

    getClosestEnemy() {
        let closest = null, min = 800;
        this.enemies.children.iterate(e => {
            if(!e.active) return;
            const d = Phaser.Math.Distance.Between(this.player.x, this.player.y, e.x, e.y);
            if(d < min) { min = d; closest = e; }
        });
        return closest;
    }

    hitEnemy(bullet, enemy) {
        if(bullet.isAura || bullet.isOrbital) {
            if(enemy.invuln > this.time.now) return;
            enemy.invuln = this.time.now + 300;
        } else {
            bullet.destroy();
        }

        const dmg = bullet.damage || (bullet.weaponRef ? bullet.weaponRef.dmg * STATE.passives.might : 10);
        enemy.hp -= dmg;
        
        // Texto de dano
        const txt = this.add.text(enemy.x, enemy.y - 20, Math.floor(dmg), { fontSize: '16px', color: '#fff', stroke: '#000', strokeThickness: 2 });
        this.tweens.add({ targets: txt, y: enemy.y-50, alpha: 0, duration: 500, onComplete: ()=>txt.destroy() });

        if(enemy.hp <= 0) {
            // Drop de Cura/XP (ammo.png)
            const dropKey = this.textures.exists('pickup') ? 'pickup' : 'fallback_player';
            const drop = this.xpGems.create(enemy.x, enemy.y, dropKey);
            drop.value = enemy.isBoss ? 500 : 10;
            // Se o ammo.png for grande, escala
            drop.setScale(0.5);

            STATE.kills++;
            document.getElementById('hud-kills').innerText = STATE.kills;
            enemy.destroy();
            
            if(enemy.isBoss) {
                document.getElementById('boss-alert').style.display = 'none';
                this.cameras.main.shake(500, 0.01);
            }
        } else {
            enemy.setTint(0xff0000);
            this.time.delayedCall(100, () => enemy.clearTint());
        }
    }

    hitPlayer(player, enemy) {
        if(player.invuln) return;
        STATE.hp -= 10;
        player.setTint(0xff0000);
        player.invuln = true;
        this.cameras.main.shake(100, 0.01);
        
        document.getElementById('hud-hp').innerText = Math.max(0, Math.ceil(STATE.hp));
        
        this.time.delayedCall(500, () => {
            player.clearTint();
            player.invuln = false;
        });

        if(STATE.hp <= 0) {
            this.physics.pause();
            STATE.isPaused = true;
            alert(`SISTEMA CRÍTICO! VOCÊ MORREU.\nNível: ${STATE.level}\nTempo: ${document.getElementById('hud-time').innerText}`);
            location.reload();
        }
    }

    collectXp(player, drop) {
        drop.destroy();
        STATE.xp += drop.value;
        const pct = (STATE.xp / STATE.nextXp) * 100;
        document.getElementById('xp-bar').style.width = Math.min(100, pct) + '%';
        
        // Recupera um pouco de vida ao pegar "ammo"
        if(STATE.hp < STATE.maxHp) {
            STATE.hp = Math.min(STATE.maxHp, STATE.hp + 2);
            document.getElementById('hud-hp').innerText = Math.floor(STATE.hp);
        }

        if(STATE.xp >= STATE.nextXp) {
            STATE.xp = 0;
            STATE.nextXp = Math.floor(STATE.nextXp * 1.3);
            STATE.level++;
            document.getElementById('hud-lvl').innerText = STATE.level;
            document.getElementById('xp-bar').style.width = '0%';
            this.openLevelUp();
        }
    }

    // ================== INIMIGOS E BOSS ==================

    spawnHorde() {
        if(this.enemies.countActive() > 250) return;

        const cam = this.cameras.main;
        // Spawn fora da tela
        const x = Phaser.Math.Between(cam.worldView.left - 200, cam.worldView.right + 200);
        const y = Phaser.Math.Between(cam.worldView.top - 200, cam.worldView.bottom + 200);
        
        // Garante que não spawna na cara do player
        if(Phaser.Math.Distance.Between(x,y,this.player.x,this.player.y) < 600) return;

        // Seleção de Inimigo baseada no asset
        let typeKey = 'enemy_basic';
        let hp = 20 + (STATE.level * 2);
        let speed = 60 + Math.random() * 20;

        const rand = Math.random();
        if(rand > 0.9 && this.textures.exists('enemy_tank')) {
            typeKey = 'enemy_tank';
            hp *= 3;
            speed *= 0.5;
        } else if (rand > 0.7 && this.textures.exists('enemy_fast')) {
            typeKey = 'enemy_fast';
            hp *= 0.6;
            speed *= 1.5;
        }

        // Se a textura não existir, usa fallback
        if(!this.textures.exists(typeKey)) typeKey = 'fallback_enemy';

        const e = this.enemies.create(x, y, typeKey);
        e.hp = hp;
        e.speed = speed;
    }

    spawnBoss() {
        const data = BOSS_DB[Math.floor(Math.random() * BOSS_DB.length)];
        const x = this.player.x + 500; 
        const y = this.player.y;

        const bossKey = this.textures.exists('boss') ? 'boss' : 'fallback_enemy';
        const boss = this.enemies.create(x, y, bossKey);
        
        boss.setScale(data.scale);
        if(data.tint) boss.setTint(data.tint);
        
        boss.isBoss = true;
        boss.maxHp = 800 * STATE.level * (data.hpMult/100);
        boss.hp = boss.maxHp;
        boss.aiType = data.ai;
        boss.state = 'CHASE'; 
        boss.stateTimer = 0;
        boss.speed = 50;

        const alert = document.getElementById('boss-alert');
        alert.innerText = `ALERTA: ${data.name}`;
        alert.style.display = 'block';
        setTimeout(() => alert.style.display = 'none', 4000);
    }

    updateBossAI(boss, time) {
        if(time < boss.stateTimer) return;
        const dist = Phaser.Math.Distance.Between(boss.x, boss.y, this.player.x, this.player.y);

        if(boss.state === 'CHASE') {
            this.physics.moveToObject(boss, this.player, boss.speed);
            if(dist < 250) {
                boss.state = 'ATTACK';
                boss.stateTimer = time + 1000;
                boss.body.setVelocity(0);
            }
        } else if (boss.state === 'ATTACK') {
            if(boss.aiType === 'charger') this.physics.moveToObject(boss, this.player, 350);
            else if (boss.aiType === 'shooter') {
                 // Dispara projétil simples usando asset de bala
                 const bKey = this.textures.exists('bullet') ? 'bullet' : 'fallback_enemy';
                 const b = this.enemies.create(boss.x, boss.y, bKey);
                 b.hp = 1; b.speed = 250; b.setScale(1.5); b.setTint(0xff0000);
                 this.physics.moveToObject(b, this.player, 250);
            }
            boss.state = 'COOLDOWN';
            boss.stateTimer = time + 2000;
        } else if (boss.state === 'COOLDOWN') {
            boss.state = 'CHASE';
        }
    }

    // ================== UTILS ==================

    tickSecond() {
        if(STATE.isPaused) return;
        STATE.time++;
        const m = Math.floor(STATE.time / 60).toString().padStart(2,'0');
        const s = (STATE.time % 60).toString().padStart(2,'0');
        document.getElementById('hud-time').innerText = `${m}:${s}`;
        
        // Spawn Boss a cada 60s
        if(STATE.time % 60 === 0 && STATE.time > 0) this.spawnBoss();
    }

    openLevelUp() {
        STATE.isPaused = true;
        this.physics.pause();
        const screen = document.getElementById('levelup-screen');
        const list = document.getElementById('upgrade-list');
        list.innerHTML = '';
        screen.classList.remove('hidden');

        // Escolhe 3 upgrades
        for(let i=0; i<3; i++) {
            const item = WEAPONS_DB[Math.floor(Math.random()*WEAPONS_DB.length)];
            const card = document.createElement('div');
            card.className = 'card';
            card.innerHTML = `<h3>${item.name}</h3><small>${item.type.toUpperCase()}</small><p>${item.desc}</p>`;
            card.onclick = () => {
                this.addWeapon(item.id);
                screen.classList.add('hidden');
                STATE.isPaused = false;
                this.physics.resume();
            };
            list.appendChild(card);
        }
    }

    addWeapon(id) {
        const stats = WEAPONS_DB.find(x => x.id === id);
        const existing = STATE.weapons.find(w => w.id === id);
        
        if(existing) {
            existing.dmg *= 1.3;
            if(existing.type === 'orbital') {
                existing.count++;
                this.rebuildOrbitals(existing);
            }
        } else {
            const newWep = { ...stats, nextFire: 0 };
            if(newWep.type === 'aura') {
                // Aura usa um gráfico simples circular
                const g = this.make.graphics().fillStyle(newWep.color, 0.2).fillCircle(100,100,100);
                g.generateTexture('aura_'+id, 200, 200);
                newWep.sprite = this.physics.add.sprite(0,0,'aura_'+id);
                this.bullets.add(newWep.sprite);
                newWep.sprite.isAura = true;
                newWep.sprite.weaponRef = newWep;
            }
            if(newWep.type === 'orbital') {
                this.rebuildOrbitals(newWep);
            }
            STATE.weapons.push(newWep);
        }
    }

    rebuildOrbitals(wep) {
        if(wep.sprites) wep.sprites.forEach(s => s.destroy());
        wep.sprites = [];
        // Usa bullet como orbital
        const bKey = this.textures.exists('bullet') ? 'bullet' : 'fallback_player';
        for(let i=0; i<wep.count; i++) {
            const s = this.physics.add.sprite(0,0,bKey);
            s.setTint(wep.color);
            s.isOrbital = true; s.weaponRef = wep;
            this.bullets.add(s);
            wep.sprites.push(s);
        }
    }
}

function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    new Phaser.Game({
        type: Phaser.AUTO,
        width: window.innerWidth,
        height: window.innerHeight,
        backgroundColor: '#050505',
        parent: 'game-container',
        physics: { default: 'arcade', arcade: { debug: false } },
        scene: MainScene
    });
}
</script>
</body>
</html>


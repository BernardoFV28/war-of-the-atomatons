<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>War of the Automatons V1.3 - A Cruzada da Rainha</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #0a0000ce;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh; /* Garante que o body ocupe a altura total da viewport */
    }
    #game-container {
      width: 100%; /* Permite que o Phaser.Scale gerencie o tamanho */
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas {
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
<div id="game-container"></div>
<script>
const config = {
  type: Phaser.AUTO,
  width: 1380,
  height: 580,
  backgroundColor: '#000000',
  physics: {
    default: 'arcade',
    arcade: { debug: false }
  },
  scale: { // Melhoria: Configuração de escala para responsividade
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
    parent: 'game-container', // Onde o jogo será inserido
    width: 1380,
    height: 580
  },
  scene: {
    preload: preloadScene,
    create,
    update
  }
};

let waveText;
let hudGroup;
let armaNomeText;
let armaImagem;
let player, cursors;
let bullets, enemies, enemyBullets, armas, itemsGroup;
let lastShoot = 0;
let score = 0;
let scoreText;
let healthText;
let playerHealth = 100;
let playerMaxHealth = 100;
let playerSpeed = 400;
let playerDamage = 10;
let wave = 1;
let enemiesToSpawn = 5;
let enemiesKilledThisWave = 0;
let enemySpawnDelay = 1000;
let lastEnemySpawnTime = 0;
let gameOver = false;
let bossMode = false;
let bossHealthBar;
let bossHealthBarBackground;
let bossNameText;
let boss;

// New variables for Obstacles and Mechanics
let obstaclesGroup;
let powerUpGroup;
let cursedItemGroup;
let holographicClonesGroup;

let killStreak = 0;
let comboText;
let frenzyActive = false;
let frenzyTimer = null; // Inicializar como null
let playerOriginalDamage;
let playerOriginalTint;
let playerIsSlowed = false;
let playerSpeedRestoreTimer = null;
let originalPlayerSpeed; // Declare globally for applySlowEffect

// Temporary effect display
let temporaryEffectText = null; // Inicializar como null
let temporaryEffectTimer = null; // Inicializar como null

// Tween de brilho do Frenesi
let frenzyTintTween = null;

// Player Inventory and Items
const playerInventory = {
  activableItems: {
    "Óculos de Visão Térmica": { count: 1, cooldown: 15000, lastUsed: 0, ready: true },
    "Módulo de Escudo": { count: 1, cooldown: 20000, lastUsed: 0, ready: true },
    "Circuito de Sobrecarga": { count: 1, cooldown: 25000, lastUsed: 0, ready: true },
    "DPE (Dispositivo de Posicionamento Espacial)": { count: 1, cooldown: 30000, lastUsed: 0, ready: true },
    "Ampola de Cura": { count: 1, cooldown: 10000, lastUsed: 0, ready: true },
    "Projetor Holográfico": { count: 1, cooldown: 45000, lastUsed: 0, ready: true }
  },
  passiveItems: {
    "Blindagem Reforçada": { description: "Reduz o dano recebido em 10%." },
    "Calibragem de Precisão": { description: "Aumenta a velocidade do projétil em 20%." },
    "Fonte de Energia Extra": { description: "Reduz o tempo de recarga das habilidades ativáveis em 15%." }
  }
};

const itemOptions = [
  { nome: "Óculos de Visão Térmica", tipo: "activable", hotkey: "Q" },
  { nome: "Módulo de Escudo", tipo: "activable", hotkey: "E" },
  { nome: "Circuito de Sobrecarga", tipo: "activable", hotkey: "R" },
  { nome: "DPE (Dispositivo de Posicionamento Espacial)", tipo: "activable", hotkey: "F" },
  { nome: "Ampola de Cura", tipo: "activable", hotkey: "G" },
  { nome: "Projetor Holográfico", tipo: "activable", hotkey: "T" }
];

// Weapon system variables
const weapons = {
    'pistol': { damage: 10, fireRate: 200, bulletSpeed: 400, sprite: 'pistol' },
    'shotgun': { damage: 15, fireRate: 600, bulletSpeed: 300, sprite: 'shotgun', pellets: 3, spread: 0.2 },
    'rifle': { damage: 20, fireRate: 100, bulletSpeed: 600, sprite: 'rifle' },
    // 'laserGun': { damage: 25, fireRate: 50, bulletSpeed: 800, sprite: 'laserGun' }, // Removido
    // 'plasmaGun': { damage: 30, fireRate: 400, bulletSpeed: 350, sprite: 'plasmaGun', areaDamage: true } // Removido
};
let currentWeapon = 'pistol'; // Default weapon

// UI Class for Inventory Display
class InventoryUI {
  constructor(scene) {
      this.scene = scene;
      this.inventoryText = this.scene.add.text(10, config.height - 150, '', {
          fontSize: '16px',
          color: '#00FF00',
          backgroundColor: '#333333',
          padding: { x: 5, y: 5 }
      }).setScrollFactor(0).setDepth(100);

      this.weaponSelectorText = this.scene.add.text(config.width - 200, config.height - 50, '', {
          fontSize: '18px',
          color: '#00FFFF',
          backgroundColor: '#333333',
          padding: { x: 5, y: 5 }
      }).setScrollFactor(0).setDepth(100);

      this.updateInventoryDisplay();
      this.updateWeaponDisplay();
  }

  updateInventoryDisplay() {
      let inventoryDisplay = "Inventário:\n";
      let hasActivable = false;
      const time = this.scene.time.now;

      for (const itemKey in playerInventory.activableItems) {
          const itemData = playerInventory.activableItems[itemKey];
          if (itemData.count > 0) {
              hasActivable = true;
              let status = "";
              if (!itemData.ready) {
                  const remainingTime = Math.ceil((itemData.cooldown - (time - itemData.lastUsed)) / 1000);
                  status = ` (Recarga: ${remainingTime}s)`;
              } else {
                  status = " (PRONTO)";
              }
              const itemInfo = itemOptions.find(opt => opt.nome === itemKey);
              const hotkey = itemInfo ? ` (${itemInfo.hotkey})` : '';

              inventoryDisplay += `- ${itemKey}${hotkey}${status}\n`;
          }
      }
      if (!hasActivable) {
          inventoryDisplay += "Nenhum Ativável\n";
      }

      inventoryDisplay += "\nItens Passivos:\n";
      let hasPassive = false;
      for (const itemKey in playerInventory.passiveItems) {
        const itemData = playerInventory.passiveItems[itemKey];
        if (itemData) {
            hasPassive = true;
            inventoryDisplay += `- ${itemKey}: ${itemData.description}\n`;
        }
      }
      if (!hasPassive) {
          inventoryDisplay += "Nenhum Passivo\n";
      }

      this.inventoryText.setText(inventoryDisplay);
  }

  updateWeaponDisplay() {
      this.weaponSelectorText.setText(`Arma: ${currentWeapon.toUpperCase()}`);
      // Melhoria: Atualizar imagem da arma no HUD
      if (armaImagem) {
          armaImagem.setTexture(currentWeapon);
          armaImagem.setScale(0.5); // Ajuste a escala conforme necessário
      }
  }

  displayTemporaryEffect(effectName, durationSeconds) {
    if (temporaryEffectText) {
        temporaryEffectText.destroy(); // Destroi o texto anterior para evitar acúmulo
        temporaryEffectText = null;
    }
    if (temporaryEffectTimer) {
        temporaryEffectTimer.remove(false); // Remove o timer anterior
        temporaryEffectTimer = null;
    }

    temporaryEffectText = this.scene.add.text(config.width / 2, config.height / 2 + 100, effectName, {
      fontSize: '32px',
      color: '#FFFF00',
      fontStyle: 'bold',
      shadow: {
        offsetX: 2,
        offsetY: 2,
        color: '#000000',
        blur: 4,
        stroke: true,
        fill: true
      }
    }).setOrigin(0.5).setDepth(100);

    temporaryEffectTimer = this.scene.time.delayedCall(durationSeconds * 1000, () => {
        if (temporaryEffectText) {
            temporaryEffectText.destroy();
            temporaryEffectText = null;
        }
    }, [], this.scene);
  }
}

let inventoryUI;

function preloadScene() {
    // Background Image
    this.load.image('bg', 'assets/fundogame.png');

    // Player and Projectiles
    this.load.image('player', 'assets/player.png');
    this.load.image('bullet', 'assets/bullet.png');
    this.load.image('enemyBullet', 'assets/enemy_bullet.png');

    // Enemies (using specific enemy types if you have them, otherwise fallback to generic 'enemy.png')
    this.load.image('enemy_robot', 'assets/enemy_robot.png');
    this.load.image('enemy_fast', 'assets/enemy_fast.png');
    this.load.image('enemy_tank', 'assets/enemy_tank.png');
    this.load.image('boss_robot', 'assets/boss_robot.png');

    // Weapons
    this.load.image('pistol', 'assets/pistolinha.png');
    this.load.image('shotgun', 'assets/lancarraio.png');
    this.load.image('rifle', 'assets/metralha.png');
    // this.load.image('laserGun', 'assets/laser_gun.png'); // Removido
    // this.load.image('plasmaGun', 'assets/plasma_gun.png'); // Removido

    // Obstacle Assets
    this.load.image('scrapBlock', 'assets/scrap_block.png');
    this.load.image('electricCoil', 'assets/electric_coil.png');
    this.load.image('explosiveDrone', 'assets/explosive_drone.png');
    this.load.image('turret', 'assets/turret.png');
    this.load.image('magneticDistortion', 'assets/magnetic_distortion.png');

    // Power-up Assets
    this.load.image('powerUpSpeed', 'assets/powerup_speed.png');
    this.load.image('powerUpHealth', 'assets/powerup_health.png');
    this.load.image('powerUpShield', 'assets/powerup_shield.png');

    // Cursed Item Asset
    this.load.image('cursedItem', 'assets/cursed_item.png');

    // Holographic Clone Asset
    this.load.image('holographicClone', 'assets/holographic_clone.png');

    // Melhoria: Assets para Partículas (Removido sparkle e powerup_sparkle)
    // this.load.image('sparkle', 'assets/sparkle.png');
    // this.load.image('powerup_sparkle', 'assets/powerup_sparkle.png');

    // Other potentially missing assets based on your list:
    this.load.image('ammo', 'assets/ammo.png');
    this.load.image('card', 'assets/card.png');
    this.load.image('cor.a', 'assets/cor.a.png');
    this.load.image('f', 'assets/f.png');
    this.load.image('fundo-errado', 'assets/fundo-errado.png');
    this.load.image('granade', 'assets/granade.png');
    this.load.image('m', 'assets/m.png');
    this.load.image('o', 'assets/o.png');
    // A metralha já está listada como rifle, mas foi mantida aqui por estar na lista original de "outros assets"
    this.load.image('metralha', 'assets/metralha.png');
}

function create() {
    // Background image
    this.add.image(config.width / 2, config.height / 2, 'bg').setScrollFactor(0).setDepth(0);

    // Player
    player = this.physics.add.sprite(config.width / 4, config.height / 2, 'player');
    player.setCollideWorldBounds(true);
    player.setOrigin(0.5);
    player.setDepth(5);
    player.setDamping(true).setDrag(0.99);

    // Melhoria: Camera Follow
    this.cameras.main.startFollow(player, true, 0.05, 0.05); // Segue o jogador com um pequeno atraso para suavizar

    cursors = this.input.keyboard.createCursorKeys();

    // Groups
    bullets = this.physics.add.group({
        defaultKey: 'bullet',
        maxSize: 30 // Limita o número de balas ativas para performance
    });
    enemies = this.physics.add.group(); // Inimigos são destruídos, não pooled
    enemyBullets = this.physics.add.group({
        defaultKey: 'enemyBullet',
        maxSize: 50 // Limita o número de balas inimigas ativas
    });
    armas = this.physics.add.group(); // Group for weapon pickups
    itemsGroup = this.physics.add.group(); // Group for generic item pickups

    // New groups for obstacles and mechanics
    obstaclesGroup = this.physics.add.group();
    powerUpGroup = this.physics.add.group();
    cursedItemGroup = this.physics.add.group();
    holographicClonesGroup = this.physics.add.group();

    // HUD
    scoreText = this.add.text(10, 10, 'Score: 0', { fontSize: '20px', fill: '#FFF' }).setScrollFactor(0);
    healthText = this.add.text(10, 30, `Health: ${playerHealth}/${playerMaxHealth}`, { fontSize: '20px', fill: '#FFF' }).setScrollFactor(0);
    waveText = this.add.text(config.width - 150, 10, 'Wave: 1', { fontSize: '20px', fill: '#FFF' }).setScrollFactor(0);

    // Combo Text
    comboText = this.add.text(config.width / 2, 50, 'Combo: 0', {
        fontSize: '24px',
        fill: '#FFD700', // Gold color
        fontStyle: 'bold',
        shadow: { offsetX: 2, offsetY: 2, color: '#000000', blur: 4, stroke: true, fill: true }
    }).setOrigin(0.5).setScrollFactor(0).setDepth(100).setVisible(false);

    // Melhoria: Imagem da arma no HUD
    armaImagem = this.add.image(config.width - 150, 80, currentWeapon)
                         .setScrollFactor(0)
                         .setDepth(100)
                         .setScale(0.5)
                         .setOrigin(0.5);

    // Initialize Inventory UI
    inventoryUI = new InventoryUI(this);
    inventoryUI.updateWeaponDisplay(); // Garante que a imagem inicial da arma seja exibida

    // Store original player speed for slow effect restoration
    originalPlayerSpeed = playerSpeed;

    // Initial Spawns
    spawnEnemies();
    spawnObstacles(wave);

    // Collisions
    this.physics.add.collider(bullets, enemies, hitEnemy, null, this);
    this.physics.add.overlap(player, enemies, hitPlayer, null, this);
    this.physics.add.overlap(player, enemyBullets, hitPlayer, null, this);
    this.physics.add.overlap(player, armas, pickUpArma, null, this);
    this.physics.add.overlap(player, itemsGroup, pickUpItem, null, this);

    // New Collisions for Obstacles and Mechanics
    this.physics.add.collider(bullets, obstaclesGroup, hitObstacle, null, this);
    this.physics.add.collider(player, obstaclesGroup, playerHitObstacle, null, this);
    this.physics.add.collider(enemyBullets, obstaclesGroup, hitObstacle, null, this);
    this.physics.add.overlap(player, powerUpGroup, pickUpPowerUp, null, this);
    this.physics.add.overlap(player, cursedItemGroup, pickUpCursedItem, null, this);
    this.physics.add.collider(holographicClonesGroup, enemies, (clone, enemy) => {
        // Enemies will be distracted by the clone.
        // Optional: enemies could deal "damage" to clone, and it disappears after a certain amount
        // For now, they just collide and are distracted.
    }, null, this);
    this.physics.add.collider(holographicClonesGroup, enemyBullets, (clone, enemyBullet) => {
        enemyBullet.destroy(); // Enemy bullets hit clone and are destroyed
    }, null, this);


    // Keyboard controls for activable items
    this.input.keyboard.on('keydown-Q', () => useActivableItem("Óculos de Visão Térmica", this));
    this.input.keyboard.on('keydown-E', () => useActivableItem("Módulo de Escudo", this));
    this.input.keyboard.on('keydown-R', () => useActivableItem("Circuito de Sobrecarga", this));
    this.input.keyboard.on('keydown-F', () => useActivableItem("DPE (Dispositivo de Posicionamento Espacial)", this));
    this.input.keyboard.on('keydown-G', () => useActivableItem("Ampola de Cura", this));
    this.input.keyboard.on('keydown-T', () => useActivableItem("Projetor Holográfico", this));

    // Keyboard control for shooting (event listener instead of checking every frame)
    this.input.keyboard.on('keydown-SPACE', (event) => {
        if (this.time.now > lastShoot) {
            shootBullet(player.x, player.y, currentWeapon);
            lastShoot = this.time.now + weapons[currentWeapon].fireRate;
        }
    });

    // Store original player damage
    playerOriginalDamage = playerDamage;
    playerOriginalTint = player.tint;

    // Initial weapon pickup for testing
    // pickUpArma.call(this, player, { texture: { key: 'shotgun' }, destroy: () => {} });
}

function update(time, delta) {
    if (gameOver) {
        return;
    }

    // Player Movement
    player.setVelocity(0);
    if (cursors.left.isDown) {
        player.setVelocityX(-playerSpeed);
    } else if (cursors.right.isDown) {
        player.setVelocityX(playerSpeed);
    }
    if (cursors.up.isDown) {
        player.setVelocityY(-playerSpeed);
    } else if (cursors.down.isDown) {
        player.setVelocityY(playerSpeed);
    }
    player.body.velocity.normalize().scale(playerSpeed); // Normaliza para que o movimento diagonal não seja mais rápido

    // Enemy AI and Spawning
    enemies.children.each(function(enemy) {
        if (enemy && enemy.active) {
            // Simple enemy movement: move towards player or clone if active
            let target = player;
            if (holographicClonesGroup.getLength() > 0) {
                const closestClone = this.physics.closest(enemy, holographicClonesGroup.getChildren());
                if (closestClone) {
                    target = closestClone;
                }
            }
            this.physics.moveToObject(enemy, target, enemy.speed);

            // Simple enemy shooting
            if (time > enemy.lastShotTime + enemy.fireRate) {
                shootEnemyBullet(enemy.x, enemy.y, target);
                enemy.lastShotTime = time;
            }
        }
    }, this);

    // Boss health bar update (if boss mode is active)
    if (bossMode && bossHealthBar && bossHealthBarBackground && boss && boss.active) {
        bossHealthBar.width = (boss.health / boss.maxHealth) * bossHealthBarBackground.width;
    }

    // Wave progression and enemy spawning
    if (enemiesKilledThisWave >= enemiesToSpawn && !bossMode && enemies.countActive(true) === 0) {
        startNextWave.call(this);
    } else if (!bossMode && time > lastEnemySpawnTime + enemySpawnDelay && enemies.countActive(true) < enemiesToSpawn) {
        spawnEnemies.call(this);
        lastEnemySpawnTime = time;
    }

    // Update inventory display (for cooldowns)
    inventoryUI.updateInventoryDisplay();

    // Update combo text visibility
    if (killStreak > 0) {
        comboText.setVisible(true);
        comboText.setText(`Combo: ${killStreak}`);
        if (killStreak >= 15 && !frenzyActive) {
            activateFrenzy.call(this);
        }
    } else {
        comboText.setVisible(false);
    }
}

function shootBullet(x, y, weaponType) {
    const weapon = weapons[weaponType];
    const bulletSpeed = weapon.bulletSpeed;
    const bulletDamage = weapon.damage;

    // Melhoria: Calibragem de Precisão para velocidade de projétil
    let finalBulletSpeed = bulletSpeed;
    if (playerInventory.passiveItems["Calibragem de Precisão"]) {
        finalBulletSpeed *= 1.2; // Aumenta velocidade em 20%
    }


    if (weapon.pellets) { // Shotgun-like behavior
        for (let i = 0; i < weapon.pellets; i++) {
            const bullet = bullets.get(x, y);
            if (bullet) {
                const angle = Phaser.Math.Angle.Between(x, y, this.input.mousePointer.x, this.input.mousePointer.y);
                const spread = Phaser.Math.RND.between(-weapon.spread * 100, weapon.spread * 100) / 100;
                const finalAngle = angle + spread;

                bullet.setActive(true).setVisible(true).setRotation(finalAngle);
                this.physics.velocityFromRotation(finalAngle, finalBulletSpeed, bullet.body.velocity);
                bullet.setTint(frenzyActive ? 0xFFD700 : 0xFFFFFF);
                bullet.setData('damage', bulletDamage); // Store damage in bullet data
            }
        }
    } else { // Single projectile
        const bullet = bullets.get(x, y);
        if (bullet) {
            const angle = Phaser.Math.Angle.Between(x, y, this.input.mousePointer.x, this.input.mousePointer.y);
            bullet.setActive(true).setVisible(true).setRotation(angle);
            this.physics.velocityFromRotation(angle, finalBulletSpeed, bullet.body.velocity);
            bullet.setTint(frenzyActive ? 0xFFD700 : 0xFFFFFF);
            bullet.setData('damage', bulletDamage); // Store damage in bullet data
        }
    }
}

function shootEnemyBullet(x, y, target) {
    const enemyBullet = enemyBullets.get(x, y);
    if (enemyBullet) {
        enemyBullet.setActive(true).setVisible(true);
        this.physics.moveToObject(enemyBullet, target, 150 + (wave * 5)); // Aumenta velocidade da bala inimiga com a onda
    }
}

function hitEnemy(bullet, enemy) {
    // Adicionado verificação extra para garantir que os objetos são válidos antes de continuar
    if (!bullet || !enemy || !bullet.active || !enemy.active) return;

    // Melhoria: Flash de dano no inimigo
    this.tweens.add({
        targets: enemy,
        tint: 0xff0000,
        duration: 100,
        yoyo: true,
        onComplete: () => {
            enemy.setTint(0xFFFFFF);
        }
    });

    // Melhoria: Texto de dano flutuante
    let damageAmount = bullet.getData('damage') || playerDamage;
    let damageText = this.add.text(enemy.x, enemy.y - 20, `${damageAmount}`, {
        fontSize: '16px',
        fill: '#FFD700',
        fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(10);
    this.tweens.add({
        targets: damageText,
        y: damageText.y - 50,
        alpha: 0,
        duration: 800,
        onComplete: () => damageText.destroy() // Garante que o texto de dano seja destruído
    });

    bullet.setActive(false).setVisible(false); // Inativa a bala em vez de destruir
    enemy.health -= damageAmount;
    if (enemy.health <= 0) {
        enemy.destroy(); // Destrói o inimigo
        score += 100 + (wave * 10); // Aumenta o score por inimigo com a onda
        scoreText.setText('Score: ' + score);
        enemiesKilledThisWave++;
        killStreak++;

        // Melhoria: Partículas na destruição do inimigo (REMOVIDO)
        // const emitter = this.add.particles(enemy.x, enemy.y, 'sparkle', {
        //     speed: { min: -200, max: 200 },
        //     angle: { min: 0, max: 360 },
        //     scale: { start: 0.8, end: 0 },
        //     blendMode: 'ADD',
        //     lifespan: 600,
        //     gravityY: 100
        // });
        // emitter.explode(15);
        // this.time.delayedCall(700, () => emitter.stop(), [], this);

        dropPowerUp.call(this, enemy.x, enemy.y);
        dropCursedItem.call(this, enemy.x, enemy.y);
    }
}

function hitPlayer(player, target) {
    if (!player || !target || !player.active || !target.active) return; // Adicionado verificação extra

    // Melhoria: Camera Shake
    this.cameras.main.shake(100, 0.005); // Pequeno tremor ao ser atingido

    if (player.immune) {
        this.add.tween({
            targets: player,
            alpha: { from: 0.5, to: 0.8 },
            ease: 'Sine.easeInOut',
            duration: 100,
            yoyo: true,
            repeat: 0
        });
        if (target.active) target.destroy(); // Destrói o projétil inimigo ou o inimigo de colisão
        return;
    }

    // Melhoria: Flash de dano no jogador
    this.tweens.add({
        targets: player,
        tint: 0xff0000,
        duration: 100,
        yoyo: true,
        onComplete: () => {
            player.setTint(playerOriginalTint); // Retorna à tintura original (ou do frenesi se ativo)
        }
    });

    let damageTaken = 10;
    // Otimização: Acesso direto ao 'data' para projéteis que podem ter 'damage'
    if (target.body.gameObject && target.body.gameObject.data && target.body.gameObject.data.values.damage) {
        damageTaken = target.body.gameObject.data.values.damage;
    } else {
        damageTaken = 10; // Dano padrão para inimigos que colidem
    }

    if (player.damageMultiplier) {
        damageTaken *= player.damageMultiplier;
    }
    // Aplica efeito de item passivo "Blindagem Reforçada"
    if (playerInventory.passiveItems["Blindagem Reforçada"]) {
        damageTaken *= 0.9; // Reduz dano em 10%
    }


    if (target.active) target.destroy(); // Destroi a bala ou inimigo que causou dano
    playerHealth -= damageTaken;
    healthText.setText(`Health: ${Math.max(0, playerHealth)}/${playerMaxHealth}`);
    killStreak = 0;
    if (frenzyActive) {
        deactivateFrenzy.call(this); // Ensure context is passed
    }

    if (playerHealth <= 0) {
        endGame(this);
    }
}

function pickUpArma(player, arma) {
    if (!arma || !arma.active) return;

    // Melhoria: Animação de pickup do item
    this.tweens.add({
        targets: arma,
        x: player.x,
        y: player.y,
        alpha: 0,
        scale: 0.5,
        duration: 300,
        ease: 'Cubic.easeIn',
        onComplete: () => {
            const weaponType = arma.getData('weaponType');
            if (weaponType && weapons[weaponType]) {
                currentWeapon = weaponType;
                playerDamage = weapons[currentWeapon].damage;
                inventoryUI.updateWeaponDisplay();
                inventoryUI.displayTemporaryEffect(`Nova Arma: ${weaponType.toUpperCase()}`, 2);
            }
            arma.destroy();
        }
    });
}

function pickUpItem(player, item) {
    if (!item || !item.active) return;

    // Melhoria: Animação de pickup do item
    this.tweens.add({
        targets: item,
        x: player.x,
        y: player.y,
        alpha: 0,
        scale: 0.5,
        duration: 300,
        ease: 'Cubic.easeIn',
        onComplete: () => item.destroy()
    });
}

// New Obstacle Collision Handlers
function hitObstacle(projectile, obstacle) {
    if (!projectile || !obstacle || !projectile.active || !obstacle.active) return;

    if (obstacle.getData('type') === 'explosiveDrone') {
        obstacle.health -= projectile.getData('damage') || 10;
        if (obstacle.health <= 0) {
            obstacle.detonate();
        }
    }
    projectile.setActive(false).setVisible(false); // Inativa o projétil
}

function playerHitObstacle(player, obstacle) {
    if (!player || !obstacle || !player.active || !obstacle.active) return;

    if (obstacle.getData('type') === 'explosiveDrone') {
        obstacle.detonate();
    } else if (obstacle.getData('type') === 'electricCoil') {
        applySlowEffect.call(this, player, 3);
    }
    // For static obstacles, default collider behavior handles collision.
}

// Obstacle Spawning
function spawnObstacles(wave) {
    // Otimização: Limpa o grupo de obstáculos antes de gerar novos, para evitar acúmulo
    obstaclesGroup.clear(true, true);

    const obstacleTypes = [];
    if (wave >= 2) {
        obstacleTypes.push('scrapBlock');
    }
    if (wave >= 4) {
        obstacleTypes.push('electricCoil');
    }
    if (wave >= 6) {
        obstacleTypes.push('explosiveDrone');
    }
    if (wave >= 8) {
        obstacleTypes.push('turret');
    }
    if (wave >= 10) {
        obstacleTypes.push('magneticDistortion');
    }

    if (obstacleTypes.length === 0) {
        return;
    }

    const numObstacles = Math.min(Math.floor(wave / 2) + 1, 10 + Math.floor(wave / 5));

    for (let i = 0; i < numObstacles; i++) {
        const type = Phaser.Utils.Array.GetRandom(obstacleTypes);
        let obstacle;

        let x, y;
        let attempts = 0;
        const minDistance = 100;
        do {
            x = Phaser.Math.Between(config.width * 0.4, config.width * 0.9);
            y = Phaser.Math.Between(config.height * 0.1, config.height * 0.9);
            let tooClose = false;
            // Otimização: Evitar criar obstáculos muito próximos uns dos outros
            obstaclesGroup.children.each(existingObstacle => {
                if (existingObstacle.active && Phaser.Math.Distance.Between(x, y, existingObstacle.x, existingObstacle.y) < minDistance) {
                    tooClose = true;
                }
            });
            if (!tooClose) break;
            attempts++;
        } while (attempts < 10);

        switch (type) {
            case 'scrapBlock':
                obstacle = obstaclesGroup.create(x, y, 'scrapBlock');
                obstacle.setImmovable(true);
                obstacle.setDepth(2);
                obstacle.setData('type', 'scrapBlock');
                obstacle.body.setSize(obstacle.width * 0.8, obstacle.height * 0.8);
                break;
            case 'electricCoil':
                obstacle = obstaclesGroup.create(x, y, 'electricCoil');
                obstacle.setImmovable(true);
                obstacle.setDepth(2);
                obstacle.setData('type', 'electricCoil');
                obstacle.body.setSize(obstacle.width * 0.7, obstacle.height * 0.7);
                // Otimização: Armazena o evento para poder removê-lo se o obstáculo for destruído
                obstacle.pulseEvent = this.time.addEvent({
                    delay: 3000,
                    callback: () => emitElectricPulse.call(this, obstacle),
                    loop: true,
                    callbackScope: this
                });
                break;
            case 'explosiveDrone':
                obstacle = obstaclesGroup.create(x, y, 'explosiveDrone');
                obstacle.setImmovable(true);
                obstacle.setDepth(2);
                obstacle.setData('type', 'explosiveDrone');
                obstacle.health = 50 + (wave * 5);
                obstacle.detonate = function() {
                    // Otimização: Destruir o objeto de explosão após a animação
                    const explosion = this.scene.add.circle(this.x, this.y, 50, 0xFF0000, 0.5);
                    this.scene.tweens.add({
                        targets: explosion,
                        radius: 100,
                        alpha: 0,
                        ease: 'Quart.easeOut',
                        duration: 300,
                        onComplete: () => explosion.destroy()
                    });

                    const distanceToPlayer = Phaser.Math.Distance.Between(player.x, player.y, this.x, this.y);
                    if (distanceToPlayer < 150) {
                        let damage = 20 + (wave * 2);
                        if (player.immune) {
                            this.scene.add.tween({
                                targets: player,
                                alpha: { from: 0.5, to: 0.8 },
                                ease: 'Sine.easeInOut',
                                duration: 100,
                                yoyo: true,
                                repeat: 0
                            });
                        } else {
                            if (player.damageMultiplier) damage *= player.damageMultiplier;
                            // Aplica efeito de item passivo "Blindagem Reforçada"
                            if (playerInventory.passiveItems["Blindagem Reforçada"]) {
                                damage *= 0.9;
                            }
                            playerHealth -= damage;
                            healthText.setText(`Health: ${Math.max(0, playerHealth)}/${playerMaxHealth}`);
                            killStreak = 0;
                            if (frenzyActive) deactivateFrenzy.call(this.scene);
                            if (playerHealth <= 0) endGame(this.scene);
                        }
                    }
                    this.destroy(); // Destrói o drone
                };
                this.physics.add.collider(bullets, obstacle, (bullet, drone) => {
                    if (bullet.active && drone.active) {
                        bullet.setActive(false).setVisible(false); // Inativa a bala
                        drone.health -= bullet.getData('damage') || playerDamage;
                        if (drone.health <= 0) {
                            drone.detonate();
                        }
                    }
                }, null, this);
                break;
            case 'turret':
                obstacle = obstaclesGroup.create(x, y, 'turret');
                obstacle.setImmovable(true);
                obstacle.setDepth(2);
                obstacle.setData('type', 'turret');
                obstacle.fireRate = Phaser.Math.Between(1500, 3000) - (wave * 50);
                if (obstacle.fireRate < 500) obstacle.fireRate = 500;
                obstacle.lastShotTime = 0;
                // Otimização: Armazena o evento para poder removê-lo se a torre for destruída
                obstacle.fireEvent = this.time.addEvent({
                    delay: obstacle.fireRate,
                    callback: () => shootTurretBullet.call(this, obstacle),
                    loop: true,
                    callbackScope: this
                });
                break;
            case 'magneticDistortion':
                obstacle = obstaclesGroup.create(x, y, 'magneticDistortion');
                obstacle.setImmovable(true);
                obstacle.setDepth(2);
                obstacle.setData('type', 'magneticDistortion');
                obstacle.body.setCircle(50);
                this.physics.add.overlap(bullets, obstacle, deflectProjectile, null, this);
                this.physics.add.overlap(enemyBullets, obstacle, deflectProjectile, null, this);
                break;
        }
    }
}

function emitElectricPulse(coil) {
    if (!coil || !coil.active) { // Verifica se a bobina ainda está ativa
        // Otimização: Remove o evento de pulso se a bobina não estiver mais ativa
        if (coil.pulseEvent) {
            coil.pulseEvent.remove(false);
            coil.pulseEvent = null;
        }
        return;
    }

    const pulse = this.add.circle(coil.x, coil.y, 10, 0x00FFFF, 0.3);
    this.tweens.add({
        targets: pulse,
        radius: 150,
        alpha: 0,
        ease: 'Quart.easeOut',
        duration: 1000,
        onComplete: () => pulse.destroy() // Garante que o círculo de pulso seja destruído
    });

    const distanceToPlayer = Phaser.Math.Distance.Between(player.x, player.y, coil.x, coil.y);
    if (distanceToPlayer < 150) {
        applySlowEffect.call(this, player, 2);
    }
}

function applySlowEffect(target, duration) {
    if (playerIsSlowed) {
        // Otimização: Se já está lento, reinicia o timer em vez de aplicar um novo efeito cumulativo
        if (playerSpeedRestoreTimer) {
            playerSpeedRestoreTimer.remove(false);
        }
    } else {
        playerIsSlowed = true;
        originalPlayerSpeed = playerSpeed; // Garante que a velocidade original seja capturada no momento da desaceleração
        playerSpeed *= 0.5;
    }

    inventoryUI.displayTemporaryEffect("Redução de Velocidade", duration);

    playerSpeedRestoreTimer = this.time.delayedCall(duration * 1000, () => {
        playerSpeed = originalPlayerSpeed;
        playerIsSlowed = false;
        playerSpeedRestoreTimer = null;
    }, [], this);
}

function shootTurretBullet(turret) {
    if (!turret || !turret.active) { // Verifica se a torre ainda está ativa
        // Otimização: Remove o evento de tiro se a torre não estiver mais ativa
        if (turret.fireEvent) {
            turret.fireEvent.remove(false);
            turret.fireEvent = null;
        }
        return;
    }

    const bullet = enemyBullets.get(turret.x, turret.y);
    if (bullet) {
        bullet.setActive(true).setVisible(true);
        this.physics.moveToObject(bullet, player, 200 + (wave * 5));
        bullet.setTint(0xFF8C00);
        bullet.setData('damage', 15 + (wave * 2)); // Dano da torre aumenta com a onda
    }
}

function deflectProjectile(projectile, distortionZone) {
    if (!projectile || !distortionZone || !projectile.active || !distortionZone.active) return; // Adicionado verificação extra

    const angleToDistortion = Phaser.Math.Angle.Between(distortionZone.x, distortionZone.y, projectile.x, projectile.y);
    const deflectionForce = 150;

    const newVx = Math.cos(angleToDistortion) * deflectionForce;
    const newVy = Math.sin(angleToDistortion) * deflectionForce;

    const currentSpeed = Phaser.Math.Distance.Between(0, 0, projectile.body.velocity.x, projectile.body.velocity.y);
    const combinedVx = projectile.body.velocity.x * 0.5 + newVx * 0.5;
    const combinedVy = projectile.body.velocity.y * 0.5 + newVy * 0.5;

    const combinedSpeed = Phaser.Math.Distance.Between(0, 0, combinedVx, combinedVy);
    if (combinedSpeed > 0) {
        projectile.setVelocity(
            (combinedVx / combinedSpeed) * currentSpeed,
            (combinedVy / combinedSpeed) * currentSpeed
        );
    } else {
        projectile.setVelocity(newVx, newVy);
    }

    projectile.setTint(0x00FF00);
}

// Frenzy Mode
function activateFrenzy() {
    if (frenzyActive) return;

    frenzyActive = true;
    playerDamage *= 2;
    // Melhoria: Efeito de brilho pulsante para o frenesi
    if (frenzyTintTween) {
        frenzyTintTween.stop(); // Parar qualquer tween anterior
        frenzyTintTween = null; // Resetar referência
    }
    frenzyTintTween = this.tweens.add({
        targets: player,
        tint: { from: 0xFFD700, to: 0xFFA500 }, // Dourado para laranja dourado
        duration: 300,
        yoyo: true,
        repeat: -1, // Repete indefinidamente
        ease: 'Sine.easeInOut'
    });
    // Melhoria: Camera Zoom para Frenesi
    this.cameras.main.zoomTo(1.1, 500); // Zoom in
    inventoryUI.displayTemporaryEffect("FRENESI ATIVO!", 10);

    // Otimização: Garante que o timer anterior seja removido antes de criar um novo
    if (frenzyTimer) frenzyTimer.remove(false);
    frenzyTimer = this.time.delayedCall(10000, deactivateFrenzy, [], this);
}

function deactivateFrenzy() {
    if (!frenzyActive) return;

    frenzyActive = false;
    playerDamage = playerOriginalDamage;
    if (frenzyTintTween) {
        frenzyTintTween.stop(); // Parar a pulsação
        frenzyTintTween = null;
    }
    player.setTint(playerOriginalTint); // Retorna à cor original
    // Melhoria: Camera Zoom out
    this.cameras.main.zoomTo(1, 500); // Zoom out
    if (frenzyTimer) {
        frenzyTimer.remove(false); // Garante que o timer de frenesi seja removido
        frenzyTimer = null;
    }
}

// Power-ups
function dropPowerUp(x, y) {
    if (Math.random() < 0.2) {
        const powerUpTypes = ['speed', 'health', 'shield'];
        const type = Phaser.Utils.Array.GetRandom(powerUpTypes);
        let powerUp;

        switch (type) {
            case 'speed':
                powerUp = powerUpGroup.create(x, y, 'powerUpSpeed');
                break;
            case 'health':
                powerUp = powerUpGroup.create(x, y, 'powerUpHealth');
                break;
            case 'shield':
                powerUp = powerUpGroup.create(x, y, 'powerUpShield');
                break;
        }
        if (powerUp) {
            powerUp.setData('type', type);
            powerUp.setDepth(6);
            powerUp.setVelocityY(50);
            powerUp.setCollideWorldBounds(true);
            powerUp.setBounceY(0.5);
            powerUp.body.setGravityY(300); // Adiciona um pouco de gravidade
        }
    }
}

function pickUpPowerUp(player, powerUp) {
    if (!player || !powerUp || !powerUp.active) return; // Adicionado verificação extra

    const type = powerUp.getData('type');
    let effectDuration = 10;

    // Aplica efeito de item passivo "Fonte de Energia Extra"
    if (playerInventory.passiveItems["Fonte de Energia Extra"]) {
        effectDuration *= 1.15; // Aumenta duração em 15%
    }

    // Melhoria: Animação de pickup do power-up
    this.tweens.add({
        targets: powerUp,
        x: player.x,
        y: player.y,
        alpha: 0,
        scale: 0.5,
        duration: 300,
        ease: 'Cubic.easeIn',
        onComplete: () => {
            // Melhoria: Partículas ao coletar power-up (REMOVIDO)
            // const emitter = this.add.particles(powerUp.x, powerUp.y, 'powerup_sparkle', {
            //     speed: { min: -100, max: 100 },
            //     angle: { min: 0, max: 360 },
            //     scale: { start: 0.5, end: 0 },
            //     blendMode: 'ADD',
            //     lifespan: 400
            // });
            // emitter.explode(10);
            // this.time.delayedCall(450, () => emitter.stop(), [], this);

            powerUp.destroy();
            switch (type) {
                case 'speed':
                    const originalSpeedBeforeBoost = playerSpeed;
                    playerSpeed *= 1.5;
                    inventoryUI.displayTemporaryEffect("Aumento de Velocidade!", effectDuration);
                    // Otimização: Garante que o timer anterior seja removido antes de criar um novo
                    if (playerSpeedRestoreTimer) playerSpeedRestoreTimer.remove(false);
                    this.time.delayedCall(effectDuration * 1000, () => {
                        playerSpeed = originalSpeedBeforeBoost;
                    }, [], this);
                    break;
                case 'health':
                    playerHealth = Math.min(playerMaxHealth, playerHealth + 30);
                    healthText.setText(`Health: ${playerHealth}/${playerMaxHealth}`);
                    inventoryUI.displayTemporaryEffect("Cura Recebida!", 1);
                    break;
                case 'shield':
                    player.setAlpha(0.5);
                    player.immune = true;
                    inventoryUI.displayTemporaryEffect("Escudo Ativo!", effectDuration);
                    this.time.delayedCall(effectDuration * 1000, () => {
                        player.setAlpha(1);
                        player.immune = false;
                    }, [], this);
                    break;
            }
        }
    });
}

// Cursed Items
function dropCursedItem(x, y) {
    // Chance de dropar item amaldiçoado é menor
    if (Math.random() < 0.05) {
        const cursedItem = cursedItemGroup.create(x, y, 'cursedItem');
        cursedItem.setData('type', 'random');
        cursedItem.setDepth(6);
        cursedItem.setVelocityY(50);
        cursedItem.setTint(0x8B0000);
        cursedItem.body.setGravityY(300); // Adiciona um pouco de gravidade
    }
}

function pickUpCursedItem(player, cursedItem) {
    if (!player || !cursedItem || !cursedItem.active) return; // Adicionado verificação extra

    // Melhoria: Animação de pickup do item amaldiçoado
    this.tweens.add({
        targets: cursedItem,
        x: player.x,
        y: player.y,
        alpha: 0,
        scale: 0.5,
        duration: 300,
        ease: 'Cubic.easeIn',
        onComplete: () => {
            cursedItem.destroy();
            const cursedEffects = [
                { name: "Vida Máxima Reduzida!", effect: () => { playerMaxHealth = Math.max(50, playerMaxHealth - 20); playerHealth = Math.min(playerHealth, playerMaxHealth); healthText.setText(`Health: ${playerHealth}/${playerMaxHealth}`); } },
                { name: "Vulnerabilidade!", effect: () => { player.damageMultiplier = 1.5; }, revert: () => { player.damageMultiplier = 1; } },
                { name: "Lentidão!", effect: () => { applySlowEffect.call(this, player, 10); }, // Usar applySlowEffect aqui
                  revert: () => { /* applySlowEffect já lida com a restauração */ } }
            ];

            const chosenEffect = Phaser.Utils.Array.GetRandom(cursedEffects);
            chosenEffect.effect();
            inventoryUI.displayTemporaryEffect(chosenEffect.name, 10);

            if (chosenEffect.revert && chosenEffect.name !== "Lentidão!") { // Lentidão já tem seu próprio timer de reversão
                this.time.delayedCall(10000, chosenEffect.revert, [], this);
            }
        }
    });
}

// Holographic Clone Item Usage
function createHolographicClone() {
    const clone = holographicClonesGroup.create(player.x - 50, player.y, 'holographicClone');
    clone.setDepth(4);
    clone.setAlpha(0.6);
    clone.setImmovable(true);
    clone.health = 1000;

    // Otimização: Garante que o clone seja destruído após o tempo
    this.time.delayedCall(5000, () => {
        if (clone.active) clone.destroy();
    }, [], this);
}

function spawnEnemies() {
    let enemyCount = Math.floor(wave * 1.5);
    const enemySprites = ['enemy_robot', 'enemy_fast', 'enemy_tank'];

    for (let i = 0; i < enemyCount; i++) {
        const x = Phaser.Math.Between(config.width * 0.7, config.width * 0.95);
        const y = Phaser.Math.Between(50, config.height - 50);
        const randomEnemySprite = Phaser.Utils.Array.GetRandom(enemySprites);
        let enemy = enemies.create(x, y, randomEnemySprite);
        enemy.setCollideWorldBounds(true);
        enemy.setBounce(1);
        enemy.setVelocity(Phaser.Math.Between(-100, 100), Phaser.Math.Between(-100, 100));
        enemy.health = 30 + (wave * 5);
        enemy.speed = 100 + (wave * 5);
        enemy.fireRate = 2000 - (wave * 50);
        if (enemy.fireRate < 500) enemy.fireRate = 500;
        enemy.lastShotTime = 0;
        enemy.setDepth(3);
        enemy.setData('damage', 10 + (wave * 1)); // Dano padrão do inimigo em colisão
    }
}

function startNextWave() {
    wave++;
    waveText.setText('Wave: ' + wave);
    enemiesToSpawn = Math.floor(5 + (wave * 2.5));
    enemiesKilledThisWave = 0;
    enemySpawnDelay = Math.max(500, 1000 - (wave * 50));
    lastEnemySpawnTime = this.time.now;

    // Garante que todos os projéteis inimigos são limpos ao iniciar nova onda
    enemyBullets.clear(true, true);
    bullets.clear(true, true);

    // Melhoria: Animação de transição de onda
    const waveStartText = this.add.text(config.width / 2, config.height / 2, `ONDA ${wave}`, {
        fontSize: '80px',
        fill: '#FFFFFF',
        fontStyle: 'bold',
        shadow: {
            offsetX: 5,
            offsetY: 5,
            color: '#FF00FF',
            blur: 10,
            stroke: true,
            fill: true
        }
    }).setOrigin(0.5).setDepth(200).setAlpha(0);

    this.tweens.add({
        targets: waveStartText,
        alpha: 1,
        scale: { from: 0.5, to: 1 },
        ease: 'Back.easeOut',
        duration: 800,
        onComplete: () => {
            this.time.delayedCall(1000, () => {
                this.tweens.add({
                    targets: waveStartText,
                    alpha: 0,
                    scale: 1.2,
                    ease: 'Quad.easeIn',
                    duration: 500,
                    onComplete: () => waveStartText.destroy() // Garante que o texto seja destruído
                });
            }, [], this);
        }
    });


    if (wave % 3 === 0) {
        spawnMiniBoss.call(this, wave);
    } else {
        spawnEnemies.call(this);
    }

    spawnObstacles.call(this, wave);
}

function spawnMiniBoss(currentWave) {
    bossMode = true;
    enemies.clear(true, true); // Clear any remaining normal enemies

    const miniBoss = this.physics.add.sprite(config.width * 0.8, config.height / 2, 'boss_robot');
    miniBoss.setCollideWorldBounds(true);
    miniBoss.setBounce(1);
    miniBoss.setVelocity(-50, 0);
    miniBoss.health = 200 + (currentWave * 20);
    miniBoss.maxHealth = miniBoss.health;
    miniBoss.speed = 80 + (currentWave * 5);
    miniBoss.fireRate = 1000 - (currentWave * 20);
    if (miniBoss.fireRate < 300) miniBoss.fireRate = 300;
    miniBoss.lastShotTime = 0;
    miniBoss.setTint(0xFF0000);
    miniBoss.setScale(2);
    miniBoss.setDepth(3);

    enemies.add(miniBoss);
    boss = miniBoss;

    // Create Boss Health Bar
    bossHealthBarBackground = this.add.graphics();
    bossHealthBarBackground.fillStyle(0x000000, 0.5);
    bossHealthBarBackground.fillRect(config.width / 2 - 150, 20, 300, 20);
    bossHealthBarBackground.setDepth(101).setScrollFactor(0);

    bossHealthBar = this.add.graphics();
    bossHealthBar.fillStyle(0xFF0000, 1);
    bossHealthBar.fillRect(config.width / 2 - 150, 20, 300, 20);
    bossHealthBar.setDepth(102).setScrollFactor(0);

    bossNameText = this.add.text(config.width / 2, 45, 'MINI-CHEFE', {
        fontSize: '18px',
        fill: '#FF0000',
        fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(103).setScrollFactor(0);

    // Override hitEnemy for boss specific logic
    this.physics.add.collider(bullets, boss, hitBoss, null, this);
}

function hitBoss(bullet, boss) {
    if (!bullet || !boss || !bullet.active || !boss.active) return; // Adicionado verificação extra

    // Melhoria: Flash de dano no chefe
    this.tweens.add({
        targets: boss,
        tint: 0xFFF000, // Amarelo vibrante para boss
        duration: 100,
        yoyo: true,
        onComplete: () => {
            boss.setTint(0xFF0000); // Retorna à cor original do boss
        }
    });

    // Melhoria: Texto de dano flutuante no chefe
    let damageAmount = bullet.getData('damage') || playerDamage;
    let damageText = this.add.text(boss.x, boss.y - 40, `${damageAmount}`, {
        fontSize: '24px',
        fill: '#FFFF00',
        fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(10);
    this.tweens.add({
        targets: damageText,
        y: damageText.y - 60,
        alpha: 0,
        duration: 1000,
        onComplete: () => damageText.destroy() // Garante que o texto de dano seja destruído
    });


    bullet.setActive(false).setVisible(false); // Inativa a bala
    boss.health -= damageAmount;
    if (boss.health <= 0) {
        boss.destroy();
        score += 5000 + (wave * 500); // Mais score pelo boss
        scoreText.setText('Score: ' + score);
        bossMode = false;
        // Otimização: Destruir os elementos da barra de vida do boss
        if (bossHealthBar) bossHealthBar.destroy();
        if (bossHealthBarBackground) bossHealthBarBackground.destroy();
        if (bossNameText) bossNameText.destroy();

        // Melhoria: Partículas na destruição do boss (REMOVIDO)
        // const emitter = this.add.particles(boss.x, boss.y, 'sparkle', {
        //     speed: { min: -300, max: 300 },
        //     angle: { min: 0, max: 360 },
        //     scale: { start: 1, end: 0 },
        //     blendMode: 'ADD',
        //     lifespan: 1000,
        //     gravityY: 200
        // });
        // emitter.explode(50);
        // this.time.delayedCall(1200, () => emitter.stop(), [], this);

        startNextWave.call(this);
    }
}

function useActivableItem(itemName, scene) {
  const itemData = playerInventory.activableItems[itemName];
  const time = scene.time.now;

  if (itemData && itemData.count > 0 && itemData.ready) {
      // Aplica efeito de item passivo "Fonte de Energia Extra" para cooldown
      let finalCooldown = itemData.cooldown;
      if (playerInventory.passiveItems["Fonte de Energia Extra"]) {
          finalCooldown *= 0.85; // Reduz cooldown em 15%
      }

      itemData.ready = false;
      itemData.lastUsed = time;

      switch (itemName) {
          case "Óculos de Visão Térmica":
              inventoryUI.displayTemporaryEffect("Visão Térmica Ativada!", 5);
              enemies.children.each(enemy => {
                  if (enemy.active) {
                      enemy.setTint(0x00FF00); // Exemplo: inimigos ficam verdes
                  }
              });
              scene.time.delayedCall(5000, () => {
                enemies.children.each(enemy => {
                    if (enemy.active) {
                        enemy.setTint(0xFFFFFF); // Restaura cor original
                    }
                });
              }, [], scene);
              break;
          case "Módulo de Escudo":
              player.setAlpha(0.5);
              player.immune = true;
              inventoryUI.displayTemporaryEffect("Escudo Ativo!", 5);
              // Melhoria: Efeito visual para o escudo
              scene.tweens.add({
                  targets: player,
                  alpha: { from: 1, to: 0.5 },
                  duration: 200,
                  ease: 'Power1'
              });
              scene.time.delayedCall(5000, () => {
                  player.setAlpha(1);
                  player.immune = false;
              }, [], scene);
              break;
          case "Circuito de Sobrecarga":
              const originalDamage = playerDamage;
              playerDamage *= 2.5;
              inventoryUI.displayTemporaryEffect("Sobrecarga de Dano!", 3);
              scene.time.delayedCall(3000, () => {
                  playerDamage = originalDamage;
              }, [], scene);
              break;
          case "DPE (Dispositivo de Posicionamento Espacial)":
              const newX = Phaser.Math.Between(player.x - 100, player.x + 100);
              const newY = Phaser.Math.Between(player.y - 100, player.y + 100);
              player.setPosition(newX, newY);
              inventoryUI.displayTemporaryEffect("Teleporte!", 1);
              break;
          case "Ampola de Cura":
              playerHealth = Math.min(playerMaxHealth, playerHealth + 50);
              healthText.setText(`Health: ${playerHealth}/${playerMaxHealth}`);
              inventoryUI.displayTemporaryEffect("Cura Rápida!", 1);
              break;
          case "Projetor Holográfico":
                createHolographicClone.call(scene);
                inventoryUI.displayTemporaryEffect("Clone Holográfico Implantado!", 5);
                break;
      }

      // Otimização: Garante que o timer anterior seja removido antes de criar um novo
      if (itemData.cooldownTimer) itemData.cooldownTimer.remove(false);
      itemData.cooldownTimer = scene.time.delayedCall(finalCooldown, () => {
          itemData.ready = true;
          inventoryUI.updateInventoryDisplay();
          itemData.cooldownTimer = null; // Limpa a referência
      }, [], scene);
  } else if (itemData && !itemData.ready) {
      const remainingTime = Math.ceil((itemData.cooldown - (time - itemData.lastUsed)) / 1000);
      inventoryUI.displayTemporaryEffect(`${itemName} em Recarga: ${remainingTime}s`, 1);
  }
}

function endGame(scene) {
    gameOver = true;
    player.setTint(0xff0000);
    scene.physics.pause();

    // Melhoria: Camera Shake intenso no Game Over
    scene.cameras.main.shake(500, 0.02);

    // Otimização: Limpar TODOS os grupos ativos para liberar memória
    bullets.clear(true, true);
    enemies.clear(true, true);
    enemyBullets.clear(true, true);
    armas.clear(true, true);
    itemsGroup.clear(true, true);
    obstaclesGroup.clear(true, true);
    powerUpGroup.clear(true, true);
    cursedItemGroup.clear(true, true);
    holographicClonesGroup.clear(true, true);

    // Otimização: Destruir elementos de UI específicos do boss e outros elementos temporários
    if (bossHealthBar) bossHealthBar.destroy();
    if (bossHealthBarBackground) bossHealthBarBackground.destroy();
    if (bossNameText) bossNameText.destroy();
    if (temporaryEffectText) temporaryEffectText.destroy();
    if (comboText) comboText.destroy(); // Destruir o comboText também

    // Otimização: Remover TODOS os timers para evitar callbacks indesejados após o game over
    if (temporaryEffectTimer) temporaryEffectTimer.remove(false);
    if (frenzyTimer) frenzyTimer.remove(false);
    if (playerSpeedRestoreTimer) playerSpeedRestoreTimer.remove(false);
    if (frenzyTintTween) frenzyTintTween.stop(); // Parar tween de brilho
    // Remover timers específicos dos obstáculos (se existirem)
    obstaclesGroup.children.each(obstacle => {
        if (obstacle.pulseEvent) obstacle.pulseEvent.remove(false);
        if (obstacle.fireEvent) obstacle.fireEvent.remove(false);
    });

    // Reinicializar variáveis do jogo é feito em resetGameVariables
    scene.add.text(config.width / 2, config.height / 2, 'GAME OVER', {
        fontSize: '64px',
        fill: '#FF0000',
        fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(200);

    scene.add.text(config.width / 2, config.height / 2 + 70, `Score Final: ${score}`, {
        fontSize: '32px',
        fill: '#FFFFFF'
    }).setOrigin(0.5).setDepth(200);

    scene.add.text(config.width / 2, config.height / 2 + 120, 'Clique para Reiniciar', {
        fontSize: '24px',
        fill: '#FFFFFF'
    }).setOrigin(0.5).setDepth(200);


    scene.input.once('pointerdown', () => {
        resetGameVariables();
        scene.scene.restart();
    });
}

function resetGameVariables() {
    playerHealth = 100;
    playerMaxHealth = 100;
    playerSpeed = 400;
    originalPlayerSpeed = 400; // Garante que esta variável seja resetada também
    playerDamage = 10;
    score = 0;
    wave = 1;
    enemiesToSpawn = 5;
    enemiesKilledThisWave = 0;
    enemySpawnDelay = 1000;
    lastEnemySpawnTime = 0;
    gameOver = false;
    bossMode = false;
    boss = null; // Reset boss reference
    killStreak = 0;
    frenzyActive = false;
    frenzyTimer = null; // Resetar timers
    playerOriginalDamage = 10;
    playerOriginalTint = 0xFFFFFF;
    playerIsSlowed = false;
    playerSpeedRestoreTimer = null; // Resetar timers
    temporaryEffectText = null; // Resetar referência de texto
    temporaryEffectTimer = null; // Resetar timers
    currentWeapon = 'pistol';
    frenzyTintTween = null; // Resetar a referência do tween

    for (const itemKey in playerInventory.activableItems) {
        playerInventory.activableItems[itemKey].ready = true;
        playerInventory.activableItems[itemKey].lastUsed = 0;
        // Otimização: Remover quaisquer timers de cooldown remanescentes
        if (playerInventory.activableItems[itemKey].cooldownTimer) {
            playerInventory.activableItems[itemKey].cooldownTimer.remove(false);
            playerInventory.activableItems[itemKey].cooldownTimer = null;
        }
    }
}

const game = new Phaser.Game(config);
</script>
</body>
</html>
